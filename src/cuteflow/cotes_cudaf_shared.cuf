attributes(global) subroutine cotes_cudaf3(surf_d, zm_d,vdlg_d)
  ! Cacul du flux HLLC avec methode riadh
  ! Article : A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications, Riadh et al.

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine solver_Riemann_hllc(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
      use global_device
      implicit none

      integer, intent(in)                   :: kvol, kvoisin
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(nelt_d), intent(in)     :: surf
      real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg
    end subroutine solver_Riemann_hllc

    attributes(device) subroutine solver_Riemann_riadh(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
      use global_device
      implicit none

      integer, intent(in)                   :: kvol, kvoisin
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(nelt_d), intent(in)     :: surf
      real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg
    end subroutine solver_Riemann_riadh

    attributes(device) subroutine solver_Riemann_waf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,kvol_v1,kvol_v1_h,kvol_v1_u,kvol_v1_v,kvol_v2, kvol_v2_h,kvol_v2_u,kvol_v2_v,kvoisin_v1,kvoisin_v1_h,kvoisin_v1_u,kvoisin_v1_v,kvoisin_v2,kvoisin_v2_h,kvoisin_v2_u,kvoisin_v2_v,flux,ln,pp)
      use global_device
      implicit none

      integer, intent(in)                   :: kvol, kvoisin
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(nelt_d), intent(in)     :: surf
      real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg
      real(fp_kind)               :: kvol_v1_h, kvol_v1_u, kvol_v1_v
      real(fp_kind)               :: kvol_v2_h, kvol_v2_u, kvol_v2_v
      real(fp_kind)               :: kvoisin_v1_h, kvoisin_v1_u, kvoisin_v1_v
      real(fp_kind)               :: kvoisin_v2_h, kvoisin_v2_u, kvoisin_v2_v
      integer :: kvol_v1, kvol_v2, kvoisin_v1, kvoisin_v2
    end subroutine solver_Riemann_waf

  end interface

  real(fp_kind), dimension(nelt_d), intent(in)      :: surf_d, zm_d
  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)    :: vdlg_d

  integer                     :: i, nc1, nc2, kvoisin, dl,pp, nc3, kvol, kv
  real(fp_kind)               :: x1, x2, y1, y2, ln, x3, y3
  real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr, hijet, hjiet, zij
  integer               :: kvol_v1, kvol_v2, kvoisin_v1, kvoisin_v2
  real(fp_kind)               :: kvol_v1_h, kvol_v1_u, kvol_v1_v
  real(fp_kind)               :: kvol_v2_h, kvol_v2_u, kvol_v2_v
  real(fp_kind)               :: kvoisin_v1_h, kvoisin_v1_u, kvoisin_v1_v
  real(fp_kind)               :: kvoisin_v2_h, kvoisin_v2_u, kvoisin_v2_v
  real(fp_kind)               :: zero, debitnorm, orient
  real(fp_kind), dimension(2) :: norm
  real(fp_kind), dimension(3) :: flux
  real :: cond

  integer                     :: ti,gi, tj, gj, id_entree
  real(fp_kind), shared       :: s1(blockdim%x,ns_d)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti
  tj = threadIdx%y
  gj=  (blockIdx%y - 1)*blockDim%y + tj

  zero = 0.d0

  !   Retrieve a neighboring cell dry ===============================
  ! do it outside and see if un_voisin_sec is being used here    

  if(gi <= nelt_d-nelt_fant_recep_d) then
    ! write(*,*),gi,"launch"
    kvol = gi
    nc1 = tj
    cond = merge(1,0, nc1 == ns_d)
    nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))
    cond = merge(1,0, nc2 == ns_d)
    nc3 = int((nc2 - ns_d + 1)*cond + (nc2 + 1)*(1-cond))

    x1 = coo_table_elemwise_d(gi, 3*nc1-2)
    y1 = coo_table_elemwise_d(gi, 3*nc1-1)

    x2 = coo_table_elemwise_d(gi, 3*nc2-2)
    y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

    x3 = coo_table_elemwise_d(gi, 3*nc3-2)
    y3 = coo_table_elemwise_d(gi, 3*nc3-1) 

    ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

    norm(1) = ( y2 - y1 ) / ln
    norm(2) = ( x1 - x2 ) / ln

    orient = norm(1)*((x1+x2)/2.-(x1+x2+x3)/3.) + norm(2)*((y1+y2)/2.-(y1+y2+y3)/3.)
    if(orient < 0.) then
      norm(1) = ( y1 - y2 ) / ln
      norm(2) = ( x2 - x1 ) / ln
    end if

    ! *** initialisation du flux ***
    flux     = 0.d0
    kvoisin = boundary_d(gi,nc1,1)
    id_entree = boundary_d(gi,nc1,2)

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(1,gi)
      s1(ti,2) = zm_d(gi)
    endif

    call syncthreads()

    hautl  = s1(ti,1)
    zml    = s1(ti,2)

    call syncthreads()

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(2,gi)
      s1(ti,2) = vdlg_d(3,gi)
    endif

    call syncthreads()

    hul    = s1(ti,1)
    hvl    = s1(ti,2)

    call syncthreads()

    vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
    vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl

    ! *** application des conditions aux limites si kvol est frontier ***
    if ( kvoisin == -1 ) then ! *** flux entrant ***
      if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
        flux(1) = hautl * vitul
        flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
        flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
      elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
        debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
        flux(1) = debitnorm
        flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
        flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
        debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
        debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
      else
        write(*,*) 'donnee inlet_d non convenable'
      endif
    endif

    if ( kvoisin == -2 ) then ! *** flux sortant ***
      if ( vitul > tolisec_d .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
        hautl = h_sortie_d(id_entree) - zml
        hautl = max(0.0D0, hautl)
        flux(1) = hautl * vitul
        flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
        flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
      else
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl**2/2.
        flux(3) = norm(2) * gp_d * hautl**2/2.
      endif

      debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln

    endif

    if ( kvoisin == -3 ) then  ! *** flux de mur ***
      flux(1) = 0.d0
      flux(2) = norm(1) * gp_d * hautl**2/2.
      flux(3) = norm(2) * gp_d * hautl**2/2.
    endif

    if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
      hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
      zmr = zm_d(kvoisin)        !this is also inefficient global memory access

      zij = max(zml,zmr)
      hijet = hautl + zml - zij
      hijet = max(0.0D0, hijet)

      hjiet = hautr + zmr - zij
      hjiet = max(0.0D0, hjiet)

      hur   = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
      hvr   = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

      vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
      vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr

      if(iflux_d==1) then
        !!HLLC
        call solver_Riemann_hllc(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,flux,ln,pp)
      else if(iflux_d==2) then 
        !!WAF méthode riadh ata
        call solver_Riemann_riadh(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,flux,ln,pp)
      else if (iflux_d==3) then 
        !! WAF Loukilli
        !! Order 2 second neighbor
        !! kvol_v1 est le premier voisin de kvol
        !! kvol_v2 est le second voisin de kvol
        !! kvoisin est le voisin de kvol à traver l'interface qu'on regarde
        kv=1
        kvol_v1 = boundary_d(kvol,kv,1)
        if(kvol_v1 == kvoisin) then
          kv=kv+1
          kvol_v1 = boundary_d(kvol,kv,1)
        end if
        kv=kv+1
        kvol_v2 = boundary_d(kvol,1+mod(kv-1,3),1)
        if(kvol_v2 == kvoisin) then
          kv=kv+1
          kvol_v2 = boundary_d(kvol,1+mod(kv-1,3),1)
        end if


        if(kvol_v1 < 1) then
          kvol_v1 = kvol
        end if

        if(kvol_v2 < 1) then
          kvol_v2 = kvol
        end if

        kvol_v1_h = vdlg_d(1,kvol_v1)
        if(kvol_v1_h>tolisec_d) then
          kvol_v1_u = (vdlg_d(2,kvol_v1) * norm(1) + vdlg_d(3,kvol_v1) * norm(2))/kvol_v1_h
          kvol_v1_v = (vdlg_d(3,kvol_v1) * norm(1) - vdlg_d(2,kvol_v1) * norm(2))/kvol_v1_h
        else
          kvol_v1_h = tolisec_d
          kvol_v1_u = 0.
          kvol_v1_v = 0.
        end if

        kvol_v2_h = vdlg_d(1,kvol_v2)
        if(kvol_v2_h>tolisec_d) then
          kvol_v2_u = (vdlg_d(2,kvol_v2) * norm(1) + vdlg_d(3,kvol_v2) * norm(2))/kvol_v2_h
          kvol_v2_v = (vdlg_d(3,kvol_v2) * norm(1) - vdlg_d(2,kvol_v2) * norm(2))/kvol_v2_h
        else
          kvol_v2_h = tolisec_d
          kvol_v2_u = 0.
          kvol_v2_v = 0.
        end if

        kv=1
        kvoisin_v1 = boundary_d(kvoisin,kv,1)
        if(kvoisin_v1 == kvol) then
          kv=kv+1
          kvoisin_v1 = boundary_d(kvoisin,kv,1)
        end if
        kv=kv+1
        kvoisin_v2 = boundary_d(kvoisin,1+mod(kv-1,3),1)
        if(kvoisin_v2 == kvol) then
          kv=kv+1
          kvoisin_v2 = boundary_d(kvoisin,1+mod(kv-1,3),1)
        end if

        ! write(*,*),kvoisin,kvoisin_v1,kvoisin_v2
        ! write(*,*),kvol,kvol_v1,kvol_v2

        if(kvoisin_v1 < 1) then
          kvoisin_v1 = kvoisin
        end if

        if(kvoisin_v2 < 1) then
          kvoisin_v2 = kvoisin
        end if

        kvoisin_v1_h = vdlg_d(1,kvoisin_v1)
        if(kvoisin_v1_h>tolisec_d) then
          kvoisin_v1_u = (vdlg_d(2,kvoisin_v1) * norm(1) + vdlg_d(3,kvoisin_v1) * norm(2))/kvoisin_v1_h
          kvoisin_v1_v = (vdlg_d(3,kvoisin_v1) * norm(1) - vdlg_d(2,kvoisin_v1) * norm(2))/kvoisin_v1_h
        else
          kvoisin_v1_h = tolisec_d
          kvoisin_v1_u = 0.
          kvoisin_v1_v = 0.
        end if

        kvoisin_v2_h = vdlg_d(1,kvoisin_v2)
        if(kvoisin_v2_h>tolisec_d) then
          kvoisin_v2_u = (vdlg_d(2,kvoisin_v2) * norm(1) + vdlg_d(3,kvoisin_v2) * norm(2))/kvoisin_v2_h
          kvoisin_v2_v = (vdlg_d(3,kvoisin_v2) * norm(1) - vdlg_d(2,kvoisin_v2) * norm(2))/kvoisin_v2_h
        else
          kvoisin_v2_h = tolisec_d
          kvoisin_v2_u = 0.
          kvoisin_v2_v = 0.
        end if

        ! print*,kvol,kvoisin,kvol_v1,kvol_v2
        ! if(kvol==3269) then
        !   write(*,*) "dindon", kvol, kvol_v1, kvol_v2, kvoisin, kvoisin_v1, kvoisin_v2
        ! end if

        if(((kvol_v1 == kvol) .or. (kvol_v2==kvol)) .or. ((kvoisin_v1==kvoisin) .or. (kvoisin_v2==kvoisin))) then
          ! write(*,*),kvol,kvol_v1,kvol_v2, "bords"
          call solver_Riemann_riadh(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,flux,ln,pp)
        else
          ! write(*,*),kvol,kvol_v1,kvol_v2
          call solver_Riemann_waf(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,kvol_v1,kvol_v1_h,kvol_v1_u,kvol_v1_v,kvol_v2,kvol_v2_h,kvol_v2_u,kvol_v2_v,kvoisin_v1,kvoisin_v1_h,kvoisin_v1_u,kvoisin_v1_v,kvoisin_v2,kvoisin_v2_h,kvoisin_v2_u,kvoisin_v2_v,flux,ln,pp)
        end if

      end if ! de choix schéma iflux

    endif ! de ( kvoisin > 0. )

    s1(ti, tj)   = flux(1) * ln
    call syncthreads()

    if(tj == 1)  resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(2) * ln
    call syncthreads()

    if(tj == 1)  resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(3) * ln
    call syncthreads()

    if(tj == 1)  resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)

  endif
end subroutine cotes_cudaf3

attributes(device) subroutine limiter(r, c, A)
  use precision_m
  use global_device

  implicit none

  real(fp_kind), intent(in) :: r, c 
  real(fp_kind), intent(inout) :: A

  if(ilimiteur_d==0) then
    !!Reduction to HLLC
    A =1.

  else if(ilimiteur_d==1) then

    !!!Superbee
    if(r<=0) then 
      A = 1.
    else if(r>0. .and. r<0.5) then
      A = 1-2*(1-abs(c))*r
    else if(r>0.5 .and. r<1.) then
      A = abs(c)
    else if(r>1. .and. r<2.) then
      A = 1-(1-abs(c))*r
    else
      A = 2*abs(c)-1.
    end if

  else if(ilimiteur_d==2) then

    !!Leer
    if(r<=0) then 
      A = 1.
    else
      A = 1-2*(1-abs(c))*r/(1+r)
    end if

  else if(ilimiteur_d==3) then

    !!ALbada
    if(r<=0) then 
      A = 1.
    else
      A = 1.-2.*(1.-abs(c))*r*(1+r)/(1+r*r)
    end if

  else if(ilimiteur_d==4) then

    !!Minbee
    if(r<=0) then
      A = 1.
    else if(r<=1) then
      A = 1 - (1-abs(c))*r
    else
      A = abs(c)
    end if

end if

end subroutine limiter

attributes(device) subroutine solver_Riemann_waf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,kvol_v1,kvol_v1_h,kvol_v1_u,kvol_v1_v,kvol_v2, kvol_v2_h,kvol_v2_u,kvol_v2_v,kvoisin_v1,kvoisin_v1_h,kvoisin_v1_u,kvoisin_v1_v,kvoisin_v2,kvoisin_v2_h,kvoisin_v2_u,kvoisin_v2_v,flux,ln,pp)
  ! Solveur tiré de : "Numerical Tracking of Shallow Water Waves by the Unstructured Finite Volume WAF Approximation" 
  !  Loukili et Soulaimani 2007

  use precision_m
  use global_device
  use main_prog_variables
  implicit none


  interface
    attributes(device) subroutine limiter(r,c,A)
      use precision_m
      use global_device

      implicit none

      real(fp_kind), intent(in) :: r, c 
      real(fp_kind), intent(inout) :: A
    end subroutine
  end interface

  integer, intent(in)                         :: kvol, kvoisin
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(nelt_d), intent(in)     :: surf
  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg
  integer :: kvol_v1, kvol_v2, kvoisin_v1, kvoisin_v2
  real(fp_kind)               :: kvol_v1_h, kvol_v1_u, kvol_v1_v
  real(fp_kind)               :: kvol_v2_h, kvol_v2_u, kvol_v2_v
  real(fp_kind)               :: kvoisin_v1_h, kvoisin_v1_u, kvoisin_v1_v
  real(fp_kind)               :: kvoisin_v2_h, kvoisin_v2_u, kvoisin_v2_v

  integer                       :: i 
  real(fp_kind)                 :: eps
  real(fp_kind), dimension(3)   :: flux1, flux_hllc, flux_waf
  real(fp_kind), dimension(2,3) :: f, q
  real(fp_kind), dimension(3) :: fet, qet
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond
  real(fp_kind) :: dtoverdx, cr, cl, cet, wl, wlet, wlr, wr, wret
  real(fp_kind) :: rr, rl, ret, hl_upw, hr_upw, vr_upw, vl_upw, delta_loc_l, delta_loc_r, delta_loc_et
  real(fp_kind) :: delta_upw_r, delta_upw_l, delta_upw_et, limit_l, limit_r, limit_et

  eps = 1e-16

  pp = pp + 1

  if(hl.lt.eps.and.hr.lt.eps) goto 20

  al = sqrt( gp_d * hl )
  ar = sqrt( gp_d * hr )

  het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
  uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

  if ( het.lt.hl ) then
    pql = 1.
  else
    if(hl.gt.eps) then
      pql = sqrt(0.5*(het+hl)*het/hl**2)
    else
      pql = 0.
    end if
  endif

  if ( het.lt.hr ) then
    pqr = 1.
  else
    if(hr.gt.eps) then
      pqr = sqrt(0.5*(het+hr)*het/hr**2)
    else
      pqr = 0.
    end if
  endif

  20 continue

  if ( hl.gt.eps ) then
    sl = ul-al*pql
  else
    sl  = ur - 2 * ar
    sr  = ur + ar
    goto 35
  end if

  if ( hr.gt.eps ) then
    sr = ur+ar*pqr
  else
    sl  = ul - al
    sr  = ul + 2 * al
    goto 35
  end if

  35 continue

  denom = hr*(ur-sr)-hl*(ul-sl)
  if(abs(denom).lt.eps) then
    set = uet
  else
    set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
  end if

  !Calcul de Ql et Qr
  q(1,1) = hl
  q(1,2) = hl*ul
  q(1,3) = hl*vl

  q(2,1) = hr
  q(2,2) = hr*ur
  q(2,3) = hr*vr

  !!Cacul de G(Ul)
  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
  f(1,3) = hl * ul * vl

  !!Cacul de G(Ur)
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
  f(2,3) = hr * ur * vr

  !!G(U*) 
  fet = (sr*f(1,:)-sl*f(2,:)+sl*sr*(q(2,:)-q(1,:)))/(sr-sl+eps) !!HLL classique

  !Flux HLLC
  if (sl > 0) then ! G(Ul)
    flux_hllc(:) = f(1,:)
  else if (sr < 0) then ! G(Ur)
    flux_hllc(:) = f(2,:)
  else
    flux_hllc(:) = fet(:)
    !Correction HLLC
    if(set > 0) then
      flux_hllc(3) = flux_hllc(1) * vl
    else
      flux_hllc(3) = flux_hllc(1) * vr
    end if
  endif

  dtoverdx =  1.8*dt_d/min(cotemin_arr_d(kvoisin), cotemin_arr_d(kvol)) !!cotemin_arr_d is 1.8*inscribed_circle_radius

  cr = sr * dtoverdx
  cl = sl * dtoverdx
  cet = set * dtoverdx

  !! TVD stabilization 
  delta_loc_r = hr-hl
  delta_loc_l = hr-hl
  delta_loc_et = vr-vl

  hl_upw=(surf_d(kvol_v1)*kvol_v1_h+surf_d(kvol_v2)*kvol_v2_h)/(surf_d(kvol_v1)+surf_d(kvol_v2))
  hr_upw=(surf_d(kvoisin_v1)*kvoisin_v1_h+surf_d(kvoisin_v2)*kvoisin_v2_h)/(surf_d(kvoisin_v1)+surf_d(kvoisin_v2))

  vl_upw=(surf_d(kvol_v1)*kvol_v1_v+surf_d(kvol_v2)*kvol_v2_v)/(surf_d(kvol_v1)+surf_d(kvol_v2))
  vr_upw=(surf_d(kvoisin_v1)*kvoisin_v1_v+surf_d(kvoisin_v2)*kvoisin_v2_v)/(surf_d(kvoisin_v1)+surf_d(kvoisin_v2))

  if(sr>0) then
    delta_upw_r = hl-hl_upw
  else
    delta_upw_r = hr_upw-hr
  endif

  if(sl>0) then
    delta_upw_l = hl-hl_upw
  else
    delta_upw_l = hr_upw-hr
  endif

  if(set>0) then
    delta_upw_et = vl-vl_upw
  else
    delta_upw_et = vr_upw-vr
  endif

  rl = delta_upw_l/(delta_loc_l + eps)
  rr = delta_upw_r/(delta_loc_r + eps)
  ret = delta_upw_et/(delta_loc_et + eps)

  call limiter(rl,cl,limit_l)
  call limiter(rr,cr,limit_r)
  call limiter(ret,cet,limit_et)

  wl = (1 + dsign(1.d0,sl) * limit_l)/2.
  wlet = (1 + dsign(1.d0,set) * limit_et)/2.

  wlr = (dsign(1.d0,sr)*limit_r - dsign(1.d0,sl)*limit_l)/2.

  wr = (1 - dsign(1.d0,sr) * limit_r)/2.
  wret = (1 - dsign(1.d0,set) * limit_et)/2.

  flux_waf(1) = wl*f(1,1) + wlr*flux_hllc(1) + wr*f(2,1)
  flux_waf(2) = wl*f(1,2) + wlr*flux_hllc(2) + wr*f(2,2)
  flux_waf(3) = (wlet*vl + wret*vr)*flux_waf(1)

  ! *** reprojection du flux ***
  flux(1) = flux_waf(1)
  flux(2) = norm(1)*flux_waf(2) - norm(2)*flux_waf(3)
  flux(3) = norm(2)*flux_waf(2) + norm(1)*flux_waf(3)                       
end subroutine solver_Riemann_waf

attributes(device) subroutine solver_Riemann_hllc(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
  ! HLLC classique
  ! Solveur tiré de : "Numerical Tracking of Shallow Water Waves by the Unstructured Finite Volume WAF Approximation" 
  !  Loukili et Soulaimani 2007

  use precision_m
  use global_device
  use main_prog_variables
  implicit none

  integer, intent(in)                         :: kvol, kvoisin
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(nelt_d), intent(in)     :: surf
  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg

  integer                       :: i 
  real(fp_kind)                 :: eps
  real(fp_kind), dimension(3)   :: flux1, flux_hllc
  real(fp_kind), dimension(2,3) :: f, q
  real(fp_kind), dimension(3) :: fet, qet
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond

  eps = 1e-8

  pp = pp + 1

  if(hl.lt.eps.and.hr.lt.eps) goto 20

  al = sqrt( gp_d * hl )
  ar = sqrt( gp_d * hr )

  het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
  uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

  if ( het.lt.hl ) then
    pql = 1.
  else
    if(hl.gt.eps) then
      pql = sqrt(0.5*(het+hl)*het/hl**2)
    else
      pql = 0.
    end if
  endif

  if ( het.lt.hr ) then
    pqr = 1.
  else
    if(hr.gt.eps) then
      pqr = sqrt(0.5*(het+hr)*het/hr**2)
    else
      pqr = 0.
    end if
  endif

  20 continue

  if ( hl.gt.eps ) then
    sl = ul-al*pql
  else
    sl  = ur - 2 * ar
    sr  = ur + ar
    goto 35
  end if

  if ( hr.gt.eps ) then
    sr = ur+ar*pqr
  else
    sl  = ul - al
    sr  = ul + 2 * al
    goto 35
  end if

  35 continue

  denom = hr*(ur-sr)-hl*(ul-sl)
  if(abs(denom).lt.eps) then
    set = uet
  else
    set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
  end if

  !Calcul de Ql et Qr
  q(1,1) = hl
  q(1,2) = hl*ul
  q(1,3) = hl*vl

  q(2,1) = hr
  q(2,2) = hr*ur
  q(2,3) = hr*vr

  !!Cacul de G(Ul)
  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
  f(1,3) = hl * ul * vl

  !!Cacul de G(Ur)
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
  f(2,3) = hr * ur * vr

  !!G(U*) 
  fet = (sr*f(1,:)-sl*f(2,:)+sl*sr*(q(2,:)-q(1,:)))/(sr-sl+eps) !!HLL classique

  !Flux HLLC
  if (sl > 0) then ! G(Ul)
    flux_hllc(:) = f(1,:)
  else if (sr < 0) then ! G(Ur)
    flux_hllc(:) = f(2,:)
  else
    flux_hllc(:) = fet(:)
    !Correction HLLC
    if(set > 0) then
      flux_hllc(3) = flux_hllc(1) * vl
    else
      flux_hllc(3) = flux_hllc(1) * vr
    end if
  endif

  flux(1) = flux_hllc(1)
  flux(2) = norm(1) * flux_hllc(2) - norm(2) * flux_hllc(3)
  flux(3) = norm(2) * flux_hllc(2) + norm(1) * flux_hllc(3)                       
end subroutine solver_Riemann_hllc


attributes(device) subroutine solver_Riemann_riadh(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
  ! Import des routines de Riadh ATA pour HLLC
  ! Méthode de l'article : 
  ! A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications
  ! Riadh ATA et al.
  use precision_m
  use global_device
  implicit none

  integer, intent(in)                         :: kvol, kvoisin
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(nelt_d), intent(in)     :: surf
  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg

  integer                       :: i 
  real(fp_kind)                 :: eps
  real(fp_kind), dimension(3)   :: flux1
  real(fp_kind), dimension(2,3) :: f, q, fet, qet
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond

  eps = 1e-6

  pp = pp + 1

  if(hl.lt.eps.and.hr.lt.eps) goto 20

  al = sqrt( gp_d * hl )
  ar = sqrt( gp_d * hr )

  het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
  uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

  if ( het.lt.hl ) then
    pql = 1.
  else
    if(hl.gt.eps) then
      pql = sqrt(0.5*(het+hl)*het/hl**2)
    else
      pql = 0.
    end if
  endif

  if ( het.lt.hr ) then
    pqr = 1.
  else
    if(hr.gt.eps) then
      pqr = sqrt(0.5*(het+hr)*het/hr**2)
    else
      pqr = 0.
    end if
  endif

  20 continue

  if ( hl.gt.eps ) then
    sl = ul-al*pql
  else
    sl  = ur - 2 * ar
    sr  = ur + ar
    goto 35
  end if

  if ( hr.gt.eps ) then
    sr = ur+ar*pqr
  else
    sl  = ul - al
    sr  = ul + 2 * al
    goto 35
  end if

  35 continue

  denom = hr*(ur-sr)-hl*(ul-sl)
  if(abs(denom).lt.eps) then
    set = uet
  else
    set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
  end if

  !Calcul de Ql et Qr (Riadh)
  q(1,1) = hl
  q(1,2) = hl*ul
  q(1,3) = hl*vl

  q(2,1) = hr
  q(2,2) = hr*ur
  q(2,3) = hr*vr

  !!Calcul de Qetl et Qetr
  if(abs(sl-set).gt.eps) then
    pond = hl*(sl-ul)/(sl-set)
  else
    pond= 0.D0
  End if

  qet(1,1) = pond
  qet(1,2) = pond*set
  qet(1,3) = pond*vl


  if(abs(sr-set).gt.eps) then
    pond = hr*(sr-ur)/(sr-set)
  else
    pond= 0.D0
  end if

  qet(2,1) = pond
  qet(2,2) = pond*set
  qet(2,3) = pond*vr

  !!Cacul de G(Ul)
  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
  f(1,3) = hl * ul * vl

  !!Cacul de G(Ur)
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
  f(2,3) = hr * ur * vr

  fet(1,1) = f(1,1) + sl*(qet(1,1)-q(1,1))
  fet(1,2) = f(1,2) + sl*(qet(1,2)-q(1,2))
  fet(1,3) = f(1,3) + sl*(qet(1,3)-q(1,3))

  fet(2,1) = f(2,1) + sr*(qet(2,1)-q(2,1))
  fet(2,2) = f(2,2) + sr*(qet(2,2)-q(2,2))
  fet(2,3) = f(2,3) + sr*(qet(2,3)-q(2,3))

  !Flux HLLC
  if (0.lt.sl) then
    flux1(1) = f(1,1)
    flux1(2) = f(1,2)
    flux1(3) = f(1,3)
  elseif (0.lt.set.and.0.gt.sl) then
    flux1(1) = fet(1,1)
    flux1(2) = fet(1,2)
    flux1(3) = fet(1,3)
  elseif (0.gt.set.and.0.lt.sr) then
    flux1(1) = fet(2,1)
    flux1(2) = fet(2,2)
    flux1(3) = fet(2,3)
  else
    flux1(1) = f(2,1)
    flux1(2) = f(2,2)
    flux1(3) = f(2,3)
  endif

  ! *** reprojection du flux ***
  flux(1) = flux1(1)
  flux(2) = norm(1) * flux1(2) - norm(2) * flux1(3)
  flux(3) = norm(2) * flux1(2) + norm(1) * flux1(3)                       
end subroutine solver_Riemann_riadh
