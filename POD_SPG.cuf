!*************************************************************************************************************
! POD_SPG : Routines reservés au modèle reduit
!            Contient les routines : pod_snapshot ; prod_Mpk_vect; prod_tenseur_vect; prod_scalaire; debit_POD ; 
!                                    matrice_POD ; OD_PID_ROM_matrices; pod_source_friction; POD_ROM_matrices
!                                       
!**************************************************************************************************************
!
! =============================================================================================================
!
subroutine pod_snapshot(vdlg, vdlg0, vdlg1, vdlg01)
!
    use precision_m
    use global
    use m_param
!
    implicit none
! ... variables passees en parametre ...................................
!   integer ,  intent(in)               :: ni, nj, droite    ! (droite =1 si le vecteur est a droite)
!   real(fp_kind), dimension(:),  intent(in)  :: vect1
!   real(fp_kind), dimension(:),  intent(out) :: vect2
    real(fp_kind), dimension(:,:), intent(inout) :: vdlg, vdlg0, vdlg1, vdlg01
!
! ... variables locales
    integer   :: iel, j, k  
    real(fp_kind)   ::  scal, scal1, scal2, scal3, aux
!
!-----------------------------------------------------------------------------------------------------------------
!
    if (shot==1 .and. pod==0) then
        if (start == 1) then
            write(ec_param_pod,'(3i)') nelt, nsnap+1, n_seq_base    ! Création du fichier du nombre total d'éléments pour le program Matlab - POD
            do iel = 1, nelt
                if ( vdlg0(iel,1) > tolisec ) then
                    scal1 = 1/vdlg0(iel,1)
                    scal2 = vdlg01(iel,2)/vdlg0(iel,1)
                    scal3 = vdlg01(iel,3)/vdlg0(iel,1)
                else
                    scal1 = 0.d0
                    scal2 = 0.d0
                    scal3 = 0.d0
                endif   
                !               
                write(4999,'(8f16.6)')  vdlg01(iel,1)
                write(501,'(8f16.6)')  vdlg01(iel,1) - H_aval
                write(502,'(8f16.6)')  vdlg01(iel,2)
                write(503,'(8f16.6)')  vdlg01(iel,3)
                write(504,'(8f16.6)')  vdlg0(iel,1)
                write(505,'(8f16.6)')  scal2
                write(506,'(8f16.6)')  scal3
            enddo
        else
            if ( abs( tc - tvis3d2(compt_snap) ) < 1.0E-01) then
                do iel = 1, nelt            
                    if ( vdlg(iel,1) > tolisec ) then
                        scal2 = (vdlg1(iel,2)/vdlg(iel,1))
                        scal3 = (vdlg1(iel,3)/vdlg(iel,1))
                    else
                        scal2 = 0.d0
                        scal3 = 0.d0
                    endif                                       
                    write(4999,'(8f16.6)')  vdlg1(iel,1)
                    write(501,'(8f16.6)')  vdlg1(iel,1) - H_aval
                    write(502,'(8f16.6)')  vdlg1(iel,2)
                    write(503,'(8f16.6)')  vdlg1(iel,3)
                    write(504,'(8f16.6)')  vdlg (iel,1)
                    write(505,'(8f16.6)')  scal2
                    write(506,'(8f16.6)')  scal3
                    write(398,'(3f16.6)')  lamda_stock(iel,1) , lamda_stock(iel,2), lamda_stock(iel,3)
! ***             Stockage du terme source de friction pour le POD
                    if ( vdlg(iel,1) <= tolisec ) then          
                        coef_friction_pod = 0.D0
                    else
                        scal1 = sqrt( scal2**2 + scal3**2 )
                        if ( scal1 < tol ) then
                            coef_friction_pod = 0.D0        
                        else
                            coef_friction_pod = scal1 / (vdlg(iel,1)**(1.d0/3.d0))
                        endif
                    endif
                    write(555,'(f16.6)')  coef_friction_pod
                enddo
                    vdlg_moy_snap = vdlg_moy_snap + vdlg1
                    compt_snap=compt_snap+1
            endif       ! de if ( abs( tc - tvis3d2(compt_snap) ) < 1.0E-02) then

                !***    Impression dans un fichier du flux pour le POD ***
        endif
    endif
!
end subroutine pod_snapshot
!
!**************************************************************************************************************
!**************************************************************************************************************
!
subroutine prod_Mpk_vect(droite,ni,nj,mat,vect1,vect2)
!
!   Fait le produit d'une matrice par un vecteur et rend un vecteur
!
!   use global
!   use m_param
    use precision_m
!
    implicit none
! ... variables passees en parametre ...................................
    integer ,  intent(in)               :: ni, nj, droite    ! (droite =1 si le vecteur est a droite)
    real(fp_kind), dimension(:),  intent(in)  :: vect1
    real(fp_kind), dimension(:),  intent(out) :: vect2
    real(fp_kind), dimension(:,:),intent(in)  :: mat
!
! ... variables locales
    integer   :: i, j, k          
!
    if(droite ==1) then

        do i=1,ni
!
            vect2(i) = 0.d0
!
            do j=1,nj
                vect2(i) = vect2(i) + mat(i,j) * vect1(j)
            enddo
!
        enddo
    else
        do j=1,nj
!
            vect2(j) = 0.d0
!
            do i=1,ni
                vect2(j) = vect2(j) + mat(i,j) * vect1(i)
            enddo
!
        enddo
    endif
!
end subroutine prod_Mpk_vect

!*********************************************************************************************
subroutine prod_tenseur_vect(ni,nk,nj,tenseur,vect,matrx)
!
!   Fait le produit d'un tenseur par un vecteur et rend une matrice
!
!   use global
!   use m_param
!
    use precision_m
    implicit none
! ... variables passees en parametre ...................................
    integer ,  intent(in)               :: ni,nj,nk
    real(fp_kind), dimension(:),    intent(in)  :: vect
    real(fp_kind), dimension(:,:),  intent(out) :: matrx
    real(fp_kind), dimension(:,:,:),intent(in)  :: tenseur
!
! ... variables locales
    integer   :: i, j, k         
!
    do i=1,ni
!
        do j=1,nj
!
            matrx(i,j) = 0.d0
!
            do k=1,nk
                matrx(i,j) = matrx(i,j) + tenseur(i,k,j) * vect(k)
            enddo
!
        enddo
!
    enddo
!
end subroutine prod_tenseur_vect
!
!*********************************************************************************************
!*********************************************************************************************
!
subroutine prod_scalaire(ni,vect1,vect2,scal)
!
!
    use precision_m
    implicit none
! ... variables passees en parametre ...................................
    integer ,  intent(in)               :: ni
    real(fp_kind), dimension(:),  intent(in)  :: vect1, vect2
    real(fp_kind),                intent(out)  :: scal
!
! ... variables locales
    integer   :: i         
!
        scal = 0.d0
        do i=1,ni
            scal = scal + vect1(i) * vect2(i)
        enddo
!
end subroutine prod_scalaire
!==================================================================================
!
subroutine debit_POD(zm,surf)
!
! ======================================================================
!
!     debit_POD : Routine d'imposition de la condition de débit dans le POD
!
!     auteur : Jean-Marie Zokagoa  GRANIT ETSMTL
!
!     version : 2.0  ;  Mars 28 2011
! ======================================================================
!
    use precision_m
    use global
    use m_param
! ... variables passees en parametre .........................................................................................
    real(fp_kind), dimension(:),  intent(in)  :: zm, surf
!
! ... variables locales
    integer               :: iel, i, j, k, nc1, nc2
    real(fp_kind)               :: eta, hu, hv, h, auxx
    real(fp_kind)               :: ln, x1, x2, y1, y2, delta_debit_n, debit_base_n, nx, ny
    real(fp_kind), dimension(2) :: norm
!............................................................................................................................
!
    debit_n = -debitglob /long 
    delta_debit_n = -delta_Q_pod/long
    debit_base_n  = debit_n - delta_debit_n   ! débit à partir duquel la base POD a été construite 
!
    MQk_eta = 0.d0
    MQk_hu = 0.d0
    MQk_hv = 0.d0
    vol_tot_entre = 0.d0

    do iel=1,nelt_entree
!
        i  = donnees_entree(iel,1)
        ln = donnees_entree(iel,2)
        nx = donnees_entree(iel,3)
        ny = donnees_entree(iel,4)
!
        eta = 0.d0
        hu  = 0.d0
        hv  = 0.d0        
        do ii=1,maxdimbase
            if (ii <= nbase_eta) eta = eta + a0_eta(ii) * phi_eta_tild(i,ii)
!           if (ii <= nbase_eta) eta = eta + a0_eta(ii) * phi_eta(i,ii)
        enddo
!
        eta = eta + h_aval
        h   = eta - zm(i)
!               
        if(h > tolisec) then
            BQi_eta(i) = ln * debit_n
            BQi_hu(i)  = ln * nx * ((debit_n**2)/h  + gp * h * eta)   
            BQi_hv(i)  = ln * ny * ((debit_n**2)/h  + gp * h * eta)
!           BQi_hu(i)  = ln * nx * ((debit_n**2)/h )   
!           BQi_hv(i)  = ln * ny * ((debit_n**2)/h )
            
            vol_tot_entre = vol_tot_entre - debit_n*ln 
        else
            BQi_eta(i) = 0.d0
            BQi_hu(i)  = 0.d0  
            BQi_hv(i)  = 0.d0
        endif
!
        do k=1,maxdimbase
            if(k <= nbase_eta) MQk_eta(k) = MQk_eta(k) + phi_eta_tild(i,k) * BQi_eta(i) / surf(i)
!           if(k <= nbase_eta) MQk_eta(k) = MQk_eta(k) + phi_eta(i,k) * BQi_eta(i) / surf(i)
            if(k <= nbase_hu ) MQk_hu(k)  = MQk_hu(k)  + phi_hu(i,k)  * BQi_hu(i) / surf(i)
            if(k <= nbase_hv ) MQk_hv(k)  = MQk_hv(k)  + phi_hv(i,k)  * BQi_hv(i) / surf(i)
        enddo   
!
!    if ( (abs(tc-2.0)< 0.1) .or. (abs(tc-5.0)< 0.1) .or. (abs(tc-10.0)< 0.1) .or. (abs(tc-90.0)< 0.1))     write(1009,*) tc, i, h  
    
    enddo   
!
end subroutine debit_POD
!
! =============================================================================================================
! =============================================================================================================
!
subroutine matrice_POD(zm,surf)
!
    use precision_m
    use global
    use m_param
! ... variables passees en parametre .........................................................................................
    real(fp_kind), dimension(:),  intent(in)  :: zm, surf
!
! ... variables locales
    integer               :: i, j, p, p1, p2, k, nc1, nc2, kvoisin ,nb
    real(fp_kind)               :: x1, x2, y1, y2, zi, zj, xface, yface, ln 
    real(fp_kind)               :: auxij, auxij_hu, auxij_hv, auxij_u, auxij_v, auxi_j_eta, auxi_j_hu, auxi_j_hv, som, u_moy, v_moy
    real(fp_kind), dimension(2) :: norm
!............................................................................................................................
!
    nb = max(nbase_eta, nbase_hu, nbase_hv)
!
    do p1=1,nb
!
        do p=1,nb
!
            do k=1,nb
!
                if(p1 == 1) then
                    if(p <= nbase_eta .and. k <= nbase_hu)  Mpk1_hu (p,k)  = 0.d0
                    if(p <= nbase_eta .and. k <= nbase_hv)  Mpk1_hv (p,k)  = 0.d0
                    if(p <= nbase_eta .and. k <= nbase_eta) Mpk_deta(p,k)  = 0.d0
                    if(p <= nbase_hu  .and. k <= nbase_hu)  Mpk_dhu (p,k)  = 0.d0
                    if(p <= nbase_hv  .and. k <= nbase_hv)  Mpk_dhv (p,k)  = 0.d0
                    if(p <= nbase_eta .and. k <= nbase_h)   phi_h_eta(p,k) = 0.d0
                    if(p <= nbase_u   .and. k <= nbase_hu)  Mpk_u (p,k)    = 0.d0
                    if(p <= nbase_v   .and. k <= nbase_hv)  Mpk_v (p,k)    = 0.d0
!
                    if(p == 1 .and. k <= nbase_h)           phi_h_zi (k)   = 0.d0
                    if(p <= nbase_hu .and. k <= nbase_hu)   Sfxu(p,k)      = 0.d0
                    if(p <= nbase_hv .and. k <= nbase_hv)   Sfyv(p,k)      = 0.d0
!
                endif
!
                if(p1 <= nbase_hu) then 
                    if(p <= nbase_u   .and. k <= nbase_hu)  Chuu2(p1,p,k) = 0.d0
                    if(p <= nbase_u   .and. k <= nbase_hv)  Chuv2(p1,p,k) = 0.d0
                    if(p <= nbase_eta .and. k <= nbase_eta) Cg2  (p1,p,k) = 0.d0
!                   if(p <= nbase_h .and. k == 1)           Cg2_eta_tild(p1,p) = 0.d0 
                endif
                if(p1 <= nbase_hv) then
                    if(p <= nbase_v   .and. k <= nbase_hv)   Chvv3(p1,p,k) = 0.d0
                    if(p <= nbase_v   .and. k <= nbase_hu)   Chuv3(p1,p,k) = 0.d0
                    if(p <= nbase_eta .and. k <= nbase_eta)  Cg3  (p1,p,k) = 0.d0
!                   if(p <= nbase_h .and. k == 1)            Cg3_eta_tild(p1,p) = 0.d0
                endif               
!
                do i=1,nelt
!
                    if(p1 == 1) then
!
                        if(k <= nbase_hu) then
                            Bijpn1_eta(i,k) = 0.d0
                            Bi_jp_hu(i,k)   = 0.d0
                        endif
                        if(k <= nbase_hv) then
                            Bijpn2_eta(i,k) = 0.d0                      
                            Bi_jp_hv(i,k)   = 0.d0
                        endif
                        if(k <= nbase_eta) then
                            Bi_jp(i,k)          = 0.d0
                            Bijpn3_hu(i,k)      = 0.d0
                            Bijpn3_hv(i,k)      = 0.d0
!                           Bijpn3_etamoy_hu(i) = 0.d0
!                           Bijpn3_etamoy_hv(i) = 0.d0
                        endif
!
                        if(p <= nbase_u .and. k <= nbase_hu) Bijpn_uhu(i,p,k)= 0.d0
                        if(p <= nbase_u .and. k <= nbase_hv) Bijpn_uhv(i,p,k)= 0.d0
                        if(p <= nbase_v .and. k <= nbase_hu) Bijpn_vhu(i,p,k)= 0.d0
                        if(p <= nbase_v .and. k <= nbase_hv) Bijpn_vhv(i,p,k)= 0.d0
!
!                       Bzmij(i)        = 0.d0
!
                        do j=1,ns
!
                            nc1 = connectivite(i,j)
!
                            if ( j < ns ) then
                                nc2 = connectivite(i,j+1)
                            else
                                nc2 = connectivite(i,1) 
                            endif
!
!                       *** calcul du vecteur normal à ce coté ***
!
                            x1 = coordonnees(nc1,1)
                            x2 = coordonnees(nc2,1)
                            y1 = coordonnees(nc1,2)
                            y2 = coordonnees(nc2,2)
                            xface = ( x1 + x2 ) / 2.d0
                            yface = ( y1 + y2 ) / 2.d0
!
                            ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )
!
                            norm(1) = ( y2 - y1 ) / ln
                            norm(2) = ( x1 - x2 ) / ln
!
                            kvoisin = boundary(i,j)
!
                            if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
!
!                               Bzmij(i) = Bzmij(i) + (zm(i) + zm(kvoisin))
!
!CONSTRUCTION DES MATRICES CONSTANTES POD
!*** Deux premiers termes de l'équation de continuité : hun1, hun2
                                if(k <= nbase_hu)  Bijpn1_eta(i,k) = Bijpn1_eta(i,k) + ln * norm(1) * 0.5 * ( phi_hu (kvoisin,k) + phi_hu (i,k))
                                if(k <= nbase_hv)  Bijpn2_eta(i,k) = Bijpn2_eta(i,k) + ln * norm(2) * 0.5 * ( phi_hv (kvoisin,k) + phi_hv (i,k))
!***                            Terme de correcetion lamda(etaj-etai)                               
                                if(k <= nbase_eta) then
                                    if(H_AMONT .ne. H_AVAL) then
                                        if(uselamdapodmoymax==1) Bi_jp(i,k)      = Bi_jp  (i,k)   +      ln *           0.5 * ( phi_eta_tild(kvoisin,k) - phi_eta_tild(i,k))*podlamdamoy(i)*(abs(H_AMONT-H_AVAL))
                                        if(uselamdapodmoymax==2) Bi_jp(i,k)      = Bi_jp  (i,k)   +      ln *           0.5 * ( phi_eta_tild(kvoisin,k) - phi_eta_tild(i,k))*podlamdamax(i)*(abs(H_AMONT-H_AVAL))**2
                                    else
                                        if(uselamdapodmoymax==1) Bi_jp(i,k)      = Bi_jp  (i,k)   +      ln *           0.5 * ( phi_eta_tild(kvoisin,k) - phi_eta_tild(i,k))*podlamdamoy(i)
                                        if(uselamdapodmoymax==2) Bi_jp(i,k)      = Bi_jp  (i,k)   +      ln *           0.5 * ( phi_eta_tild(kvoisin,k) - phi_eta_tild(i,k))*podlamdamax(i)
                                    endif
!
!                               Termes de gravité : hgHn1, hgHn2
                                Bijpn3_hu(i,k)  = Bijpn3_hu(i,k) + gp * ln * norm(1) * 0.5 * ( phi_eta(kvoisin,k) + phi_eta(i,k))
                                Bijpn3_hv(i,k)  = Bijpn3_hv(i,k) + gp * ln * norm(2) * 0.5 * ( phi_eta(kvoisin,k) + phi_eta(i,k))
                                endif
!*** Termes de correction : lamda(huj-hui, hvj-hvi)                             
                                if(k <= nbase_hu) then
                                    if(H_AMONT .ne. H_AVAL) then
                                        if(uselamdapodmoymax==1) Bi_jp_hu(i,k) = Bi_jp_hu(i,k) + ln * 0.5 * ( phi_hu (kvoisin,k) - phi_hu (i,k))*podlamdamoy(i)*fact_lamda_pod*(abs(H_AMONT-H_AVAL))
                                        if(uselamdapodmoymax==2) Bi_jp_hu(i,k) = Bi_jp_hu(i,k) + ln * 0.5 * ( phi_hu (kvoisin,k) - phi_hu (i,k))*podlamdamax(i)*fact_lamda_pod*(abs(H_AMONT-H_AVAL))**2
                                    else
                                        if(uselamdapodmoymax==1) Bi_jp_hu(i,k) = Bi_jp_hu(i,k) + ln * 0.5 * ( phi_hu (kvoisin,k) - phi_hu (i,k))*podlamdamoy(i)*fact_lamda_pod
                                        if(uselamdapodmoymax==2) Bi_jp_hu(i,k) = Bi_jp_hu(i,k) + ln * 0.5 * ( phi_hu (kvoisin,k) - phi_hu (i,k))*podlamdamax(i)*fact_lamda_pod
!                                       if(uselamdapodmoymax==3) Bi_jp_hu(i,k) = Bi_jp_hu(i,k) + ln * 0.5 * ( phi_hu (kvoisin,k) - phi_hu (i,k))*podlamdamax(i)
                                    endif
                                endif
                                if(k <= nbase_hv) then
                                    if(H_AMONT .ne. H_AVAL) then
                                        if(uselamdapodmoymax==1) Bi_jp_hv(i,k) = Bi_jp_hv(i,k) + ln * 0.5 * ( phi_hv (kvoisin,k) - phi_hv (i,k))*podlamdamoy(i)*fact_lamda_pod*(abs(H_AMONT-H_AVAL))
                                        if(uselamdapodmoymax==2) Bi_jp_hv(i,k) = Bi_jp_hv(i,k) + ln * 0.5 * ( phi_hv (kvoisin,k) - phi_hv (i,k))*podlamdamax(i)*fact_lamda_pod*(abs(H_AMONT-H_AVAL))**2
                                    else
                                        if(uselamdapodmoymax==1) Bi_jp_hv(i,k) = Bi_jp_hv(i,k) + ln * 0.5 * ( phi_hv (kvoisin,k) - phi_hv (i,k))*podlamdamoy(i)*fact_lamda_pod
                                        if(uselamdapodmoymax==2) Bi_jp_hv(i,k) = Bi_jp_hv(i,k) + ln * 0.5 * ( phi_hv (kvoisin,k) - phi_hv (i,k))*podlamdamax(i)*fact_lamda_pod
                                    endif
                                endif
!*** Termes de convection                               
                                if(p <= nbase_u) then
                                    auxij_u = 0.5 * ( phi_u(kvoisin,p) + phi_u(i,p) )
                                    if(k <= nbase_hu) Bijpn_uhu(i,p,k) = Bijpn_uhu(i,p,k) + ln  * norm(1) * auxij_u * 0.5 * ( phi_hu (kvoisin,k) + phi_hu (i,k))  !1ere Éq. quantité de mvmt (hu)
                                    if(k <= nbase_hv) Bijpn_uhv(i,p,k) = Bijpn_uhv(i,p,k) + ln  * norm(2) * auxij_u * 0.5 * ( phi_hv (kvoisin,k) + phi_hv (i,k))  !1ere Éq. quantité de mvmt (hv)                           
                                endif
!
                                if(p <= nbase_v) then
                                    auxij_v = 0.5 * ( phi_v(kvoisin,p) + phi_v(i,p) )
                                    if(k <= nbase_hu) Bijpn_vhu(i,p,k) = Bijpn_vhu(i,p,k) + ln * norm(1) * auxij_v *  0.5 * ( phi_hu (kvoisin,k) + phi_hu (i,k))  !2e Éq. quantité de mvmt (hu)
                                    if(k <= nbase_hv) Bijpn_vhv(i,p,k) = Bijpn_vhv(i,p,k) + ln * norm(2) * auxij_v *  0.5 * ( phi_hv (kvoisin,k) + phi_hv (i,k))  !2e Éq. quantité de mvmt (hv)
                                endif
!
!***                                                                                    
                            endif ! de  if  ( kvoisin > 0. )
!
!***  Conditions aux limites    
!
!                           if ( kvoisin == -2 .and. k <= nbase_eta ) then  ! *** flux sortant ***
!!
!!                              équation de continuité  
!                                   if(k <= nbase_hu)  Bijpn1_eta(i,k) = Bijpn1_eta(i,k) + ln * norm(1) * phi_hu (i,k)  ! hun1
!                                   if(k <= nbase_hv)  Bijpn2_eta(i,k) = Bijpn2_eta(i,k) + ln * norm(2) * phi_hv (i,k)  ! hun2
!!
!!                              termes de gravité
!                                       Bijpn3_hu(i,k)  = Bijpn3_hu(i,k) + gp * ln * norm(1) * h_aval !(h_aval**2 - h_aval*zm(i)) !phi_eta(i,k) ! hgHn1
!                                       Bijpn3_hv(i,k)  = Bijpn3_hv(i,k) + gp * ln * norm(2) * h_aval !(h_aval**2 - h_aval*zm(i)) !phi_eta(i,k) ! hgHn2
!!
!                               !*** Qté de mouvement : Termes de convection                                
!                                   if(p <= nbase_u) then
!                                       if(k <= nbase_hu) Bijpn_uhu(i,p,k) = Bijpn_uhu(i,p,k) + ln  * norm(1) * phi_u(i,p) * phi_hu (i,k)  !1ere Éq. quantité de mvmt (hu)
!                                       if(k <= nbase_hv) Bijpn_uhv(i,p,k) = Bijpn_uhv(i,p,k) + ln  * norm(2) * phi_u(i,p) * phi_hv (i,k)  !1ere Éq. quantité de mvmt (hv)                          
!                                   endif
!!
!                                   if(p <= nbase_v) then
!                                       if(k <= nbase_hu) Bijpn_vhu(i,p,k) = Bijpn_vhu(i,p,k) + ln * norm(1) * phi_v(i,p)  *  phi_hu (i,k)  !2e Éq. quantité de mvmt (hu)
!                                       if(k <= nbase_hv) Bijpn_vhv(i,p,k) = Bijpn_vhv(i,p,k) + ln * norm(2) * phi_v(i,p)  *  phi_hv (i,k)  !2e Éq. quantité de mvmt (hv)
!                                   endif
!!
!                           endif
!                                               
                            if ( kvoisin == -3 .and. k <= nbase_eta ) then  ! *** flux de mur ***
                                Bijpn3_hu(i,k)      = Bijpn3_hu(i,k)      + gp * ln * norm(1) * phi_eta(i,k)
                                Bijpn3_hv(i,k)      = Bijpn3_hv(i,k)      + gp * ln * norm(2) * phi_eta(i,k)
                            endif
!
                        enddo   ! de do j=1,ns
!
!                       Matrices pour hu et hv : Équation de continuité                     
                        if(p <= nbase_eta .and. k <= nbase_hu)  Mpk1_hu(p,k)  = Mpk1_hu(p,k)  + phi_eta_tild(i,p) * Bijpn1_eta(i,k) / surf(i)
                        if(p <= nbase_eta .and. k <= nbase_hv)  Mpk1_hv(p,k)  = Mpk1_hv(p,k)  + phi_eta_tild(i,p) * Bijpn2_eta(i,k) / surf(i)
!
!                       Matrices pour les termes de correction                               
                            if(p <= nbase_hu  .and. k <= nbase_hu)  Mpk_dhu(p,k)  = Mpk_dhu(p,k)  + phi_hu(i,p)  * Bi_jp_hu(i,k)   / surf(i)    
                            if(p <= nbase_hv  .and. k <= nbase_hv)  Mpk_dhv(p,k)  = Mpk_dhv(p,k)  + phi_hv(i,p)  * Bi_jp_hv(i,k)   / surf(i)
                            if(p <= nbase_eta .and. k <= nbase_eta) Mpk_deta(p,k) = Mpk_deta(p,k) + phi_eta_tild(i,p) * Bi_jp(i,k) / surf(i)
!                       Matrice pour le calcul de h à partir de eta
                        if (p <= nbase_eta .and. k <= nbase_h) then
                            phi_h_eta(p,k) = phi_h_eta(p,k) +  phi_eta(i,p) * phi_h(i,k)
!                           if (p==1)   phi_h_zi(k)    = phi_h_zi(k) + phi_h(i,k)*zm(i)
                            if (p==1)   phi_h_zi(k)    = phi_h_zi(k) + phi_h(i,k)*( h_aval - zm(i))
                        endif
!
!                       Matrices pour les termes de convection uhu uhv vhu vhv                               
                            if(p <= nbase_u  .and. k <= nbase_hu)  then
                                if(h_pod_elt(i) > tolisec) then
                                    if(H_AMONT .ne. H_AVAL) then 
                                        if (H_AVAL > 0.0) then
                                            if (test==1) then
                                                Mpk_u(p,k)  = Mpk_u(p,k)  + phi_u(i,p) * phi_hu(i,k) / (fact_h_pod*h_pod_elt(i))
                                            else 
                                                Mpk_u(p,k)  = Mpk_u(p,k)  + phi_u(i,p) * phi_hu(i,k) * (abs(H_AMONT-H_AVAL)**2*h_pod_elt(i))
                                                    
                                            endif                                           
                                        else
                                            if (test==1) then
                                                Mpk_u(p,k)  = Mpk_u(p,k)  + phi_u(i,p) * phi_hu(i,k) / (fact_h_pod*h_pod_elt(i))
                                            else
                                                Mpk_u(p,k)  = Mpk_u(p,k)  + phi_u(i,p) * phi_hu(i,k) / (fact_h_pod*h_pod_elt(i)/H_AMONT)
                                            endif
                                            
                                        endif
                                    else
                                            Mpk_u(p,k)  = Mpk_u(p,k)  + phi_u(i,p) * phi_hu(i,k) / (fact_h_pod*h_pod_elt(i))
                                    endif
                                endif
                            endif
!
                            if(p <= nbase_v  .and. k <= nbase_hv) then
                                if(h_pod_elt(i) > tolisec) then
                                    if(H_AMONT .ne. H_AVAL) then 
                                        if (H_AVAL > 0.0) then
                                            Mpk_v(p,k)  = Mpk_v(p,k)  + phi_v(i,p) * phi_hv(i,k) / (fact_h_pod*h_pod_elt(i))
                                        else
                                            Mpk_v(p,k)  = Mpk_v(p,k)  + phi_v(i,p) * phi_hv(i,k) / (4*h_pod_elt(i)/H_AMONT)
                                        endif
                                    else
                                            !Mpk_v(p,k)  = Mpk_v(p,k)  + phi_v(i,p) * phi_hv(i,k) / h_pod_elt(i)
                                            Mpk_v(p,k)  = Mpk_v(p,k)  + phi_v(i,p) * phi_hv(i,k) / (fact_h_pod*h_pod_elt(i))
                                    endif   
                                endif
                            endif
!
!                   Matrices pour les termes sources de friction : 1ere Eq. Qté de Mvt                      
                        if (p <= nbase_hu .and. k <= nbase_hu) then
                            Sfxu(p,k) = Sfxu(p,k) + gp*phi_hu(i,p) * phi_u(i,k) * coef_fric_pod_elt(i)
                        endif  
!
!                   Matrices pour les termes sources de friction : 2e Eq. Qté de Mvt                        
                        if (p <= nbase_hv .and. k <= nbase_hv) then
                              Sfyv(p,k) = Sfyv(p,k) + gp*phi_hv(i,p) * phi_v(i,k) * coef_fric_pod_elt(i)
                        endif 
!                       
                    endif !de if p1===1
!
!***                Matrices pour les termes de convection et le terme de gravité : 1ere Eq. Qté de Mvt                     
                    if (p1 <= nbase_hu) then
                        if (p <= nbase_u .and. k <= nbase_hu)  Chuu2(p1,p,k)  = Chuu2(p1,p,k)  + phi_hu(i,p1) * Bijpn_uhu(i,p,k)             / surf(i) 
                        if (p <= nbase_u .and. k <= nbase_hv)  Chuv2(p1,p,k)  = Chuv2(p1,p,k)  + phi_hu(i,p1) * Bijpn_uhv(i,p,k)             / surf(i)
                        if (p <= nbase_h .and. k <= nbase_eta) Cg2  (p1,p,k)  = Cg2  (p1,p,k)  + phi_hu(i,p1) * phi_h(i,p) * Bijpn3_hu(i,k)  / surf(i)          
                    endif
!
!***                Matrices pour les termes de convection et le terme de gravité : 2e Eq. Qté de Mvt                   
                    if (p1 <= nbase_hv) then
                        if (p <= nbase_v .and. k <= nbase_hu)  Chuv3(p1,p,k)  = Chuv3(p1,p,k)  + phi_hv(i,p1) * Bijpn_vhu(i,p,k)              / surf(i)  
                        if (p <= nbase_v .and. k <= nbase_hv)  Chvv3(p1,p,k)  = Chvv3(p1,p,k)  + phi_hv(i,p1) * Bijpn_vhv(i,p,k)              / surf(i)
                        if (p <= nbase_h .and. k <= nbase_eta) Cg3  (p1,p,k)  = Cg3  (p1,p,k)  + phi_hv(i,p1) * phi_h(i,p) * Bijpn3_hv(i,k)   / surf(i)
                    endif
!**                               
                enddo   !do i=1,nelt
!
        enddo   !do k=1,nb
!
    enddo   !do p=1,nb
! 
   enddo    !do p1=1,nb
!
end subroutine matrice_POD 


!
!==================================================================================
subroutine POD_PID_ROM_matrices(surf,zm)
!====================================================================================================   
!                                       MODELE REDUIT
!====================================================================================================

! ======================================================================
!
!     Auteur : Jean-Marie Zokagoa
!
!     version : 2010
!
! ======================================================================
!
    use precision_m
    use global
    use m_param
!
!   use avdef
!   use avviewer
!   use dflib
!   use dfmt
!   use dflogm
!
    implicit none
! *** bloc interface ***
!
    interface
!
! ... variables passees en parametre .........................................................................................
!
        subroutine debit_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine debit_POD
!
        subroutine CL_sortie_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine CL_sortie_POD    
!        
        subroutine entree_sortie_domaine
            use precision_m
            use global
            use m_param
        end subroutine entree_sortie_domaine
!   
        subroutine matrice_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine matrice_POD
!
        subroutine pod_source_friction(surf,zm)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine pod_source_friction
!   
        subroutine prod_Mpk_vect(droite,ni,nj,mat,vect1,vect2)
            use precision_m
            integer ,  intent(in)               :: ni,nj, droite
            real(fp_kind), dimension(:),  intent(in)  :: vect1
            real(fp_kind), dimension(:),  intent(out) :: vect2
            real(fp_kind), dimension(:,:),intent(in)  :: mat
        end subroutine prod_Mpk_vect
!
        subroutine prod_tenseur_vect(ni,nj,nk,tenseur,vect,matrx)
            use precision_m
            integer ,intent(in)                   :: ni,nj,nk
            real(fp_kind), dimension(:),    intent(in)  :: vect
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
            real(fp_kind), dimension(:,:,:),intent(in)  :: tenseur
        end subroutine prod_tenseur_vect
!
        subroutine prod_scalaire(ni,vect1,vect2,scal)
            use precision_m
            integer ,  intent(in)               :: ni
            real(fp_kind), dimension(:),  intent(in)  :: vect1, vect2
            real(fp_kind),                intent(out)  :: scal
        end subroutine prod_scalaire
!
        subroutine lecture_fichier_matlab(nfichier,ni, nj, matrx)
            use precision_m
            integer ,intent(in)                   :: nfichier, ni, nj
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
        end subroutine lecture_fichier_matlab
!
    end interface
!
!
! ... variables passees en parametre ...................................
!
    real(fp_kind), dimension(:), intent(in)      :: surf, zm    
!
!*** Variables locales ***
    real(fp_kind), dimension(:,:), allocatable :: greta_lisec1
!   
    integer :: i, ii, j, ib, jb, kb
!
    real(fp_kind) :: Q_unit, zero
!
    zero      = 0.d0
    Q_unit = -debitglob/long
!
        open(unit=2001,file='POD_Mpk1_hu.dat',status="unknown")
        open(unit=2002,file='POD_Mpk1_hv.dat',status="unknown")
        open(unit=2003,file='POD_Mpk_deta.dat',status="unknown")
        open(unit=2004,file='POD_Mpk_dhu.dat',status="unknown")
        open(unit=2005,file='POD_Mpk_dhv.dat',status="unknown")
        open(unit=2006,file='POD_Mpk_u.dat',status="unknown")
        open(unit=2007,file='POD_Mpk_v.dat',status="unknown")
        open(unit=2008,file='POD_Mphi_h_zi.dat',status="unknown")
        open(unit=2009,file='POD_MSfxu.dat',status="unknown")
        open(unit=2010,file='POD_MSfxv.dat',status="unknown")
        open(unit=2011,file='POD_MChuu2.dat',status="unknown")
        open(unit=2012,file='POD_MChuv2.dat',status="unknown")
        open(unit=2013,file='POD_MCg2.dat',status="unknown")
        open(unit=2014,file='POD_MChvv3.dat',status="unknown")
        open(unit=2015,file='POD_MChuv3.dat',status="unknown")
        open(unit=2016,file='POD_MCg3.dat',status="unknown")
!
!                   if(p <= nbase_h .and. k == 1)            Cg3_eta_tild(p1,p) = 0.d0 
!***********************************************************************************************************************************
!       Lecture des éléments à l'entrée du domaine pour l'imposition du débit
                open(unit=507,file='Donnees_entree_dom.dat',status="old")
                    read(507,*) nelt_entree
                    allocate(donnees_entree(nelt_entree,4))
                    do i=1,nelt_entree
                        read(507,*) donnees_entree(i,1), donnees_entree(i,2), donnees_entree(i,3), donnees_entree(i,4)
                    enddo
                close(507)    
!   *** ***
!       Lecture des éléments à la sortie du domaine pour l'imposition de la condition de flux de sortie  
                open(unit=508,file='Donnees_sortie_dom.dat',status="old")
                    read(508,*) nelt_sortie
                    allocate(donnees_sortie(nelt_sortie,4))
                    do i=1,nelt_sortie
                        read(508,*) donnees_sortie(i,1), donnees_sortie(i,2), donnees_sortie(i,3), donnees_sortie(i,4)
                    enddo
                close(508)       
!***********************************************************************************************************************************
!
!  ==================================================================================================================================
!
            i_seq_pod = 1 
!
            write(num_seq_base1,'(i1)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base1// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base1// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base1// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base1// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base1// '.txt'
            base_u_num = 'BASE_u' //num_seq_base1// '.txt'
            base_v_num = 'BASE_v' //num_seq_base1// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base1// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base1// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base1// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base1// '.dat'
!
!       ------------------------------------------------------------------------------------------------ 
!                   
            open(unit=391,file=base_h_num,status="old")
            open(unit=392,file=base_eta_num,status="old")
            open(unit=393,file=base_hu_num,status="old")
            open(unit=394,file=base_hv_num,status="old")
            open(unit=395,file=base_u_num,status="old")
            open(unit=396,file=base_v_num,status="old")
            open(unit=397,file=base_eta_tild_num,status="old")
!           
            read (391,*) nbase_h
            read (392,*) n_seq_base 
            read (392,*) nbase_eta
            read (393,*) nbase_hu
            read (394,*) nbase_hv
            read (395,*) nbase_u
            read (396,*) nbase_v
            read (397,*) n_seq_base
            read (397,*) nbase_eta_tild
!
            maxdimbase = max(nbase_h, nbase_eta, nbase_eta_tild, nbase_hu, nbase_hv, nbase_u, nbase_v)
!
!       ------------------------------------------------------------------------------------------------
            allocate(greta_lisec1(nelt,2))
!=========================================================================================================
!
            allocate(phi_h(nelt,nbase_h), phi_eta(nelt,nbase_eta), phi_eta_tild(nelt,nbase_eta_tild), phi_hu(nelt,nbase_hu), phi_hv(nelt,nbase_hv), &
                    &        phi_u(nelt,nbase_u), phi_v(nelt,nbase_v), phij_u(nelt,nbase_u), phij_v(nelt,nbase_v), phi_h_zi(nbase_h), phi_h_eta(nbase_eta,nbase_h))
            allocate(Bi_jp(nelt,nbase_eta),Bi_jp_hu(nelt,nbase_hu),Bi_jp_hv(nelt,nbase_hv))         
            allocate(Bijpn1_eta(nelt,nbase_hu), Bijpn2_eta(nelt,nbase_hv))
            allocate(Bijpn3_hu(nelt,nbase_eta), Bijpn3_hv(nelt,nbase_eta))
!
            allocate(Cg2(nbase_hu,nbase_h,nbase_eta), Cg3(nbase_hv,nbase_h,nbase_eta), Cg2_eta_tild(nbase_hu,nbase_h), Cg3_eta_tild(nbase_hv,nbase_h))
            allocate(Chuu2(nbase_hu,nbase_u,nbase_hu), Chuv2(nbase_hu,nbase_u,nbase_hv), Chuv3(nbase_hv,nbase_v,nbase_hu), Chvv3(nbase_hv,nbase_v,nbase_hv))
            allocate(Bijpn_uhu(nelt,nbase_u,nbase_hu), Bijpn_uhv(nelt,nbase_u,nbase_hv), Bijpn_vhu(nelt,nbase_v,nbase_hu), Bijpn_vhv(nelt,nbase_v,nbase_hv))
            allocate(MSfxu(nbase_hu,nbase_u,nbase_u), MSfxv(nbase_hu,nbase_u,nbase_v), MSfyv(nbase_hv,nbase_v,nbase_v), MSfyu(nbase_hv,nbase_v,nbase_u))
!
            allocate(a_eta(nbase_eta),a0_eta(nbase_eta),a01_eta(nbase_eta),resred_eta(nbase_eta), MQk_eta(nbase_eta), Mcl_out_eta(nbase_eta))
            allocate(a_hu (nbase_hu) ,a0_hu (nbase_hu), a01_hu (nbase_hu), resred_hu (nbase_hu), MQk_hu(nbase_hu), Mcl_out_hu(nbase_hu))
            allocate(a_hv (nbase_hv), a0_hv (nbase_hv), a01_hv (nbase_hv), resred_hv (nbase_hv), MQk_hv(nbase_hv), Mcl_out_hv(nbase_hv))
            allocate(a_h(nbase_h), a_u(nbase_u), a_v(nbase_v))
!
            allocate(Mpk1_hu(nbase_eta,nbase_hu), Mpk1_hv(nbase_eta,nbase_hv), hgn1(nbase_hu,nbase_eta), hgn2(nbase_hv,nbase_eta))
            allocate(un1(nbase_hu,nbase_hu),un2(nbase_hu,nbase_hv), vn1(nbase_hv,nbase_hu), vn2(nbase_hv,nbase_hv))
            allocate(Mpk_deta(nbase_eta,nbase_eta),Mpk_dhu(nbase_hu,nbase_hu),Mpk_dhv(nbase_hv,nbase_hv))  
            allocate(Mpk_u(nbase_u,nbase_hu), Mpk_v(nbase_v,nbase_hv))
            allocate(Sfxu(nbase_hu,nbase_u), Sfxv(nbase_hu,nbase_v), Sfyv(nbase_hv,nbase_v), Sfyu(nbase_hv,nbase_u))
!
            allocate(hun1(nbase_eta), hvn2(nbase_eta), deta(nbase_eta), hgHn1(nbase_hu), hgHn2(nbase_hv))
            allocate(huun1(nbase_hu), huun2(nbase_hu), huvn1(nbase_hv), hvvn2(nbase_hv), dhu(nbase_hu), dhv(nbase_hv))
            allocate(Sfx1(nbase_hu), Sfx2(nbase_hu), Sfy1(nbase_hv), Sfy2(nbase_hv))
!
            allocate(vectpod(nbase_hu,6))
            allocate(Bzmij(nelt), BQi_eta(nelt), BQi_hu(nelt), BQi_hv(nelt))
            allocate(huun1full(nelt), huun2full(nelt), huvn1full(nelt), hvvn2full(nelt), podlamdafull(nelt), sourcfric_hu(nelt), sourcfric_hv(nelt))
!       
            allocate(zero_pod(nbase_eta), pod_friction_hu(nbase_hu), pod_friction_hv(nbase_hv))
            zero_pod = 0.0
!
!=======================================================================================================================================================
!
!
            print*, "Lecture des bases modales pour le POD"
!
            call lecture_fichier_matlab(391, nelt, nbase_h, phi_h)
            call lecture_fichier_matlab(392, nelt, nbase_eta, phi_eta)
            call lecture_fichier_matlab(397, nelt, nbase_eta_tild, phi_eta_tild)
            call lecture_fichier_matlab(393, nelt, nbase_hu,  phi_hu)
            call lecture_fichier_matlab(395, nelt, nbase_u,   phi_u)
            if(dim == 2) then
                call lecture_fichier_matlab(394, nelt, nbase_hv,  phi_hv)
                call lecture_fichier_matlab(396, nelt, nbase_v, phi_v)
            else
                phi_hv = zero
                phi_v = zero
            endif           
!
!                  ------------------------------------------------------------------------------------------------
!
!============================== Traitement de lamda POD ============================================================================
!
            if(uselamdapodmoymax==1 .or. uselamdapodmoymax==2) then
            allocate(podlamdamoy(nelt), podlamdamax(nelt), h_pod_elt(nelt), coef_fric_pod_elt(nelt))
            open(unit=402,file=lamda_moy_num,status="old")
            open(unit=403,file=lamda_max_num,status="old")
            open(unit=404,file=h_pod_num,status="old")
            if (friction > 0.0) open(unit=405,file=fric_pod_num,status="old")
                do i=1,nelt
                    read(402,*) podlamdamoy(i)  
                    read(403,*) podlamdamax(i)
                    read(404,*) h_pod_elt(i)
                    if (friction > 0.0) read(405,*) coef_fric_pod_elt(i)
                enddo   
            close(402)
            close(403)
            close(404)
            close(405)
            else
                write(*,*) 'uselamdapodmoymax (pour la vitesse d onde en POD) non convenable'
            endif
!
        do i_seq_pod = 1 , n_seq_base
!
            print*, 'sequence pod en cours = ', i_seq_pod
!
! ************************************ Calcul des Matrices constantes pour le POD ***************************************************
!           Print*,"Calcul des matrices constantes pour POD"
!
            call matrice_POD(zm,surf)
!
            do ib = 1 , nbase_eta 
                write(2001,'(30f14.6)') (Mpk1_hu(ib,jb),jb=1,nbase_hu)
                write(2002,'(30f14.6)') (Mpk1_hv(ib,jb),jb=1,nbase_hv)
                write(2003,'(30f14.6)') (Mpk_deta(ib,jb),jb=1,nbase_eta)                
            enddo
            do ib = 1 , nbase_hu 
                write(2004,'(30f14.6)') (Mpk_dhu(ib,jb),jb=1,nbase_hu)
                write(2009,'(30f14.6)') (Sfxu(ib,jb),jb=1,nbase_hu)
                do jb = 1, nbase_eta
                    write(2013,'(30f14.6)') (Cg2(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_u
                    write(2011,'(30f14.6)') (Chuu2(ib,jb,kb),kb=1,nbase_hu)
                enddo
                do jb = 1, nbase_u
                    write(2012,'(30f14.6)') (Chuv2(ib,jb,kb),kb=1,nbase_hv)
                enddo
            enddo
            do ib = 1 , nbase_hv 
                write(2005,'(30f14.6)') (Mpk_dhv(ib,jb),jb=1,nbase_hv)
                write(2010,'(30f14.6)') (Sfxv(ib,jb),jb=1,nbase_hv)
                do jb = 1, nbase_eta
                    write(2016,'(30f14.6)') (Cg3(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_v
                    write(2014,'(30f14.6)') (Chvv3(ib,jb,kb),kb=1,nbase_hv)
                enddo
                do jb = 1, nbase_v
                    write(2015,'(30f14.6)') (Chuv3(ib,jb,kb),kb=1,nbase_hu)
                enddo
            enddo
            do ib = 1 , nbase_u 
                write(2006,'(30f14.6)') (Mpk_u(ib,jb),jb=1,nbase_hu)
            enddo
            do ib = 1 , nbase_v 
                write(2007,'(30f14.6)') (Mpk_v(ib,jb),jb=1,nbase_hv)
            enddo
            do ib = 1 , nbase_v
                write(2008,'(30f14.6)') phi_h_zi(ib)
            enddo
!
!************************************************************************************************************************************
!
!
! *** mise à jour du temps et de la solution initiale ***

!       ------------------------------------------------------------------------------------------------                                                
            close(391)
            close(392)
            close(393)
            close(394)
            close(395)
            close(396)
            close(397)
!           
        if (i_seq_pod <= n_seq_base ) then 
            if (i_seq_pod < 10) then
            write(num_seq_base1,'(i1)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base1// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base1// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base1// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base1// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base1// '.txt'
            base_u_num = 'BASE_u' //num_seq_base1// '.txt'
            base_v_num = 'BASE_v' //num_seq_base1// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base1// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base1// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base1// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base1// '.dat'
            !
        elseif (i_seq_pod >= 10 .and. i_seq_pod < 100) then
            write(num_seq_base2,'(i2)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base2// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base2// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base2// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base2// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base2// '.txt'
            base_u_num = 'BASE_u' //num_seq_base2// '.txt'
            base_v_num = 'BASE_v' //num_seq_base2// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base2// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base2// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base2// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base2// '.dat'
            !
        elseif (i_seq_pod >= 100 .and. i_seq_pod < 1000) then
            write(num_seq_base3,'(i3)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base3// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base3// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base3// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base3// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base3// '.txt'
            base_u_num = 'BASE_u' //num_seq_base3// '.txt'
            base_v_num = 'BASE_v' //num_seq_base3// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base3// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base3// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base3// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base3// '.dat'
        else
            print*, 'Nombre de sequences trop eleve'
        endif
!                   
            open(unit=391,file=base_h_num,status="old")
            open(unit=392,file=base_eta_num,status="old")
            open(unit=393,file=base_hu_num,status="old")
            open(unit=394,file=base_hv_num,status="old")
            open(unit=395,file=base_u_num,status="old")
            open(unit=396,file=base_v_num,status="old")
            open(unit=397,file=base_eta_tild_num,status="old")
!
            read (391,*) nbase_h
            read (392,*) n_seq_base  
            read (392,*) nbase_eta
            read (393,*) nbase_hu
            read (394,*) nbase_hv
            read (395,*) nbase_u
            read (396,*) nbase_v
            read (397,*) n_seq_base
            read (397,*) nbase_eta_tild
!
            maxdimbase = max(nbase_h, nbase_eta, nbase_eta_tild, nbase_hu, nbase_hv, nbase_u, nbase_v)
!
!       ------------------------------------------------------------------------------------------------
!               print*, "Lecture des bases modales pour le POD"
!
                call lecture_fichier_matlab(391, nelt, nbase_h, phi_h)
                call lecture_fichier_matlab(392, nelt, nbase_eta, phi_eta)
                call lecture_fichier_matlab(393, nelt, nbase_hu,  phi_hu)
                call lecture_fichier_matlab(395, nelt, nbase_u,   phi_u)
                call lecture_fichier_matlab(397, nelt, nbase_eta_tild, phi_eta_tild)
                if(dim == 2) then
                    call lecture_fichier_matlab(394, nelt, nbase_hv,  phi_hv)
                    call lecture_fichier_matlab(396, nelt, nbase_v, phi_v)
                else
                    phi_hv = zero
                    phi_v = zero
                endif
!      ---------------------------- Traitement de lamda POD --------------------------------------------
!               
                if(uselamdapodmoymax==1 .or. uselamdapodmoymax==2) then
                open(unit=402,file=lamda_moy_num,status="old")
                open(unit=403,file=lamda_max_num,status="old")
                open(unit=404,file=h_pod_num,status="old")
                if (friction > 0.0) open(unit=405,file=fric_pod_num,status="old")
                    do i=1,nelt
                        read(402,*) podlamdamoy(i)  
                        read(403,*) podlamdamax(i)
                        read(404,*) h_pod_elt(i)
                        if (friction > 0.0) read(405,*) coef_fric_pod_elt(i)
                    enddo   
                close(402)
                close(403)
                close(404)
                close(405)
                else
                    write(*,*) 'uselamdapodmoymax (pour la vitesse d onde en POD) non convenable'
                endif
!      ---------------------------- FIN Traitement de lamda POD !      ----------------------------------
!                
            endif ! de if (i_seq_pod <= n_seq_base ) then
!
        enddo      ! *** fin de la boucle sur le temps ***
!
        close(1006)
        close(2001)
        close(2002)
        close(2003)
        close(2004)
        close(2005)
        close(2006)
        close(2007)
        close(2008)
        close(2009)
        close(2010)
        close(2011)
        close(2012)
        close(2013)
        close(2014)
        close(2015)
        close(2016)
!
!****************************************************************************************************
end subroutine POD_PID_ROM_matrices
!==================================================================================
!==================================================================================
subroutine POD_ROM_matrices(surf,zm)
!====================================================================================================   
!                                       MODELE REDUIT
!====================================================================================================

! ======================================================================
!
!     Auteur : Jean-Marie Zokagoa
!
!     version : 2010
!
! ======================================================================
!
    use precision_m
    use global
    use m_param
!
!   use avdef
!   use avviewer
!   use dflib
!   use dfmt
!   use dflogm
!
    implicit none
! *** bloc interface ***
!
    interface
!
! ... variables passees en parametre .........................................................................................
!
        subroutine debit_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine debit_POD
!
        subroutine CL_sortie_POD(ns,zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine CL_sortie_POD    
!        
        subroutine entree_sortie_domaine
            use precision_m
            use global
            use m_param
        end subroutine entree_sortie_domaine
!   
        subroutine matrice_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine matrice_POD
!
        subroutine pod_source_friction(surf,zm)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine pod_source_friction
!   
        subroutine prod_Mpk_vect(droite,ni,nj,mat,vect1,vect2)
            use precision_m
            integer ,  intent(in)               :: ni,nj, droite
            real(fp_kind), dimension(:),  intent(in)  :: vect1
            real(fp_kind), dimension(:),  intent(out) :: vect2
            real(fp_kind), dimension(:,:),intent(in)  :: mat
        end subroutine prod_Mpk_vect
!
        subroutine prod_tenseur_vect(ni,nj,nk,tenseur,vect,matrx)
            use precision_m
            integer ,intent(in)                   :: ni,nj,nk
            real(fp_kind), dimension(:),    intent(in)  :: vect
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
            real(fp_kind), dimension(:,:,:),intent(in)  :: tenseur
        end subroutine prod_tenseur_vect
!
        subroutine prod_scalaire(ni,vect1,vect2,scal)
            use precision_m
            integer ,  intent(in)               :: ni
            real(fp_kind), dimension(:),  intent(in)  :: vect1, vect2
            real(fp_kind),                intent(out)  :: scal
        end subroutine prod_scalaire
!
        subroutine lecture_fichier_matlab(nfichier,ni, nj, matrx)
            use precision_m
            integer ,intent(in)                   :: nfichier, ni, nj
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
        end subroutine lecture_fichier_matlab
!
    end interface
!
!
! ... variables passees en parametre ...................................
!
    real(fp_kind), dimension(:), intent(in)      :: surf, zm    
!
!*** Variables locales ***
    real(fp_kind), dimension(:,:), allocatable :: greta_lisec1
!   
    integer :: i, ii, j, ib, jb, kb
!
    real(fp_kind) :: Q_unit, zero
!
    zero      = 0.d0
    Q_unit = -debitglob/long        
! 
    open(unit=2001,file='POD_Mpk1_hu_0.dat',status="unknown")
    open(unit=2002,file='POD_Mpk1_hv_0.dat',status="unknown")
    open(unit=2003,file='POD_Mpk_deta_0.dat',status="unknown")
    open(unit=2004,file='POD_Mpk_dhu_0.dat',status="unknown")
    open(unit=2005,file='POD_Mpk_dhv_0.dat',status="unknown")
    open(unit=2006,file='POD_Mpk_u_0.dat',status="unknown")
    open(unit=2007,file='POD_Mpk_v_0.dat',status="unknown")
    open(unit=2008,file='POD_Mphi_h_zi_0.dat',status="unknown")
    open(unit=2009,file='POD_MSfxu_0.dat',status="unknown")
    open(unit=2010,file='POD_MSfxv_0.dat',status="unknown")
    open(unit=2011,file='POD_MChuu2_0.dat',status="unknown")
    open(unit=2012,file='POD_MChuv2_0.dat',status="unknown")
    open(unit=2013,file='POD_MCg2_0.dat',status="unknown")
    open(unit=2014,file='POD_MChvv3_0.dat',status="unknown")
    open(unit=2015,file='POD_MChuv3_0.dat',status="unknown")
    open(unit=2016,file='POD_MCg3_0.dat',status="unknown")
!  
! ************************************ Calcul des Matrices constantes pour le POD *****************************************************
!           
        open(unit=391,file='BASE_h.txt',status="old")
        open(unit=392,file='BASE_eta.txt',status="old")
        open(unit=393,file='BASE_hu.txt',status="old")
        open(unit=394,file='BASE_hv.txt',status="old")
        open(unit=395,file='BASE_u.txt',status="old")
        open(unit=396,file='BASE_v.txt',status="old")
        open(unit=397,file='base_eta_tild.txt',status="old")
!
        read (391,*) nbase_h
        read (392,*) nbase_eta
        read (393,*) nbase_hu
        read (394,*) nbase_hv
        read (395,*) nbase_u
        read (396,*) nbase_v
        read (397,*) nbase_eta_tild
!
        maxdimbase = max(nbase_h, nbase_eta, nbase_hu, nbase_hv, nbase_u, nbase_v)
!
!============================== Traitement de lamda POD ==================================================
!
        if(uselamdapodmoymax==1 .or. uselamdapodmoymax==2) then
            allocate(podlamdamoy(nelt), podlamdamax(nelt), h_pod_elt(nelt), coef_fric_pod_elt(nelt))
            open(unit=402,file='lamda_moy_POD.dat',status="old")
            open(unit=403,file='lamda_max_POD.dat',status="old")
            open(unit=404,file='h_pod_elem.dat',status="old")
            if (friction > 0.0) open(unit=405,file='POD_friction.txt',status="old")
                do i=1,nelt
                    read(402,*) podlamdamoy(i)  
                    read(403,*) podlamdamax(i)
                    read(404,*) h_pod_elt(i)
                    if (friction > 0.0) read(405,*) coef_fric_pod_elt(i)
                enddo   
            close(402)
            close(403)
            close(404)
            close(405)
        else
            write(*,*) 'uselamdapodmoymax (pour la vitesse d onde en POD) non convenable'
        endif
!   
        allocate(greta_lisec1(nelt,2))
!=========================================================================================================
!
        allocate(phi_h(nelt,nbase_h), phi_eta(nelt,nbase_eta), phi_eta_tild(nelt,nbase_eta_tild), phi_hu(nelt,nbase_hu), phi_hv(nelt,nbase_hv), &
            &        phi_u(nelt,nbase_u), phi_v(nelt,nbase_v), phij_u(nelt,nbase_u), phij_v(nelt,nbase_v), phi_h_zi(nbase_h), phi_h_eta(nbase_eta,nbase_h))
        allocate(Bi_jp(nelt,nbase_eta),Bi_jp_hu(nelt,nbase_hu),Bi_jp_hv(nelt,nbase_hv))         
        allocate(Bijpn1_eta(nelt,nbase_hu), Bijpn2_eta(nelt,nbase_hv))
        allocate(Bijpn3_hu(nelt,nbase_eta), Bijpn3_hv(nelt,nbase_eta))
!
        allocate(Cg2(nbase_hu,nbase_h,nbase_eta), Cg3(nbase_hv,nbase_h,nbase_eta))
        allocate(Chuu2(nbase_hu,nbase_u,nbase_hu), Chuv2(nbase_hu,nbase_u,nbase_hv), Chuv3(nbase_hv,nbase_v,nbase_hu), Chvv3(nbase_hv,nbase_v,nbase_hv))
        allocate(Bijpn_uhu(nelt,nbase_u,nbase_hu), Bijpn_uhv(nelt,nbase_u,nbase_hv), Bijpn_vhu(nelt,nbase_v,nbase_hu), Bijpn_vhv(nelt,nbase_v,nbase_hv))
        allocate(MSfxu(nbase_hu,nbase_u,nbase_u), MSfxv(nbase_hu,nbase_u,nbase_v), MSfyv(nbase_hv,nbase_v,nbase_v), MSfyu(nbase_hv,nbase_v,nbase_u))
!
        allocate(a_eta(nbase_eta),a0_eta(nbase_eta),a01_eta(nbase_eta),resred_eta(nbase_eta), MQk_eta(nbase_eta), Mcl_out_eta(nbase_eta))
        allocate(a_hu (nbase_hu) ,a0_hu (nbase_hu), a01_hu (nbase_hu), resred_hu (nbase_hu), MQk_hu(nbase_hu), Mcl_out_hu(nbase_hu))
        allocate(a_hv (nbase_hv), a0_hv (nbase_hv), a01_hv (nbase_hv), resred_hv (nbase_hv), MQk_hv(nbase_hv), Mcl_out_hv(nbase_hv))
        allocate(a_h(nbase_h), a_u(nbase_u), a_v(nbase_v))
!
        allocate(Mpk1_hu(nbase_eta,nbase_hu), Mpk1_hv(nbase_eta,nbase_hv), hgn1(nbase_hu,nbase_eta), hgn2(nbase_hv,nbase_eta))
        allocate(un1(nbase_hu,nbase_hu),un2(nbase_hu,nbase_hv), vn1(nbase_hv,nbase_hu), vn2(nbase_hv,nbase_hv))
        allocate(Mpk_deta(nbase_eta,nbase_eta),Mpk_dhu(nbase_hu,nbase_hu),Mpk_dhv(nbase_hv,nbase_hv))  
        allocate(Mpk_u(nbase_u,nbase_hu), Mpk_v(nbase_v,nbase_hv))
        allocate(Sfxu(nbase_hu,nbase_u), Sfxv(nbase_hu,nbase_v), Sfyv(nbase_hv,nbase_v), Sfyu(nbase_hv,nbase_u))
!
        allocate(hun1(nbase_eta), hvn2(nbase_eta), deta(nbase_eta), hgHn1(nbase_hu), hgHn2(nbase_hv))
        allocate(huun1(nbase_hu), huun2(nbase_hu), huvn1(nbase_hv), hvvn2(nbase_hv), dhu(nbase_hu), dhv(nbase_hv))
        allocate(Sfx1(nbase_hu), Sfx2(nbase_hu), Sfy1(nbase_hv), Sfy2(nbase_hv))
!
        allocate(vectpod(nbase_hu,6))
        allocate(Bzmij(nelt), BQi_eta(nelt), BQi_hu(nelt), BQi_hv(nelt))
        allocate(huun1full(nelt), huun2full(nelt), huvn1full(nelt), hvvn2full(nelt), podlamdafull(nelt), sourcfric_hu(nelt), sourcfric_hv(nelt))
!       
        allocate(zero_pod(nbase_eta), pod_friction_hu(nbase_hu), pod_friction_hv(nbase_hv))
        zero_pod = 0.0
!
        print*, "Lecture des bases modales pour le POD"
!
        call lecture_fichier_matlab(391, nelt, nbase_h, phi_h)
        call lecture_fichier_matlab(392, nelt, nbase_eta, phi_eta)
        call lecture_fichier_matlab(397, nelt, nbase_eta_tild, phi_eta_tild)
        call lecture_fichier_matlab(393, nelt, nbase_hu,  phi_hu)
        call lecture_fichier_matlab(395, nelt, nbase_u,   phi_u)
        if(dim == 2) then
            call lecture_fichier_matlab(394, nelt, nbase_hv,  phi_hv)
            call lecture_fichier_matlab(396, nelt, nbase_v, phi_v)
        else
            phi_hv = zero
            phi_v = zero
        endif           
!
!***********************************************************************************************************************************
!       Lecture des éléments à l'entrée du domaine pour l'imposition du débit
            open(unit=507,file='Donnees_entree_dom.dat',status="old")
                read(507,*) nelt_entree
                allocate(donnees_entree(nelt_entree,4))
                do i=1,nelt_entree
                    read(507,*) donnees_entree(i,1), donnees_entree(i,2), donnees_entree(i,3), donnees_entree(i,4)
                enddo
            close(507)    
!   *** ***
!       Lecture des éléments à la sortie du domaine pour l'imposition de la condition de flux de sortie  
            open(unit=508,file='Donnees_sortie_dom.dat',status="old")
                read(508,*) nelt_sortie
                allocate(donnees_sortie(nelt_sortie,4))
                do i=1,nelt_sortie
                    read(508,*) donnees_sortie(i,1), donnees_sortie(i,2), donnees_sortie(i,3), donnees_sortie(i,4)
                enddo
            close(508)       
!***********************************************************************************************************************************
        Print*,"Calcul des matrices constantes pour POD"
        call matrice_POD(zm,surf)
!
            do ib = 1 , nbase_eta 
                write(2001,'(30f14.6)') (Mpk1_hu(ib,jb),jb=1,nbase_hu)
                write(2002,'(30f14.6)') (Mpk1_hv(ib,jb),jb=1,nbase_hv)
                write(2003,'(30f14.6)') (Mpk_deta(ib,jb),jb=1,nbase_eta)                
            enddo
            do ib = 1 , nbase_hu 
                write(2004,'(30f14.6)') (Mpk_dhu(ib,jb),jb=1,nbase_hu)
                write(2009,'(30f14.6)') (Sfxu(ib,jb),jb=1,nbase_hu)
                do jb = 1, nbase_eta
                    write(2013,'(30f14.6)') (Cg2(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_u
                    write(2011,'(30f14.6)') (Chuu2(ib,jb,kb),kb=1,nbase_hu)
                enddo
                do jb = 1, nbase_u
                    write(2012,'(30f14.6)') (Chuv2(ib,jb,kb),kb=1,nbase_hv)
                enddo
            enddo
            do ib = 1 , nbase_hv 
                write(2005,'(30f14.6)') (Mpk_dhv(ib,jb),jb=1,nbase_hv)
                write(2010,'(30f14.6)') (Sfxv(ib,jb),jb=1,nbase_hv)
                do jb = 1, nbase_eta
                    write(2016,'(30f14.6)') (Cg3(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_v
                    write(2014,'(30f14.6)') (Chvv3(ib,jb,kb),kb=1,nbase_hv)
                enddo
                do jb = 1, nbase_v
                    write(2015,'(30f14.6)') (Chuv3(ib,jb,kb),kb=1,nbase_hu)
                enddo
            enddo
            do ib = 1 , nbase_u 
                write(2006,'(30f14.6)') (Mpk_u(ib,jb),jb=1,nbase_hu)
            enddo
            do ib = 1 , nbase_v 
                write(2007,'(30f14.6)') (Mpk_v(ib,jb),jb=1,nbase_hv)
            enddo
            do ib = 1 , nbase_v
                write(2008,'(30f14.6)') phi_h_zi(ib)
            enddo
!
!************************************************************************************************
        close(1006)
        close(2001)
        close(2002)
        close(2003)
        close(2004)
        close(2005)
        close(2006)
        close(2007)
        close(2008)
        close(2009)
        close(2010)
        close(2011)
        close(2012)
        close(2013)
        close(2014)
        close(2015)
        close(2016)

!****************************************************************************************************
end subroutine POD_ROM_matrices
!==================================================================================
!==================================================================================

subroutine pod_source_friction(surf,zm)
!
! ======================================================================
!
!     pod_source_friction : Calcul et Reduction du terme source de friction pour le pod
!
!     auteur : Jean-Marie Zokagoa  GRANIT ETSMTL
!
!     version : 1.0  ;  Fevrier 22 2011
! ======================================================================
!
    use precision_m
    use global
    use m_param
!
    implicit none
!
! ... variables passees en parametre ...................................
!
    real(fp_kind), dimension(:), intent(in) :: surf, zm
!
! ... variables locales ................................................
!
    real(fp_kind)     :: haut, eta_FV, hu_FV, hv_FV, chezy2, vitu, vitv, normvit, sourcfric1, sourcfric2
    integer     :: kvol, i, k
!
! ... debut du traitement
!
!*** Calcul du terme source de friction par les volumes finis
    do kvol=1,nelt
!
        sourcfric_hu(kvol)=0.d0
        sourcfric_hv(kvol)=0.d0
!
! ****** Extraction de la solution Volumes Finis de POD
        eta_FV = 0.d0
        hu_FV  = 0.d0
        hv_FV  = 0.d0
        do k=1,nbase_eta
            eta_FV = eta_FV + a0_eta(k) * phi_eta(kvol,k)
        enddo
        do k=1,nbase_hu
            hu_FV  = hu_FV  + a0_hu(k)  * phi_hu(kvol,k)
        enddo
        do k=1,nbase_hv
            hv_FV  = hv_FV  + a0_hv(k)  * phi_hv(kvol,k)
        enddo
!
        haut = eta_FV - zm(kvol)
!
        if (  haut <= tolisec ) then                
            sourcfric1 = 0.D0
            sourcfric2 = 0.D0
        else                                                
            vitu = hu_FV / haut
            vitv = hv_FV / haut
            normvit = sqrt( vitu**2 + vitv**2 )
            chezy2 = haut**(1.d0/3.d0) / manning**2         
            if ( normvit <= tolisec ) then
                normvit= 0.D0
            endif
            sourcfric1 = - gp * vitu * normvit / chezy2 
            sourcfric2 = - gp * vitv * normvit / chezy2
        endif
!       
        sourcfric_hu(kvol)=sourcfric1
        sourcfric_hv(kvol)=sourcfric2
!
    enddo
!
!***   Reduction du terme source de friction ***
!
    do k=1,nbase_hu 
        pod_friction_hu(k) = 0.d0      
        do i=1,nelt    
            pod_friction_hu(k) = pod_friction_hu(k) + phi_hu(i,k) * sourcfric_hu(i)
        enddo        
    enddo
    do k=1,nbase_hu 
        pod_friction_hv(k) = 0.d0      
        do i=1,nelt    
            pod_friction_hv(k) = pod_friction_hv(k) + phi_hv(i,k) * sourcfric_hv(i)
        enddo        
    enddo 
!     
! ... fin du traitement ................................................
!
end subroutine pod_source_friction
!==================================================================================
!==================================================================================

!==================================================================================
!==================================================================================

!==================================================================================
!==================================================================================

!==================================================================================
!==================================================================================

