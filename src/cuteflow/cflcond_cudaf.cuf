attributes(global) subroutine cflcond_cudaf(solut_d, deltatmin_d)
  ! ======================================================================
  !     cfl_dcond = calculation of the time step following the cfl_d
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global_device

  implicit none

  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)     :: solut_d
  real(fp_kind), intent(inout)                  :: deltatmin_d(nelt_d-nelt_fant_recep_d)

  real(fp_kind)               :: hauteur, vitessu, vitessv, normvites, vitessmax
  integer                     :: ti,gi

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti


  if(gi <= nelt_d-nelt_fant_recep_d) then
    deltatmin_d(gi) = 1000000.0D0
    hauteur = solut_d(1,gi)
    if ( hauteur > tolisec_d ) then
      vitessu = solut_d(2,gi) / hauteur
      vitessv = solut_d(3,gi) / hauteur
      normvites = sqrt(vitessu**2 + vitessv**2)
      vitessmax = max( 0.01D0, (normvites + sqrt(gp_d * abs(hauteur))))
      deltatmin_d(gi) = min( cfl_d * cotemin_arr_d(gi)/vitessmax, 1000000.0D0)
    else
      deltatmin_d(gi) = 1000000.0D0
    endif
  endif   
  dt_d=1000000.0D0
end subroutine cflcond_cudaf

attributes(global) subroutine cflcond_sec_cudaf(solut_d, deltatmin_d, dt_d)
  !!Met le pas de temps minimal des mailles mouill√©es dans toutes les mailles seches

  use precision_m
  use global_device

  implicit none

  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)     :: solut_d
  real(fp_kind), intent(inout)                  :: deltatmin_d(nelt_d-nelt_fant_recep_d)
  real(fp_kind), intent(in)                     :: dt_d

  integer                     :: i, j
  real(fp_kind)               :: hauteur
  integer                     :: ti,gi

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti

  if(gi <= nelt_d-nelt_fant_recep_d) then
    hauteur = solut_d(1,gi)
    if ( hauteur <= tolisec_d ) then
      deltatmin_d(gi) = 1e-3*dt_d*cotemin_d/cotemin_arr_d(gi)
    endif
  endif   
end subroutine cflcond_sec_cudaf

attributes(global) subroutine cflcond_reduc_cudaf(solut_d, deltatmin_d)

  use precision_m
  use global_device

  implicit none

  real(fp_kind), dimension(ndln_d,nelt_d), intent(in)     :: solut_d
  real(fp_kind), dimension(nelt_d-nelt_fant_recep_d), intent(inout)         :: deltatmin_d

  real(fp_kind)               :: hauteur, vitessu, vitessv, normvites, vitessmax
  integer                     :: ti,gi, i, ierr_d
  real(fp_kind), shared       :: s(*)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti


  s(ti) = 10000000.0D0
  dt_d = s(1)
  if(gi <= nelt_d-nelt_fant_recep_d) then
    deltatmin_d(gi) = 1000000.0D0
    hauteur = solut_d(1,gi)
    if ( hauteur > tolisec_d ) then
      vitessu = solut_d(2,gi) / hauteur
      vitessv = solut_d(3,gi) / hauteur
      normvites = sqrt(vitessu**2 + vitessv**2)
      vitessmax = max( 0.01D0, (normvites + sqrt(gp_d * abs(hauteur))))
      deltatmin_d(gi) = min( cfl_d * cotemin_arr_d(gi)/vitessmax, 1000000.0D0)
      ! deltatmin_d(gi) = 1e-5
    else
      deltatmin_d(gi) = 1000000.0D0
    endif
    s(ti) = deltatmin_d(gi)
  endif   

  call syncthreads()
  i = blockdim%x/2 !! Block dim doit etre divisible par 2
  do while(i/=1)
    if(threadidx%x <= i) then
      s(threadidx%x) = min(s(threadidx%x), s(threadidx%x + i))
    end if
    i = i/2
    call syncthreads()
  end do
  s(1) = min(s(1), s(2))

  if(ti == 1) then
    do while(atomicCas(mutex,0,1)/=0)
    end do
    dt_d = min(dt_d,s(1))
    ierr_d = atomicExch(mutex, 0)
  end if
end subroutine cflcond_reduc_cudaf

attributes(global) subroutine reduction(deltatmin_d)

  use precision_m
  use global_device

  implicit none

  real(fp_kind), dimension(nelt_d-nelt_fant_recep_d), intent(inout)         :: deltatmin_d

  real(fp_kind), shared       :: s(blockDim%x*sizeof(deltatmin_d(1)))
  integer :: i, ti, gi, ierr_d

  ti = threadIdx%x
  ! gi = (blockIdx%x - 1)*(blockDim%x*2)+ ti
  gi = (blockIdx%x - 1)*blockDim%x+ ti

  if(gi<=nelt_d-nelt_fant_recep_d) then
    s(ti) = deltatmin_d(gi)
  else
    s(ti) = 100000.0d0
  end if

  ! if(gi+blockDim%x<=nelt_d-nelt_fant_recep_d) then
  !   s(ti) = min(s(ti), deltatmin_d(gi+blockDim%x))
  ! end if
  call syncthreads()

  i = blockdim%x/2
  do while(i>=1)
    if(ti <= i) then
      s(ti) = min(s(ti),s(ti+i))
    end if
    i = i/2
    call syncthreads()
  end do

  call syncthreads()
  if(ti==1) then
    ierr_d = atomicmin(dt_d,s(1))
  end if
  call syncthreads()
end subroutine reduction
