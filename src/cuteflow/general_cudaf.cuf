program general
  ! ======================================================================
  !   CUTEFLOW : programme de simulation par volumes finis / solveurs de Riemann
  !               des ecoulements de canalisations, bris de barrages et innondations.
  !               Equations de base : Shallow Water Equations
  ! ======================================================================
  !     Auteur : Youssef Loukili  & Jean-Marie Zokagoa & Vincent Delmas GRANIT ETSMTL
  !     version : 4.0  ;  December 2019
  ! ======================================================================

  use precision_m
  use global
  use m_param
  use cudafor
  use global_device
  use mpi
  use mpiDeviceUtil

  use pre_post_traitement
  use Full_FV_module
  use condition_initial
  use maillage

  implicit none

  integer         :: i, ii, j, p, kk, ss, ie, iel, nt, n_MC, i_MC, af_input
  integer         :: nsbloc, nreste, tot
  character(4)    :: i_MC_char
  integer         :: status, l, ie_coupe_transv, ierr, dev
  real(fp_kind)   :: d2, t2, dtime2, tcm2, d, t, zero, time_start, time_stop
  real(fp_kind)   :: errf, errf1, errf2, errf3, errf4, errf5
  real            :: time_cuda
  type(dim3 )     :: grid, tblock, grid_nodes, tblock_nodes, grid11, tblock11
  type(cudaEvent) :: startEvent , stopEvent
  integer                     :: stat(MPI_STATUS_SIZE)

  call MPI_INIT(mpi_ierr)
  call MPI_COMM_RANK (MPI_COMM_WORLD, mpi_process_id, mpi_ierr)
  call MPI_COMM_SIZE (MPI_COMM_WORLD, num_mpi_process, mpi_ierr)

  !! Setting proper GPU device for each MPI process
  !! ierr = cudaDeviceReset()
  call assignDevice(dev)
  ierr = cudaSetDevice(dev)
  ierr = cudaGetDeviceProperties (prop , 0)
  call cuda_glerror('ierr <- cudaGetDeviceProperties <-- general_cudaf.cuf)',1)

  write(*,"('Device name:',a, 'thread id : ', i1)") trim(prop%name), mpi_process_id
  write(*,"('Compute capability : ',i1,'.',i1)") prop%major, prop%minor

  gridylim = 65535
  gridxlim = 2147483647

  zero      = 0.d0


  !!Création des cuda stream
  istat = cudaStreamCreate(stream1)
  istat = cudaStreamCreate(stream2)
  istat = cudaStreamCreate(stream3)

  !! Ecriture du nom de process dans une chaine de caracteres
  write(mpi_process_id_string, "(I3)") mpi_process_id

  !! Lecture des données (terrain, maillage, initiales, simulation)
  call lec_donnees

  allocate(dt)
  allocate(dt_max)
  dt_max=1000000.0D0

  !! Data transfer from host to device
  call global_data_transfer

  !! Initization of the iteration counters
  comptvisu        = 0
  cptviscoupe      = 1
  cptsolvtk        = 1
  cptsoljauge      = 1
  cptsolrestart    = 1
  cptsolsimple      = 0
  ie_coupe_transv  = 0
  tc_init          = 0
  tc_init_d        = tc_init

  !! Construction / lecture  et  stockage du maillage 
  print*,mpi_process_id,"lect const mail debut"
  call lect_const_mail
  print*,mpi_process_id,"lect const mail fin"

  cotemin_arr_d = cotemin_arr
  call cuda_glerror('ierr <-- cotemin_arr_d = cotemin_arr',1)

  !!Alocation req send recv pour echange mpi non bloquant
  if(is_cgns) then
    allocate(reqsend(nelt_fant_envoi_bloc), sendstat(MPI_STATUS_SIZE,nelt_fant_envoi_bloc))
    allocate(reqrecv(nelt_fant_recep_bloc), recvstat(MPI_STATUS_SIZE,nelt_fant_recep_bloc))
  else
    tot=0
    do j=1,nelt_fant_envoi_bloc
      nsbloc = ndln*elt_fant_envoi_bloc(j,2)/768 + 1
      nreste = ndln*elt_fant_envoi_bloc(j,2)-(nsbloc-1)*768
      tot=tot+nsbloc
    end do
    allocate(reqsend(tot), sendstat(MPI_STATUS_SIZE,tot))

    tot=0
    do j=1,nelt_fant_recep_bloc
      nsbloc = ndln*elt_fant_recep_bloc(j,2)/768 + 1
      nreste = ndln*elt_fant_recep_bloc(j,2)-(nsbloc-1)*768
      tot=tot+nsbloc
    end do
    allocate(reqrecv(tot), recvstat(MPI_STATUS_SIZE,tot))
  end if

  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)

  !! Allocation des matrices et vecteurs
  allocate( surf(nelt), zm(nelt) )
  allocate( surf_d(nelt), zm_d(nelt) )

  allocate( vdlg(ndln,nelt), vdlg0(ndln,nelt))

  !!Allocation des variables sur GPU avec leur pointeurs
  allocate( vdlg_d(ndln,nelt), vdlg0_d(ndln,nelt))

  if(diffusion) allocate(vdlg_nodes_d(ndln,nnt))

  allocate( she0(nnt), sh0(nnt), shu0(nnt), shv0(nnt), su0(nnt), sv0(nnt) )

  allocate( tsoljauge(200000), tsolrestart(200000), tsolvtk(200000), tsolsimple(200000))

  !! Ouverture/creation des fichiers (opening / creating files)
  call ouv_fichiers
  vdlg_d = vdlg

  !! Construction of visualization vectors in post-processing
  if (solvtk == 1) then
    do ii = 1,vtk_snapshots
      tsolvtk(ii) = ii*ts/(1.0*vtk_snapshots)
    enddo
  endif

  if (solsimple /= 0) then
    do ii = 1,simple_snapshots
      tsolsimple(ii) = ii*ts/(1.0*simple_snapshots)
    enddo
  endif

  if (solrestart == 1) then
    do ii = 1,restart_snapshots
      tsolrestart(ii)= ii*ts/(1.0*restart_snapshots)
    enddo
  endif 

  !! Calculation of the area and the gradient term z of each element
  tblock = dim3(64, 1, 1)
  grid   = dim3(ceiling(real(nelt)/real(tblock%x)), 1, 1)

  call surfzm_cudaf<<<grid, tblock>>>(surf_d,zm_d)

  zm      = zm_d
  surf    = surf_d

  write(*,*) '======================================================================'
  write(*,*) ' Parameters'
  write(*,*) '======================================================================'
  write(*,*) 'meshfile            = ', meshfile 
  write(*,*) 'cotemin             = ', cotemin
  write(*,*) 'elt_bound           = ', elt_bound
  write(*,*) 'H_AMONT             = ', H_AMONT 
  write(*,*) 'U_AMONT             = ', U_AMONT
  write(*,*) 'V_AMONT             = ', V_AMONT
  write(*,*) 'H_AVAL              = ', H_AVAL
  write(*,*) 'U_AVAL              = ', U_AVAL
  write(*,*) 'V_AVAL              = ', V_AVAL 
  write(*,*) 'iflux               =', iflux
  write(*,*) 'Fricimplic          =', fricimplic
  write(*,*) 'solrestart          =', solrestart
  write(*,*) 'restart_snapshots   =', restart_snapshots
  write(*,*) 'solvtk               =', solvtk
  write(*,*) 'vtk_snapshots     =', vtk_snapshots
  write(*,*) 'tol_reg_perm        =', tol_reg_perm
  write(*,*) 'tol                 =', tol
  write(*,*) 'tolisec             =', tolisec
  write(*,*) 'tolaffiche          =', tolaffiche
  if(mpi_process_id==0) write(*,*) "nombre d'elements totaux = ",nelt_global_non_fant
  write(*,*) 'freqaffich          =', freqaffich
  write(*,*) 'nombre entree       =', nombre_entrees
  do af_input=1,nombre_entrees
    write(*,*) 'debitglob       ', af_input, " =", debitglob(af_input)
    write(*,*) 'longueur entree ', af_input, " =", long_entree(af_input)
  end do
  write(*,*) 'nombre sortie       =', nombre_sorties
  do af_input=1,nombre_sorties
    write(*,*) 'H_SORTIE        ', af_input, " =", h_sortie(af_input)
  end do
  write(*,*) '======================================================================'
  write(*,*) '======================================================================'

  !! Initialisation a zero des differents vecteurs
  vdlg0              = zero
  vdlg               = zero

  vdlg0_d  = vdlg0
  vdlg_d   = vdlg

  !! Application des conditions initiales
  if (solinit==1) then
    call read_cond_initial(vdlg0) 
    vdlg0_d = vdlg0
  else
    call cond_initial_cudaf<<<grid, tblock>>>(zm_d, vdlg0_d)
  endif               

  !!Fix non walls
  call set_unset_as_wall<<<grid, tblock>>>()

  !! Calcul de la solution initiale sur les noeuds
  valtemps = '0.0'

  vdlg0 = vdlg0_d
  call sol_nodes(vdlg0,surf,zm,sh0,she0,shu0,shv0,su0,sv0)

  !!  Storage for postraitement with possibility of animation (Tecplot)
  if(solvtk) then             
    start=1
    call paraview_export(vdlg0, zm, she0, sh0, shu0, shv0, cptsolvtk)
    cptsolvtk = cptsolvtk + 1
  endif

  if(solsimple/=0) then
    start=1
    call simple_export(vdlg0, zm, she0, sh0, shu0, shv0, cptsolsimple)
    cptsolsimple = cptsolsimple + 1
  end if

  !! Initialisation du temps et calcul de dt via la CFL
  tc = 0.00
  tc_d = tc

  !! FULL FINITE VOLUME
  call Full_FV 

  close(ec_solj_h)
  close(ec_solj_u)

  close(ec_tecplot)
  close(320)
  close(330)

  close(350)
  close(360)
  close(370)

  close(400)

  if(solrestart==1) then
    close(ec_sol_elt_t)
    close(ec_sol_nd_t)
  endif

  d=temps_final-temps_initial

  print*, '==========================================================================='
  print*, '=========================   FIN DE LA SIMULATION   ========================'
  print*, '==========================================================================='
  print*, ''
  print*, 'DUREE DU CALCUL :', d, ' Secondes '
  if (d >= 60)    print*, '   soit:',  d/60,    ' Minutes'
  if (d >= 3600)  print*, '   soit:', d/3600,  ' Heures'
  if (d >= 86400) print*, '   soit:', d/86400, ' Jours'
  print*, '==========================================================================='
  print*, '==========================================================================='   

  !! Enregistrment du temps cpu de calcul (calculating cpu time registration) 
  write(ec_bilan_sim,*) '====================================================================='
  write(ec_bilan_sim,*) '======================= FIN DE LA SIMULATION ========================'
  write(ec_bilan_sim,*) '====================================================================='
  write(ec_bilan_sim,*) ''

  write(ec_bilan_sim,*) 'MODELE FULL-ORDER VOLUMES FINIS'
  write(ec_bilan_sim,*) ''

  if ( t_reg_perm > 0. ) then
    write(ec_bilan_sim,*) ' REGIME PERMANENR ATTEINT A : T =', t_reg_perm, ' Secondes'
    write(ec_bilan_sim,*) ''
    do af_input=1,nombre_entrees
      write(ec_bilan_sim,*) 'debit_entre ',af_input, " = ",  debit_entree
    end do
    write(ec_bilan_sim,*) 'debit_sorti =', debit_sortie
    write(ec_bilan_sim,*) ''
  else
    write(ec_bilan_sim,*) 'TEMPS DE SIMULATION ATTEINT A : T = ', tc, ' Secondes'
    write(ec_bilan_sim,*) ''
  endif

  write(ec_bilan_sim,*) 'DUREE DU CALCUL :', d, ' Secondes'
  if (d >= 60)    print*, '   soit:',  d/60,    ' Minutes'
  if (d >= 3600)  print*, '   soit:', d/3600,  ' Heures'
  if (d >= 86400) print*, '   soit:', d/86400, ' Jours'
  write(ec_bilan_sim,*) '====================================================================='
  write(ec_bilan_sim,*) '====================================================================='  

  close(ec_bilan_sim)
  close(3001)
  close(3002)
  close(3003)

  call MPI_FINALIZE(mpi_ierr)
end program
