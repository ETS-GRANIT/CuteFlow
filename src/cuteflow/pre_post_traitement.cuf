module pre_post_traitement
  implicit none
contains

  subroutine sol_nodes(soleta,solh,solhu,solhv,solu,solv)
    ! ======================================================================
    !     sol_nodes = calcul de la solution aux noeuds du maillage par
    !                 moyennes ponderees sur les volumes entourants
    !     auteur : Youssef Loukili  GRANIT ETSMTL
    !     version : 1.0  ;  May 12 2003
    ! ======================================================================

    use precision_kind
    use global_data
    use global_data_device
    use file_id

    implicit none

    real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv, solu, solv

    real(fp_kind), dimension(:), allocatable :: surfno, zzz

    integer :: kvol, i, no
    allocate(  surfno(nnt), zzz(nnt) )

    surfno = 0.0d0
    soleta  = 0.0d0
    solh   = 0.0d0
    solhu   = 0.0d0
    solhv   = 0.0d0
    solu   = 0.0d0
    solv   = 0.0d0
    zzz    = 0.0d0

    do kvol=1,nelt
      do i=1,ns
        no = connectivite(kvol,i)
        surfno(no) = surfno(no) + surf(kvol)
        zzz(no) = zzz(no) + surf(kvol) * zm(kvol)
        if ( vdlg(1,kvol) > tolisec ) then
          solh(no)   = solh(no)  + surf(kvol) * vdlg(1,kvol)
          soleta(no)    = soleta(no)   + surf(kvol) * ( vdlg(1,kvol) + zm(kvol) )
          solhu(no)    = solhu(no)   + surf(kvol) * vdlg(2,kvol) 
          solhv(no)    = solhv(no)   + surf(kvol) * vdlg(3,kvol)
        else
          soleta(no)    = soleta(no)   + surf(kvol) * ( tolisec + zm(kvol) )
        endif
      enddo
    enddo

    do no=1,nnt
      zzz(no) = zzz(no) / surfno(no)
      solh(no) = solh(no) / surfno(no)
      if ( solh(no) <= tolisec ) then
        solh(no) = tolisec
        soleta(no)  = zzz(no)
        solhu(no)  = 0.
        solhv(no)  = 0.
        solu(no)  = 0.
        solv(no)  = 0.
      else
        soleta(no) = soleta(no) / surfno(no)
        solhu(no)  = solhu(no)  / surfno(no)
        solhv(no)  = solhv(no)  / surfno(no)
        solu(no)   = solhu(no)  / (solh(no)*surfno(no))
        solv(no)   = solhv(no)  / (solh(no)*surfno(no))
      endif
    enddo

    deallocate(surfno, zzz)
  end subroutine sol_nodes

  subroutine ouv_fichiers
    use precision_kind
    use global_data
    use file_id
    implicit none

    open(unit=ec_bilan_sim,file='RAPPORT_SIMULATION.txt',status="unknown")

    if(num_mpi_process>1) then
      sol_elt_ts = trim(adjustl(mpi_process_id_string))//trim(adjustl('_solution_elements_restart.txt'))
    else
      sol_elt_ts = trim(adjustl('solution_elements_restart.txt'))
    end if

    if(solrestart==1) then
      open(ec_sol_elt_t, file=sol_elt_ts, status="unknown")
    endif
  end subroutine ouv_fichiers

  subroutine bluekenue_export(solh, soleta, solhu, solhv)
    ! =================================================================================
    !     bluekenue_export == Exporte dans un fichier pour postraitement avec Bluekenue
    !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
    !     version : 2.0  ;  mai 31 2010
    ! =================================================================================

    use precision_kind
    use global_data
    use file_id

    implicit none

    real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

    integer :: nd, iel
    real(fp_kind) :: solu, solv

    write(valtemps,'(f12.3)') tc 
    if(num_mpi_process>1) then
      solfile_eta_T3S = trim(adjustl(mpi_process_id_string)) // '_solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_h_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_u_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_v_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    else
      solfile_eta_T3S = 'solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_h_T3S   = 'solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_u_T3S   = 'solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_v_T3S   = 'solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    end if

    open(unit=ec_Bluekenu_eta,file=solfile_ETA_T3S,status="unknown")
    open(unit=ec_Bluekenu_h,file=solfile_H_T3S,    status="unknown")
    open(unit=ec_Bluekenu_u,file=solfile_U_T3S,    status="unknown")
    open(unit=ec_Bluekenu_v,file=solfile_V_T3S,    status="unknown")

    write(ec_Bluekenu_eta,*) ':NodeCount', nnt
    write(ec_Bluekenu_eta,*) ':ElementCount', nelt
    write(ec_Bluekenu_eta,*) ':ElementType  T3'
    write(ec_Bluekenu_eta,*) ':EndHeader'

    write(ec_Bluekenu_h,*) ':NodeCount', nnt
    write(ec_Bluekenu_h,*) ':ElementCount', nelt
    write(ec_Bluekenu_h,*) ':ElementType  T3'
    write(ec_Bluekenu_h,*) ':EndHeader'

    write(ec_Bluekenu_u,*) ':NodeCount', nnt
    write(ec_Bluekenu_u,*) ':ElementCount', nelt
    write(ec_Bluekenu_u,*) ':ElementType  T3'
    write(ec_Bluekenu_u,*) ':EndHeader'

    write(ec_Bluekenu_v,*) ':NodeCount', nnt
    write(ec_Bluekenu_v,*) ':ElementCount', nelt
    write(ec_Bluekenu_v,*) ':ElementType  T3'
    write(ec_Bluekenu_v,*) ':EndHeader'

    do nd=1, nnt
      if ( solh(nd) > tolisec ) then
        solu = solhu(nd)/solh(nd)
        solv = solhv(nd)/solh(nd)
      else
        solu = 0.d0
        solv = 0.d0
      endif
      write(ec_Bluekenu_eta,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)-sol_z_offset
      write(ec_Bluekenu_h,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solh(nd)
      write(ec_Bluekenu_u,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solu
      write(ec_Bluekenu_v,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solv
    enddo
    do iel=1, nelt
      write(ec_Bluekenu_eta,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_h,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_u,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_v,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    enddo

    close(ec_Bluekenu_eta)
    close(ec_Bluekenu_h)
    close(ec_Bluekenu_u)
    close(ec_Bluekenu_v)

  end subroutine bluekenue_export

  subroutine simple_export(vdlg, zm, solh, soleta, solhu, solhv, ci)

    use precision_kind
    use global_data
    use file_id

    implicit none

    integer, intent(in) :: ci
    real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv, zm
    real(fp_kind), dimension(:,:), intent(in)  :: vdlg

    integer :: nd, iel, i
    integer                     :: stat(MPI_STATUS_SIZE)

    if(ci==-1) then
      write(valtemps,*) "Final"
    else if(ci==0) then
      write(valtemps,*) "Initial"
    else
      write(valtemps,'(I20)') ci-1
    end if

    if(solsimple==1 .or. solsimple==3) then 
      if(num_mpi_process>1) then
        solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      else
        solfile_simple = 'solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      end if
      open(unit=ec_sol_simple_nd,file=solfile_simple,status="unknown")
      write(ec_sol_simple_nd,*) tc                        
      do nd=1,nnt
        write(ec_sol_simple_nd,'(4f16.6)') solh(nd), soleta(nd)-sol_z_offset, solhu(nd), solhv(nd)
      end do
      close(ec_sol_simple_nd)
    end if

    if(solsimple==2 .or. solsimple==3) then 
      if(num_mpi_process>1) then
        solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      else
        solfile_simple = 'solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      end if
      open(unit=ec_sol_simple_elt,file=solfile_simple,status="unknown")
      write(ec_sol_simple_elt,*) tc                        
      do iel=1,nelt
        write(ec_sol_simple_elt,'(4f16.6)') vdlg(1,iel), vdlg(1,iel)+zm(iel)-sol_z_offset, vdlg(2,iel), vdlg(3,iel)
      end do
      close(ec_sol_simple_elt)
    end if
  end subroutine simple_export

  subroutine cgns_export(solh, solhu, solhv, t, it)
    use global_data
    use precision_kind
    use file_id
    use cgns

    implicit none 

    integer, intent(in) :: it
    real(fp_kind), intent(in) :: t
    real(fp_kind), dimension(:), intent(in) :: solh, solhu, solhv

    integer :: my_zone
    integer :: ierr, fn, n_bases, base, cellDim, physDim, n_zones, zone, zoneType, sizes(3*3), ord, i
    integer :: field_wd, field_vx, field_vy, field_vz, field_mx, field_my, field_mz, field_b, field_fs
    integer, dimension(2) :: idata
    character(200) :: basename, zonename

    !!Read cgns file and goto good location
    call cgp_pio_mode_f(0, ierr)

    call cgp_open_f(meshfile, CG_MODE_MODIFY, fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cg_nbases_f(fn, n_bases, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f
    base = 1

    call cg_base_read_f(fn, base, basename, cellDim, physDim, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    call cg_nzones_f(fn, base, n_zones, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    do zone=1,n_zones
      call cg_zone_type_f(fn, base, zone, zoneType, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_zone_read_f(fn, base, zone, zonename, sizes, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_goto_f(fn, base, ierr, trim(adjustl(zonename)), 0, "end")
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_ordinal_read_f(ord, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      if(ord == mpi_process_id) then
        exit
      end if
    end do

    my_zone = zone

    if(it==1) then
      call cg_biter_write_f(fn, base, 'TimeIterValues', visu_snapshots, ierr)
      call cg_goto_f(fn, base, ierr,'BaseIterativeData_t',1,'end')
      !!RealDouble = 4
      call cg_array_write_f('TimeValues',4,1,visu_snapshots,tsolvisu,ierr)

      do zone=1,n_zones
        call cg_ziter_write_f(fn,base,zone,'ZoneIterativeData',ierr)
        call cg_goto_f(fn,base,ierr,'Zone_t',zone,'ZoneIterativeData_t',1,'end')
        idata(1)=32
        idata(2)=visu_snapshots
        !!Character = 5
        call cg_array_write_f('FlowSolutionPointers',5,2,idata,solname_visu,ierr)
      end do
    end if

    do zone=1,n_zones
      !!!Vertex = 2
      !!!Cellcenter = 3
      call cg_sol_write_f(fn, base, zone, solname_visu(it), 3, it, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      !!RealDouble = 4
      call cgp_field_write_f(fn, base, zone, it, 4, 'Water Depth', field_wd, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'Bathymetry', field_b, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'Free surface elevation', field_fs, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'MomentumX', field_mx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'MomentumY', field_my, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'MomentumZ', field_mz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'VelocityX', field_vx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'VelocityY', field_vy, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, it, 4, 'VelocityZ', field_vz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f
    end do

    zone = my_zone

    !!Not on gpu to save gpu memory
    do i=1,nelt
      vdlg_visu(i,1) = vdlg(1,i)

      vdlg_visu(i,2) = vdlg(2,i)
      vdlg_visu(i,3) = vdlg(3,i)
      vdlg_visu(i,4) = 0.

      if(vdlg_visu(i,1) > tolisec) then
        vdlg_visu(i,5) = vdlg(2,i)/vdlg(1,i)
        vdlg_visu(i,6) = vdlg(3,i)/vdlg(1,i)
        vdlg_visu(i,7) = 0.
      else 
        vdlg_visu(i,5) = 0.
        vdlg_visu(i,6) = 0.
        vdlg_visu(i,7) = 0.
      end if

      vdlg_visu(i,8) = vdlg(1,i) + zm(i) - sol_z_offset
    end do

    call cgp_field_write_data_f(fn, base, zone, it, field_wd, 1, nelt,  vdlg_visu(1,1), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_b, 1, nelt,  zm, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_fs, 1, nelt,  vdlg_visu(1,8), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_mx, 1, nelt,  vdlg_visu(1,2), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_my, 1, nelt,  vdlg_visu(1,3), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_mz, 1, nelt,  vdlg_visu(1,4), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_vx, 1, nelt,  vdlg_visu(1,5), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_vy, 1, nelt,  vdlg_visu(1,6), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, it, field_vz, 1, nelt,  vdlg_visu(1,7), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_close_f(fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

  end subroutine cgns_export

  subroutine paraview_export(vdlg, zm, solh, soleta, solhu, solhv, ci)
    ! ==============================================================================
    !     paraview_export == Exporte dans un fichier vtk pour postraitement avec paraview
    !     auteur : Delmas Vincent
    !     version : 2.0  ;  july 31 2019
    ! ==============================================================================

    use precision_kind
    use global_data
    use file_id

    implicit none

    real(fp_kind), dimension(:,:), intent(in)  :: vdlg
    real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv, zm

    integer :: nd, iel, ci
    real(fp_kind) :: solu, solv

    if(ci==-1) then
      write(valtemps,*) "Final"
    else if(ci==0) then
      write(valtemps,*) "Initial"
    else
      write(valtemps,'(I20)') ci-1
    end if

    solfile_para = trim(adjustl(trim(mpi_process_id_string)))//'_solution-Paraview_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.vtk'))

    open(unit=ec_Paraview,file=solfile_para,status="unknown")

    write(ec_Paraview,'(a)') "# vtk DataFile Version 1.0"
    write(ec_Paraview,'(a)') "2D Unstructured Grid"
    write(ec_Paraview,'(a)') "ASCII"
    write(ec_Paraview,'(a)') ""

    write(ec_Paraview,'(a)') "DATASET UNSTRUCTURED_GRID"
    write(ec_Paraview,'(a,I10,a)') "POINTS", nnt, " float"

    do nd=1, nnt
      write(ec_Paraview,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), 0.
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10,I10)') "CELLS", nelt, 4*nelt
    do iel=1, nelt
      write(ec_Paraview,'(I1,3I10)') 3, connectivite(iel,1)-1, connectivite(iel,2)-1, connectivite(iel,3)-1
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10)') "CELL_TYPES", nelt
    do iel=1, nelt
      write(ec_Paraview,'(a)') "5"
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10)') "CELL_DATA", nelt
    write(ec_Paraview,'(a)') "SCALARS eta float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') vdlg(1,iel)+zm(iel)-sol_z_offset
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "SCALARS h float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') vdlg(1,iel)
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "SCALARS b float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') zm(iel)-sol_z_offset
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "VECTORS velocity float"
    do iel=1, nelt
      if ( vdlg(1,iel) > tolisec ) then
        solu = vdlg(2,iel)/vdlg(1,iel)
        solv = vdlg(3,iel)/vdlg(1,iel)
      else
        solu = 0.d0
        solv = 0.d0
      endif
      write(ec_Paraview,'(3f16.6)')   solu, solv, 0.
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "VECTORS flux float"
    do iel=1, nelt
      if ( vdlg(1,iel) > tolisec ) then
        write(ec_Paraview,'(3f16.6)')   vdlg(2,iel), vdlg(3,iel), 0.
      else
        write(ec_Paraview,'(3f16.6)')   0., 0., 0.
      endif
    end do

    close(ec_Paraview)

  end subroutine paraview_export

  subroutine tecplot_export(solh, soleta, solhu, solhv)
    ! ============================================================================
    !     tecplot_export == Export to a text file the solutions for postraitement with Tecplot
    !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
    !     version : 2.0  ;  mai 13 2018
    ! ============================================================================

    use precision_kind
    use global_data
    use file_id

    implicit none

    real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

    integer :: nd, i
    real(fp_kind) :: solu, solv

    if ( start == 1 ) then

      tecplot   =  trim(adjustl(mpi_process_id_string))//'_solution-Tecplot.dat'

      open(unit=ec_tecplot,file=tecplot,status="unknown")

      write(ec_tecplot,*) 'title = "hauteur"'
      write(ec_tecplot,*) 'variables = "x","y","z","h","eta","u","v", "manning"'
      write(ec_tecplot,*) 'zone t="pas:',valtemps, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle'

      do nd=1, nnt
        write(ec_tecplot,'(8f16.6)') coordonnees(nd,1),coordonnees(nd,2),coordonnees(nd,3),solh(nd),soleta(nd),solhu(nd),solhv(nd),manning_nd(nd)
      enddo

      write(ec_tecplot,*)' '
      write(ec_tecplot,*)' '

      do i=1, nelt
        write(ec_tecplot,*) connectivite(i,1) , connectivite(i,2) , connectivite(i,3)
      enddo

      write(ec_tecplot,*)' '
      write(ec_tecplot,*)' '

    else
      write(ec_tecplot,*) 'zone t="pas:',tc, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle', ',D=(feconnect)'
      do nd=1, nnt
        write(ec_tecplot,'(8f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)-solh(nd), solh(nd), soleta(nd), solhu(nd), solhv(nd), manning_nd(nd)
      enddo
      write(ec_tecplot,*)' '
      write(ec_tecplot,*)' '
    endif
  end subroutine tecplot_export
end module pre_post_traitement
