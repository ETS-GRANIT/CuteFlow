subroutine POD_PID_ROM(vdlg,vdlg0,vdlg1,vdlg01,sh0,she0,shu0,shv0,su0,sv0,surf,zm,ti,tf)
!====================================================================================================   
!                                       MODELE REDUIT
!====================================================================================================

! ======================================================================
!
!     Auteur : Jean-Marie Zokagoa
!
!     version : 2010
!
! ======================================================================
!
    use precision_m
    use global
    use m_param
!
!   use avdef
!   use avviewer
!   use dflib
!   use dfmt
!   use dflogm
!
    implicit none
! *** bloc interface ***
!
    interface
!
! ... variables passees en parametre .........................................................................................
!
        subroutine debit_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine debit_POD
!
        subroutine CL_sortie_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine CL_sortie_POD    
!        
        subroutine entree_sortie_domaine
            use precision_m
            use global
            use m_param
        end subroutine entree_sortie_domaine
!   
        subroutine matrice_POD(zm,surf)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine matrice_POD
!
        subroutine pod_source_friction(surf,zm)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:),  intent(in)  :: zm, surf
        end subroutine pod_source_friction
!   
        subroutine prod_Mpk_vect(droite,ni,nj,mat,vect1,vect2)
            use precision_m
            integer ,  intent(in)               :: ni,nj, droite
            real(fp_kind), dimension(:),  intent(in)  :: vect1
            real(fp_kind), dimension(:),  intent(out) :: vect2
            real(fp_kind), dimension(:,:),intent(in)  :: mat
        end subroutine prod_Mpk_vect
!
        subroutine prod_tenseur_vect(ni,nj,nk,tenseur,vect,matrx)
            use precision_m
            integer ,intent(in)                   :: ni,nj,nk
            real(fp_kind), dimension(:),    intent(in)  :: vect
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
            real(fp_kind), dimension(:,:,:),intent(in)  :: tenseur
        end subroutine prod_tenseur_vect
!
        subroutine prod_scalaire(ni,vect1,vect2,scal)
            use precision_m
            integer ,  intent(in)               :: ni
            real(fp_kind), dimension(:),  intent(in)  :: vect1, vect2
            real(fp_kind),                intent(out)  :: scal
        end subroutine prod_scalaire
!
        subroutine sol_nodes(vdlg,surf,zm,soleta,solh,solhu,solhv,solu,solv)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:,:), intent(in)   :: vdlg
            real(fp_kind), dimension(:), intent(in)     :: surf, zm
            real(fp_kind), dimension(:), intent(inout)  :: soleta,solh,solhu,solhv,solu,solv
        end subroutine sol_nodes
!
        subroutine lecture_fichier_matlab(nfichier,ni, nj, matrx)
            use precision_m
            integer ,intent(in)                   :: nfichier, ni, nj
            real(fp_kind), dimension(:,:),  intent(out) :: matrx
        end subroutine lecture_fichier_matlab
!
        subroutine mise_a_jr_zone_seche(zm,vdlg, vdlg1)
            use precision_m
            use global
            use m_param
            real(fp_kind), dimension(:), intent(in)       :: zm
            real(fp_kind), dimension(:,:), intent(inout)    :: vdlg, vdlg1
        end subroutine mise_a_jr_zone_seche
!
    end interface
!
!
! ... variables passees en parametre ...................................
!
    real(fp_kind),intent(out)                    :: ti, tf
    real(fp_kind), dimension(:), intent(in)      :: surf, zm
    real(fp_kind), dimension(:), intent(inout)   :: sh0, she0, shu0, shv0, su0, sv0 
    real(fp_kind), dimension(:,:), intent(inout) :: vdlg, vdlg0, vdlg1, vdlg01  
!
!*** Variables locales ***
    real(fp_kind), dimension(:,:), allocatable :: greta_lisec1
!   
    character (10) :: aaa, bbb, no_coupe
    integer :: i, ii, j, ib, jb, kb, p, kk, ss, iel, nd, dl, niter, iter, n, c, nt, n0, som, som1, som2, som3
    integer :: evoisin, status, k, l, icor
    integer :: premnoeud, deuxnoeud, nodjauge
    integer, dimension(30) :: nodjauges
!
    real(fp_kind) :: v, r, uinf, flux, s, xyc, xiel, yiel, coupe_y, distjaugm1, distjaug
    real(fp_kind) :: x, d, t, dtime, tcm, xc, yc, hauteur, newhaut, xnorm, zero, delta_debit0,delta_debit,deb_entre,deb_sorti,delta_eta
    real(fp_kind) :: volume_entre,volume_sorti, delta_volume, volume_total, volume0, volume1, volume2,vol_tot_init, delta_volume_tot, delta_sol_tot, som_dtres_tot
    real(fp_kind) :: h_output0, h_output, tc_arret, h_max, t_h_max, t_h_moy, scal, scal1, scal2, scal3, aux, Q_unit
!
    real(fp_kind) :: d2, t2, dtime2, tcm2
    
    zero      = 0.d0
    tc = 0.
    nt = 0          ! *** opérateur pour le nombre de pas ***
    comptvisu = 0
    cptvis2d = 1
    cptvis3d = 1
    cptvisjauge = 1
    Q_unit = -debitglob/long
!  
        print*, ''
        print*, 'MODEL REDUIT : POD/ROM'
        print*, ''
        open(unit=400,file='Imput_POD.txt',status="unknown")
        open(unit=498,file='Sol_A_POD.txt',status="unknown")
        open(unit=499,file='COUPE.txt',status="unknown")
!
        open(unit=2001,file='POD_Mpk1_hu.dat',status="unknown")
        open(unit=2002,file='POD_Mpk1_hv.dat',status="unknown")
        open(unit=2003,file='POD_Mpk_deta.dat',status="unknown")
        open(unit=2004,file='POD_Mpk_dhu.dat',status="unknown")
        open(unit=2005,file='POD_Mpk_dhv.dat',status="unknown")
        open(unit=2006,file='POD_Mpk_u.dat',status="unknown")
        open(unit=2007,file='POD_Mpk_v.dat',status="unknown")
        open(unit=2008,file='POD_Mphi_h_zi.dat',status="unknown")
        open(unit=2009,file='POD_MSfxu.dat',status="unknown")
        open(unit=2010,file='POD_MSfxv.dat',status="unknown")
        open(unit=2011,file='POD_MChuu2.dat',status="unknown")
        open(unit=2012,file='POD_MChuv2.dat',status="unknown")
        open(unit=2013,file='POD_MCg2.dat',status="unknown")
        open(unit=2014,file='POD_MChvv3.dat',status="unknown")
        open(unit=2015,file='POD_MChuv3.dat',status="unknown")
        open(unit=2016,file='POD_MCg3.dat',status="unknown")
!
        if(soldomaine==1) then
            open(1006,file='SOL_Dom_POD_ts.txt',status="unknown")
        endif
!       
        dt=dt
!
        i_seq_pod = 1

            write(num_seq_base1,'(i1)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base1// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base1// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base1// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base1// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base1// '.txt'
            base_u_num = 'BASE_u' //num_seq_base1// '.txt'
            base_v_num = 'BASE_v' //num_seq_base1// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base1// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base1// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base1// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base1// '.dat'
!
!       ------------------------------------------------------------------------------------------------ 
!                   
            open(unit=391,file=base_h_num,status="old")
            open(unit=392,file=base_eta_num,status="old")
            open(unit=393,file=base_hu_num,status="old")
            open(unit=394,file=base_hv_num,status="old")
            open(unit=395,file=base_u_num,status="old")
            open(unit=396,file=base_v_num,status="old")
            open(unit=397,file=base_eta_tild_num,status="old")
        !           
            read (391,*) nbase_h
            read (392,*) n_seq_base 
            read (392,*) nbase_eta
            read (393,*) nbase_hu
            read (394,*) nbase_hv
            read (395,*) nbase_u
            read (396,*) nbase_v
            read (397,*) n_seq_base
            read (397,*) nbase_eta_tild
!
            maxdimbase = max(nbase_h, nbase_eta, nbase_eta_tild, nbase_hu, nbase_hv, nbase_u, nbase_v)
!
            dt_seq_pod = ts/n_seq_base
            t_seq_pod = dt_seq_pod
!
!       ------------------------------------------------------------------------------------------------
!               allocate(greta_lisec1(nelt,2))
!=========================================================================================================
!
                allocate(phi_h(nelt,nbase_h), phi_eta(nelt,nbase_eta), phi_eta_tild(nelt,nbase_eta_tild), phi_hu(nelt,nbase_hu), phi_hv(nelt,nbase_hv), &
                    &        phi_u(nelt,nbase_u), phi_v(nelt,nbase_v), phij_u(nelt,nbase_u), phij_v(nelt,nbase_v), phi_h_zi(nbase_h), phi_h_eta(nbase_eta,nbase_h))
                allocate(Bi_jp(nelt,nbase_eta),Bi_jp_hu(nelt,nbase_hu),Bi_jp_hv(nelt,nbase_hv))         
                allocate(Bijpn1_eta(nelt,nbase_hu), Bijpn2_eta(nelt,nbase_hv))
                allocate(Bijpn3_hu(nelt,nbase_eta), Bijpn3_hv(nelt,nbase_eta))
!
                allocate(Cg2(nbase_hu,nbase_h,nbase_eta), Cg3(nbase_hv,nbase_h,nbase_eta), Cg2_eta_tild(nbase_hu,nbase_h), Cg3_eta_tild(nbase_hv,nbase_h))
                allocate(Chuu2(nbase_hu,nbase_u,nbase_hu), Chuv2(nbase_hu,nbase_u,nbase_hv), Chuv3(nbase_hv,nbase_v,nbase_hu), Chvv3(nbase_hv,nbase_v,nbase_hv))
                allocate(Bijpn_uhu(nelt,nbase_u,nbase_hu), Bijpn_uhv(nelt,nbase_u,nbase_hv), Bijpn_vhu(nelt,nbase_v,nbase_hu), Bijpn_vhv(nelt,nbase_v,nbase_hv))
                allocate(MSfxu(nbase_hu,nbase_u,nbase_u), MSfxv(nbase_hu,nbase_u,nbase_v), MSfyv(nbase_hv,nbase_v,nbase_v), MSfyu(nbase_hv,nbase_v,nbase_u))
!
                allocate(a_eta(nbase_eta),a0_eta(nbase_eta),a01_eta(nbase_eta),resred_eta(nbase_eta), MQk_eta(nbase_eta), Mcl_out_eta(nbase_eta))
                allocate(a_hu (nbase_hu) ,a0_hu (nbase_hu), a01_hu (nbase_hu), resred_hu (nbase_hu), MQk_hu(nbase_hu), Mcl_out_hu(nbase_hu))
                allocate(a_hv (nbase_hv), a0_hv (nbase_hv), a01_hv (nbase_hv), resred_hv (nbase_hv), MQk_hv(nbase_hv), Mcl_out_hv(nbase_hv))
                allocate(a_h(nbase_h), a_u(nbase_u), a_v(nbase_v))
!
                allocate(Mpk1_hu(nbase_eta,nbase_hu), Mpk1_hv(nbase_eta,nbase_hv), hgn1(nbase_hu,nbase_eta), hgn2(nbase_hv,nbase_eta))
                allocate(un1(nbase_hu,nbase_hu),un2(nbase_hu,nbase_hv), vn1(nbase_hv,nbase_hu), vn2(nbase_hv,nbase_hv))
                allocate(Mpk_deta(nbase_eta,nbase_eta),Mpk_dhu(nbase_hu,nbase_hu),Mpk_dhv(nbase_hv,nbase_hv))  
                allocate(Mpk_u(nbase_u,nbase_hu), Mpk_v(nbase_v,nbase_hv))
                allocate(Sfxu(nbase_hu,nbase_u), Sfxv(nbase_hu,nbase_v), Sfyv(nbase_hv,nbase_v), Sfyu(nbase_hv,nbase_u))
!
                allocate(hun1(nbase_eta), hvn2(nbase_eta), deta(nbase_eta), hgHn1(nbase_hu), hgHn2(nbase_hv))
                allocate(huun1(nbase_hu), huun2(nbase_hu), huvn1(nbase_hv), hvvn2(nbase_hv), dhu(nbase_hu), dhv(nbase_hv))
                allocate(Sfx1(nbase_hu), Sfx2(nbase_hu), Sfy1(nbase_hv), Sfy2(nbase_hv))
!
                allocate(vectpod(nbase_hu,6))
                allocate(Bzmij(nelt), BQi_eta(nelt), BQi_hu(nelt), BQi_hv(nelt))
                allocate(huun1full(nelt), huun2full(nelt), huvn1full(nelt), hvvn2full(nelt), podlamdafull(nelt), sourcfric_hu(nelt), sourcfric_hv(nelt))
!       
                allocate(zero_pod(nbase_eta), pod_friction_hu(nbase_hu), pod_friction_hv(nbase_hv))
                zero_pod = 0.0
!
!=======================================================================================================================================================
!
!
                print*, "Lecture des bases modales pour le POD"
!
                call lecture_fichier_matlab(391, nelt, nbase_h, phi_h)
                call lecture_fichier_matlab(392, nelt, nbase_eta, phi_eta)
                call lecture_fichier_matlab(397, nelt, nbase_eta_tild, phi_eta_tild)
                call lecture_fichier_matlab(393, nelt, nbase_hu,  phi_hu)
                call lecture_fichier_matlab(395, nelt, nbase_u,   phi_u)
                if(dim == 2) then
                    call lecture_fichier_matlab(394, nelt, nbase_hv,  phi_hv)
                    call lecture_fichier_matlab(396, nelt, nbase_v, phi_v)
                else
                    phi_hv = zero
                    phi_v = zero
                endif           
!
!                  ------------------------------------------------------------------------------------------------
!
!============================== Traitement de lamda POD ============================================================================
!
                if(uselamdapodmoymax==1 .or. uselamdapodmoymax==2) then
                allocate(podlamdamoy(nelt), podlamdamax(nelt), h_pod_elt(nelt), coef_fric_pod_elt(nelt))
                open(unit=402,file=lamda_moy_num,status="old")
                open(unit=403,file=lamda_max_num,status="old")
                open(unit=404,file=h_pod_num,status="old")
                if (friction > 0.0) open(unit=405,file=fric_pod_num,status="old")
                    do i=1,nelt
                        read(402,*) podlamdamoy(i)  
                        read(403,*) podlamdamax(i)
                        read(404,*) h_pod_elt(i)
                        if (friction > 0.0) read(405,*) coef_fric_pod_elt(i)
                    enddo   
                close(402)
                close(403)
                close(404)
                close(405)
                else
                    write(*,*) 'uselamdapodmoymax (pour la vitesse d onde en POD) non convenable'
                endif
!
!====================================================================================================================================  
!
!=========================================================================================================
! *** detection des noeuds 'nodjauges' les plus proches des jauges ***
!
    if ( nbrjauges > 0 ) then
        do j=1,nbrjauges
            distjaugm1 = 100 * distcote
            do i=1,nnt
                distjaug = sqrt( ( xjauges(j) - coordonnees(i,1) )**2 + ( yjauges(j) - coordonnees(i,2) )**2 )
                if ( distjaug < distjaugm1 ) then
                    nodjauges(j) = i
                    distjaugm1 = distjaug
                endif
            enddo
        enddo
    endif
!
! *** debut stokage solution pour les gauges ***
!
    if ( nbrjauges > 0 .and. nodjauges(1) >  0) then
        write(njaug,'(i2)') nbrjauges

        solfilej_eta = genrtest // 'POD-PID ' // njaug // 'gauges' // '_eta' // '.txt'
        solfilej_h = genrtest // 'POD-PID ' // njaug // 'gauges' // '_h' // '.txt'
        solfilej_u = genrtest // 'POD-PID ' // njaug // 'gauges' // '_u' // '.txt'
        solfilej_v = genrtest // 'POD-PID ' // njaug // 'gauges' // '_v' // '.txt'

        open(unit=ec_solj_eta,file=solfilej_eta,status="unknown")
        open(unit=ec_solj_h,file=solfilej_h,status="unknown")
        open(unit=ec_solj_u,file=solfilej_u,status="unknown")
        open(unit=ec_solj_v,file=solfilej_v,status="unknown")

        if ( nbrjauges <= 30 ) then
            write(ec_solj_eta,'(f8.3,30f14.6)') 0.0 , (sh0(nodjauges(j)), j=1,nbrjauges)
            write(ec_solj_h,'(f8.3,30f14.6)') 0.0 ,   (she0(nodjauges(j)),j=1,nbrjauges)
            write(ec_solj_u,'(f8.3,30f14.6)') 0.0 ,   (su0(nodjauges(j)), j=1,nbrjauges)
            write(ec_solj_v,'(f8.3,30f14.6)') 0.0 ,   (sv0(nodjauges(j)), j=1,nbrjauges)
        else
            write(*,*) '*** Attention : nombre de jauges > 30 ***'
        endif
    endif
!
!*******************    INITIALISATION des a    *************************************************************************************   
                a0_eta    = zero
                a_eta     = zero
                a0_hu     = zero
                a_hu      = zero
                a0_hv     = zero
                a_hv      = zero
                a_u       = zero
                a_v       = zero
        ! 
                do ii=1,maxdimbase          
                    do iel=1,nelt
                        if(ii <= nbase_eta)                a0_eta(ii) = a0_eta(ii) + (vdlg01(iel,1)-h_aval) * phi_eta_tild(iel,ii)
!                       if(ii <= nbase_eta)                a0_eta(ii) = a0_eta(ii) + (vdlg01(iel,1)-h_aval) * phi_eta(iel,ii)
                        if(ii <= nbase_hu)                 a0_hu(ii)  = a0_hu(ii)  + vdlg01(iel,2) * phi_hu(iel,ii)
                        if(ii <= nbase_hv .and. dim==2) a0_hv(ii)  = a0_hv(ii)  + vdlg01(iel,3) * phi_hv(iel,ii)
                        if(ii <= nbase_h)                  a_h(ii) = a_h(ii)
                    enddo                   
                enddo
!
        ! Utilisation d'un h moyen
                do ii=1,nbase_u
                    do kk=1,nbase_hu
                        a_u  (ii)  = a_u  (ii)  + Mpk_u(ii,kk) * a0_hu(kk)
                    enddo
                enddo
                if(dim==2) then
                    do ii=1,nbase_v
                        do kk=1,nbase_hv
                            a_v  (ii)  = a_v  (ii)  + Mpk_v(ii,kk) * a0_hv(kk)
                        enddo
                    enddo
                endif
!
!***************************************************************************************************************************
!****************   Vérificaton de la solution initiale par la base  ********************************************************
!               call prod_Mpk_vect(nelt,nbase_eta, phi_eta, a0_eta, vdlg01(:,1))
!               call prod_Mpk_vect(nelt,nbase_eta, phi_hu,  a0_hu,  vdlg01(:,2))
!               call prod_Mpk_vect(nelt,nbase_eta, phi_hv,  a0_hv,  vdlg01(:,3)         
!***************************************************************************************
!
!*******************    FIN INITIALISATION des a    **************************************************************************************
!

!==========================================================================================
        call cpu_time(ti)

!==========================================================================================     
!
!  ==================================================================================================================================
        do while ( (tc - ts + 2*tol ) < tol )
!
            nt = nt + 1
!
            tcm = tc / 60   ! *** temps en minutes ***
!
                print*, 'sequence pod en cours = ', i_seq_pod               
!
! ************************************ Calcul des Matrices constantes pour le POD ***************************************************
!               Print*,"Calcul des matrices constantes pour POD"
!               call matrice_POD(ns,zm,surf) 
            do ib = 1 , nbase_eta
                read(2001,'(30f14.6)') (Mpk1_hu(ib,jb),jb=1,nbase_hu)
                read(2002,'(30f14.6)') (Mpk1_hv(ib,jb),jb=1,nbase_hv)
                read(2003,'(30f14.6)') (Mpk_deta(ib,jb),jb=1,nbase_eta)             
            enddo
!
            do ib = 1 , nbase_hu 
                read(2004,'(30f14.6)') (Mpk_dhu(ib,jb),jb=1,nbase_hu)
                read(2009,'(30f14.6)') (Sfxu(ib,jb),jb=1,nbase_hu)
                do jb = 1, nbase_eta
                    read(2013,'(30f14.6)') (Cg2(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_u
                    read(2011,'(30f14.6)') (Chuu2(ib,jb,kb),kb=1,nbase_hu)
                enddo
                do jb = 1, nbase_u
                    read(2012,'(30f14.6)') (Chuv2(ib,jb,kb),kb=1,nbase_hv)
                enddo
            enddo
            do ib = 1 , nbase_hv 
                read(2005,'(30f14.6)') (Mpk_dhv(ib,jb),jb=1,nbase_hv)
                read(2010,'(30f14.6)') (Sfxv(ib,jb),jb=1,nbase_hv)
                do jb = 1, nbase_eta
                    read(2016,'(30f14.6)') (Cg3(ib,jb,kb),kb=1,nbase_eta)
                enddo
                do jb = 1, nbase_v
                    read(2014,'(30f14.6)') (Chvv3(ib,jb,kb),kb=1,nbase_hv)
                enddo
                do jb = 1, nbase_v
                    read(2015,'(30f14.6)') (Chuv3(ib,jb,kb),kb=1,nbase_hu)
                enddo
            enddo
            do ib = 1 , nbase_u 
                read(2006,'(30f14.6)') (Mpk_u(ib,jb),jb=1,nbase_hu)
            enddo
            do ib = 1 , nbase_v 
                read(2007,'(30f14.6)') (Mpk_v(ib,jb),jb=1,nbase_hv)
            enddo
            do ib = 1 , nbase_v
                read(2008,'(30f14.6)') phi_h_zi(ib)
            enddo
!
!************************************************************************************************************************************

!********************************************************************************************************************************************************
!         Début de la boucle sur les séquences de bases
!
            do while ( (tc - t_seq_pod + 2*tol ) < tol )

!
!               if (friction > 0.0) then
!                   call pod_source_friction(surf,zm)
!               endif
!
                if (inlet == 'inflow'.and. debitglob > 0.0) call debit_POD(zm,surf)  ! *** flux entrant              
!               if (nelt_sortie > 0.0) call CL_sortie_POD(zm,surf)
!               
!               print*, vol_tot_entre, vol_tot_sorti, vol_tot_entre-vol_tot_sorti
!
!=====================================================================================================================
!========================= Equation de continuité =====================================================================
!                                   
                call prod_Mpk_vect(1,nbase_eta,nbase_hu, Mpk1_hu, a0_hu, hun1)
                call prod_Mpk_vect(1,nbase_eta,nbase_hv, Mpk1_hv, a0_hv, hvn2)
                call prod_Mpk_vect(1,nbase_eta,nbase_eta,Mpk_deta,a0_eta,deta)
!
                if (debitglob > 0.0) then               
                    a_eta  = a0_eta + dt * (- hun1 - hvn2 - MQk_eta + alfa*fact_lamda_pod_tild*deta)
                else
                    a_eta  = a0_eta + dt * (- hun1 - hvn2  + alfa*fact_lamda_pod_tild*deta)
                endif
!
!               call prod_Mpk_vect(2,nbase_eta, nbase_h, phi_h_eta, a0_eta, a_h)
                call prod_Mpk_vect(2,nbase_eta, nbase_h, phi_eta_tild, a0_eta, a_h)
!
!========================= Equation de la quantité de mouvement (hu) =====================================================================================================
!           
                call prod_tenseur_vect(nbase_hu, nbase_u, nbase_hu,  Chuu2, a_u, un1)
                call prod_tenseur_vect(nbase_hu, nbase_u, nbase_hv,  Chuv2, a_u, un2)
!               call prod_tenseur_vect(nbase_hu, nbase_h, nbase_eta, Cg2, a_h - phi_h_zi, hgn1)
                call prod_tenseur_vect(nbase_hu, nbase_h, nbase_eta, Cg2, a_h, hgn1)
!               call prod_tenseur_vect(nbase_hu, nbase_h, nbase_eta, Cg2, phi_h_zi, hgn1)
!       
                call prod_Mpk_vect(1,nbase_hu, nbase_hu, un1, a_hu, huun1)
                call prod_Mpk_vect(1,nbase_hu, nbase_hv, un2, a_hv, huun2)

!               call prod_Mpk_vect(1,nbase_hu, nbase_eta, hgn1, a0_eta, hgHn1)
                call prod_Mpk_vect(1,nbase_hu, nbase_eta, hgn1, a0_eta, hgHn1)
                            
                call prod_Mpk_vect(1,nbase_hu, nbase_hu, Mpk_dhu, a0_hu,   dhu)
                if (manning> 0.0) call prod_Mpk_vect(1,nbase_hu, nbase_u, Sfxu, a_u, Sfx1)
!
                if (debitglob > 0.0  .and. manning> 0.0) then
                    a_hu = a0_hu + dt * (- huun1 - huun2 - hgHn1 - MQk_hu + alfa*fact_lamda_pod*dhu - (manning**2)*Sfx1)
                elseif (debitglob == 0.0  .and. manning> 0.0) then
                    a_hu = a0_hu + dt * (- huun1 - huun2 - hgHn1 + alfa*fact_lamda_pod*dhu - (manning**2)*Sfx1)
                elseif (debitglob > 0.0  .and. manning == 0.0) then
                    a_hu = a0_hu + dt * (- huun1 - huun2 - hgHn1 - MQk_hu + alfa*fact_lamda_pod*dhu)
                else
!                   a_hu = a0_hu + dt * (- huun1 - huun2 - hgHn1 - Mcl_out_hu + alfa*fact_lamda_pod*dhu)
                    a_hu = a0_hu + dt * (- huun1 - huun2 - hgHn1 + alfa*fact_lamda_pod*dhu)

                endif
!
!======================== Equation de la quantité de mouvement (hv) ====================================================================            
!
                if(dim == 2) then
!
                    call prod_tenseur_vect(nbase_hv, nbase_v, nbase_hu,  Chuv3, a_v,    vn1)
                    call prod_tenseur_vect(nbase_hv, nbase_v, nbase_hv,  Chvv3, a_v,    vn2)
!                   call prod_tenseur_vect(nbase_hv, nbase_h, nbase_eta, Cg3, a_h - phi_h_zi, hgn2)
                    call prod_tenseur_vect(nbase_hv, nbase_h, nbase_eta, Cg3, phi_h_zi, hgn2)
!
                    call prod_Mpk_vect(1,nbase_hv, nbase_hu, vn1, a_hu, huvn1)
                    call prod_Mpk_vect(1,nbase_hv, nbase_hv, vn2, a_hv, hvvn2)
                    call prod_Mpk_vect(1,nbase_hv, nbase_eta, hgn2,    a0_eta, hgHn2)
                    call prod_Mpk_vect(1,nbase_hv, nbase_hv, Mpk_dhv, a0_hv,  dhv)
                    if (manning > 0.0) call prod_Mpk_vect(1,nbase_hv, nbase_v, Sfyv, a_v,  Sfy1)
!
                    if (debitglob > 0.0  .and. manning> 0.0) then
                        a_hv = a0_hv + dt * (- huvn1 - hvvn2 - hgHn2 - MQk_hv + alfa*fact_lamda_pod*dhv - (manning**2)*Sfy1)
                    elseif (debitglob == 0.0  .and. manning> 0.0) then
                        a_hv = a0_hv + dt * (- huvn1 - hvvn2 - hgHn2  + alfa*fact_lamda_pod*dhv - (manning**2)*Sfy1)
                    elseif (debitglob > 0.0  .and. manning == 0.0) then
                        a_hv = a0_hv + dt * (- huvn1 - hvvn2 - hgHn2 - MQk_hv  + alfa*fact_lamda_pod*dhv)
                    else
                        a_hv = a0_hv + dt * (- huvn1 - hvvn2 - hgHn2 + alfa*fact_lamda_pod*dhv)
                    endif

                 endif ! de if(dim == 2) then
!   
!*****************  Calcul de la solution à partir de la base reduite   ******************************          
!
!*****************************************************************************************************
                do ii=1,nbase_u
                    a_u  (ii) = 0.d0
                    do i=1,nbase_hu
                        a_u(ii)  = a_u(ii) + Mpk_u(ii,i) * a_hu(i)/fact_h_pod               
                    enddo
                enddo
!
                if(dim == 2)then    
                    do ii=1,nbase_v
                        a_v  (ii) = 0.d0
                        do i=1,nbase_hv
                            a_v(ii) = a_v(ii) + Mpk_v(ii,i) * a_hv(i)/fact_h_pod
                        enddo
                    enddo
                endif
!
!*******    Reinitialisation   ***********************************************************************
                do ii=1,maxdimbase 
                    if (ii <= nbase_eta) a0_eta(ii) = a_eta(ii)
                    if (ii <= nbase_hu)  a0_hu(ii)  = a_hu(ii)
                    if (ii <= nbase_hv .and. dim == 2)   a0_hv(ii) = a_hv(ii)
                enddo
!*******************************************************************************************************
!
                if ( tc < tbase ) dt = dt / divbase
!
                comptvisu = comptvisu + 1
!
! *** mise à jour du temps et de la solution initiale ***
!
                tc = tc + dt
!
!*********************************************************************************************************************
! *** affichage du journal des iterations ***
    !
                if ( mod(nt,freqaffich)==0 ) then 
                    print*, 'nt', nt, '   tc', tc
                endif
!
! *** stockage de la solution en coupes 2D pour les temps du tableau 'tvis2d' 
!     lu dans les donnees de simulation *** 
!
        if (nbrcoupes > 0 ) then
                if ( abs( tc - tvis2d(cptvis2d) ) < tolaffiche) then

    !               do ii=1,maxdimbase 
    !                   write(498,'(3f16.6)') a_eta(ii), a_hu(ii),  a_u(ii)
    !               enddo
    !
                        do iel=1,nelt
                            vdlg1(iel,1) = 0.d0
                            vdlg1(iel,2) = 0.d0
                            vdlg1(iel,3) = 0.d0
                            do ii=1,maxdimbase
                                if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta_tild(iel,ii)
!                               if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta(iel,ii)
                                if (ii <= nbase_hu)  vdlg1(iel,2) = vdlg1(iel,2) + a_hu(ii)  * phi_hu(iel,ii)
                                if (ii <= nbase_hv)  vdlg1(iel,3) = vdlg1(iel,3) + a_hv(ii)  * phi_hv(iel,ii)
                            enddo

                            vdlg1(iel,1) = vdlg1(iel,1) + h_aval
    
                        enddo
    
                        call mise_a_jr_zone_seche(zm,vdlg, vdlg1)
                        call sol_nodes(vdlg,surf,zm,sh0,she0,shu0,shv0,su0,sv0)
    !
                    write(valtemps,'(f12.3)') tc
                    write(debit_tot,'(f8.3)') debitglob
                    write(coef_frot,'(f6.3)') manning
!
                    do j=1,nbrcoupes
!                   write(aaa,'(f6.3)') coupe_a(j)
!                   write(bbb,'(f6.3)') coupe_b(j)
                    write(no_coupe,'(i2)') j
                    if (pod==1) solfile2d = genrtest //'POD-PID'// '2D_' // 'coupe_' // no_coupe // valtemps // 's'// '.txt'
!                       solfile2d = genrtest // 'POD-PID--' //'Q'// debit_tot // ' n'// coef_frot// 't' //valtemps // 's'// '.txt'
                        open(unit=ec_sol2d,file=solfile2d,status="unknown")
                            do i=1,nnt
                                coupe_y = coupe_a(j) * coordonnees(i,1) + coupe_b(j)
                                aux = su0(i)/sh0(i)
                                if (sh0(i)<=tolisec) aux=0.0
                                if ( abs( coordonnees(i,2) - coupe_y ) <= distcote/densite_coupe ) &
                                    write(ec_sol2d,'(5f16.6)') coordonnees(i,1), sh0(i)-she0(i), she0(i), sh0(i), su0(i)
!                                   write(ec_sol2d,'(5f16.6)') coordonnees(i,1), sh0(i)-she0(i), she0(i), sh0(i), aux
!                                   write(ec_sol2d,'(5f16.6)') coordonnees(i,1), sh0(i)-she0(i), she0(i), sh0(i), su0(i)/sh0(i)
                    
                            enddo
!                   
                       close (ec_sol2d)
!
!                        solfile2d = 'Var_POD' // valtemps // 's'// '.txt'
!                        open(unit=ec_sol2d,file=solfile2d,status="unknown")
!                           do ii=1,nbase_hu
!                               write(ec_sol2d,'(3f16.6)') a_eta(ii), dt*(-hun1(ii)-hvn2(ii) + alfa*deta(ii)), dt*(debitglob / long)*MQk_eta(ii)
!                           enddo
!                        close (ec_sol2d)
    !
    !                    Pour recuperation de la solution sur tout le domaine pour fin de calcul des erreurs
    !                    if(soldomaine==1) then
    !                       solfile2d = 'SOL_Dom_POD' // valtemps // 's'// '.txt'
    !                       open(1005,file=solfile2d,status="unknown")
    !                           do i=1,nelt
    !                               write(1005,'(i,3f16.6)') i, vdlg(i,1), vdlg1(i,1), vdlg(i,2)
    !                           enddo
    !                       close(1005)
    !                    endif 
                    enddo
    !
!
    !   *********   Exportation des solutions des éléments sélectionnés dans la prairie ***********
    !
    !               if (test ==7 .and. ncel > 0) then
    !                   open(unit=ec_sol2d,file=solfile2d,status="unknown")
    !                   x0=-1       
    !                   do i=1,nelt
    !                       call res_elem_selct_ligne(i,zm,vdlg)                
    !                   enddo
    !               endif
    !
                    cptvis2d = cptvis2d + 1
    !
                endif   ! de if ( abs( tc - tvis2d(cptvis2d) ) < 1.0E-01) then
!
            endif
    !
! *** stockage de la solution pour les positions des gauges 'xjauges' et 'yjauges'
!     lues dans les donnees de simulation *** 
!
!           if ( mod(nt,freqjauges)==0 .and. nbrjauges > 0 ) then
            if ( abs( tc - tvisjauge(cptvisjauge) ) <= tolaffiche) then
                    if ( nbrjauges > 0 .and. nodjauges(1) >  0) then
                        do iel=1,nelt
                            vdlg1(iel,1) = 0.d0
                            vdlg1(iel,2) = 0.d0
                            vdlg1(iel,3) = 0.d0
                            do ii=1,maxdimbase
                                if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta_tild(iel,ii)
!                               if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta(iel,ii)
                                if (ii <= nbase_hu)  vdlg1(iel,2) = vdlg1(iel,2) + a_hu(ii)  * phi_hu(iel,ii)
                                if (ii <= nbase_hv)  vdlg1(iel,3) = vdlg1(iel,3) + a_hv(ii)  * phi_hv(iel,ii)
                            enddo

                            vdlg1(iel,1) = vdlg1(iel,1) + h_aval
    
                        enddo
    
                        call mise_a_jr_zone_seche(zm,vdlg, vdlg1)
                        call sol_nodes(vdlg,surf,zm,sh0,she0,shu0,shv0,su0,sv0)

                        write(ec_solj_h,'(f8.3,30f14.6)') tc , (she0(nodjauges(j)),j=1,nbrjauges)
                        !write(ec_solj_u,'(f8.3,30f14.6)') tc , ( su0(nodjauges(j)),j=1,nbrjauges)
                    else
                        if ( nbrjauges > 30) write(*,*) '*** Attention : nombre de jauges > 30 ***'
                    endif
!
                cptvisjauge = cptvisjauge + 1
!
            endif
!
!
                if (video ==1) then
    ! *** stockage de la solution 3D pour les temps du tableau 'tvis3d' 
    !               lu dans les donnees de simulation ( a destination de TecPlot ) *** 
    !
                    if ( abs( tc - tvis3d2(cptvis3d) ) <= tolaffiche) then
                            do iel=1,nelt
                                vdlg1(iel,1) = 0.d0
                                vdlg1(iel,2) = 0.d0
                                vdlg1(iel,3) = 0.d0
                                do ii=1,maxdimbase
                                    if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta_tild(iel,ii)
!                                   if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta(iel,ii)
                                    if (ii <= nbase_hu)  vdlg1(iel,2) = vdlg1(iel,2) + a_hu(ii)  * phi_hu(iel,ii)
                                    if (ii <= nbase_hv)  vdlg1(iel,3) = vdlg1(iel,3) + a_hv(ii)  * phi_hv(iel,ii)
                                enddo

                                vdlg1(iel,1) = vdlg1(iel,1) + h_aval

                            enddo
                            call mise_a_jr_zone_seche(zm,vdlg, vdlg1)
                            call sol_nodes(vdlg,surf,zm,sh0,she0,shu0,shv0,su0,sv0)
!                      write(valtemps,'(f12.3)') tc
                            solfile3d = genrtest // '3d' // genrelt // & 
                                        ntrirec // genrmeth // valtemps // 's'// '.txt'
    !jm                     call v_tecplot_nod(solfile3d,she0,sh0,su0,sv0)
    !                       STOCKAGE POUR AFFICHAGE VIDEO
                       if ( ns == 3 ) then
                            write(300,*) 'zone t="pas:',tc, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle', ',D=(feconnect)'
                       else
                            write(300,*) 'zone t="pas:',tc, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=quadrilateral', ',D=(feconnect)'
                       endif
                       do nd=1, nnt
                            write(300,'(7f16.6)') coordonnees(nd,1), coordonnees(nd,2), sh0(nd)-she0(nd), she0(nd), sh0(nd), su0(nd), sv0(nd)
                       enddo
                       write(300,*)' '
                       write(300,*)' '                 
    !
                       if(soldomaine==1) then
                            do i=1,nelt
                                write(1006,'(5f16.6)') tc, vdlg(i,1), vdlg1(i,1), vdlg(i,2), vdlg(i,3)
                            enddo
                       endif 
    !
                       cptvis3d = cptvis3d + 1
    !
                    endif   ! de if ( abs( tc - tvis3d2(cptvis3d) ) <= tolaffiche) then
    !               
                endif   ! de if (video ==1) then
    !

            enddo   !  *** fin de la boucle sur i_seq_pod 
    !
            if(n_seq_base/=1) i_seq_pod = i_seq_pod + 1
            t_seq_pod = t_seq_pod + dt_seq_pod
!
!       ------------------------------------------------------------------------------------------------                                                
            close(391)
            close(392)
            close(393)
            close(394)
            close(395)
            close(396)
            close(397)
            
        if (i_seq_pod <= n_seq_base ) then 
            if (i_seq_pod < 10) then
            write(num_seq_base1,'(i1)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base1// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base1// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base1// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base1// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base1// '.txt'
            base_u_num = 'BASE_u' //num_seq_base1// '.txt'
            base_v_num = 'BASE_v' //num_seq_base1// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base1// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base1// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base1// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base1// '.dat'
            !
        elseif (i_seq_pod >= 10 .and. i_seq_pod < 100) then
            write(num_seq_base2,'(i2)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base2// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base2// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base2// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base2// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base2// '.txt'
            base_u_num = 'BASE_u' //num_seq_base2// '.txt'
            base_v_num = 'BASE_v' //num_seq_base2// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base2// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base2// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base2// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base2// '.dat'
            !
        elseif (i_seq_pod >= 100 .and. i_seq_pod < 1000) then
            write(num_seq_base3,'(i3)') i_seq_pod
            base_h_num = 'BASE_h' //num_seq_base3// '.txt'
            base_eta_num = 'BASE_eta' //num_seq_base3// '.txt'
            base_eta_tild_num = 'BASE_eta_tild' //num_seq_base3// '.txt'
            base_hu_num = 'BASE_hu' //num_seq_base3// '.txt'
            base_hv_num = 'BASE_hv' //num_seq_base3// '.txt'
            base_u_num = 'BASE_u' //num_seq_base3// '.txt'
            base_v_num = 'BASE_v' //num_seq_base3// '.txt'
            lamda_moy_num = 'lamda_moy_POD'//num_seq_base3// '.dat'
            lamda_max_num = 'lamda_max_POD'//num_seq_base3// '.dat'
            h_pod_num = 'h_pod_elem'//num_seq_base3// '.dat' 
            fric_pod_num = 'POD_friction'//num_seq_base3// '.dat'
        else
            print*, 'Nombre de sequences trop eleve'
        endif

!       print*, base_h_num,base_eta_num,base_hu_num,base_hv_num,base_u_num,base_v_num, lamda_moy_num,lamda_max_num,h_pod_num,fric_pod_num
!       pause
                    
            open(unit=391,file=base_h_num,status="old")
            open(unit=392,file=base_eta_num,status="old")
            open(unit=393,file=base_hu_num,status="old")
            open(unit=394,file=base_hv_num,status="old")
            open(unit=395,file=base_u_num,status="old")
            open(unit=396,file=base_v_num,status="old")
            open(unit=397,file=base_eta_tild_num,status="old")
        !
            read (391,*) nbase_h
            read (392,*) n_seq_base  
            read (392,*) nbase_eta
            read (393,*) nbase_hu
            read (394,*) nbase_hv
            read (395,*) nbase_u
            read (396,*) nbase_v
            read (397,*) n_seq_base
            read (397,*) nbase_eta_tild
!
            maxdimbase = max(nbase_h, nbase_eta, nbase_eta_tild, nbase_hu, nbase_hv, nbase_u, nbase_v)
!
!       ------------------------------------------------------------------------------------------------
!               print*, "Lecture des bases modales pour le POD"
!
                call lecture_fichier_matlab(391, nelt, nbase_h, phi_h)
                call lecture_fichier_matlab(392, nelt, nbase_eta, phi_eta)
                call lecture_fichier_matlab(393, nelt, nbase_hu,  phi_hu)
                call lecture_fichier_matlab(395, nelt, nbase_u,   phi_u)
                call lecture_fichier_matlab(397, nelt, nbase_eta_tild, phi_eta_tild)
                if(dim == 2) then
                    call lecture_fichier_matlab(394, nelt, nbase_hv,  phi_hv)
                    call lecture_fichier_matlab(396, nelt, nbase_v, phi_v)
                else
                    phi_hv = zero
                    phi_v = zero
                endif
!      ---------------------------- Traitement de lamda POD --------------------------------------------
!               
                if(uselamdapodmoymax==1 .or. uselamdapodmoymax==2) then
                open(unit=402,file=lamda_moy_num,status="old")
                open(unit=403,file=lamda_max_num,status="old")
                open(unit=404,file=h_pod_num,status="old")
                if (friction > 0.0) open(unit=405,file=fric_pod_num,status="old")
                    do i=1,nelt
                        read(402,*) podlamdamoy(i)  
                        read(403,*) podlamdamax(i)
                        read(404,*) h_pod_elt(i)
                        if (friction > 0.0) read(405,*) coef_fric_pod_elt(i)
                    enddo   
                close(402)
                close(403)
                close(404)
                close(405)
                else
                    write(*,*) 'uselamdapodmoymax (pour la vitesse d onde en POD) non convenable'
                endif
!      ---------------------------- FIN Traitement de lamda POD !      ----------------------------------
                 
            endif ! de if (i_seq_pod <= n_seq_base ) then        
!
        enddo      ! *** fin de la boucle sur le temps ***
!
! =============================================================================================================
! ========================= CALCUL DE LA SOLUTION FINALE ======================================================
!
        do iel=1,nelt
            vdlg1(iel,1) = 0.d0
            vdlg1(iel,2) = 0.d0
            vdlg1(iel,3) = 0.d0
            do ii=1,maxdimbase
                if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta_tild(iel,ii)
!               if (ii <= nbase_eta) vdlg1(iel,1) = vdlg1(iel,1) + a_eta(ii) * phi_eta(iel,ii)
                if (ii <= nbase_hu)  vdlg1(iel,2) = vdlg1(iel,2) + a_hu(ii)  * phi_hu(iel,ii)
                if (ii <= nbase_hv)  vdlg1(iel,3) = vdlg1(iel,3) + a_hv(ii)  * phi_hv(iel,ii)
            enddo
            vdlg1(iel,1) = vdlg1(iel,1) + h_aval
        enddo
!
        call mise_a_jr_zone_seche(zm,vdlg, vdlg1)
        call sol_nodes(vdlg,surf,zm,sh0,she0,shu0,shv0,su0,sv0)
!

! ======  STOCKAGE DE LA SOLUTION POUR TRAITEMENT PAR MONTE CARLO  =============================================
!
        if (multi_simul ==1) then
!
            if (monte_carlo == 0) then
                do i=1,nnt
                    if ( sqrt( ( xjauges(1) - coordonnees(i,1) )**2 + ( yjauges(1) - coordonnees(i,2) )**2 ) < distcote ) nodjauge=i
                enddo
!               write(3000,'(8f8.3)') debitglob, H_AMONT, H_AVAL, manning, vdlg(elts(1),1), vdlg1(elts(1),1), vdlg1(elts(1),2), vdlg1(elts(1),3)
                write(3000,'(6f8.3)') debitglob, H_AMONT, H_AVAL, manning, vdlg(nodjauge,1), vdlg1(nodjauge,1)
! ----------------------------------------------------------------------------------------------------------------------------------------------
            else
!
                if ( abs( tc - TS ) < tolaffiche) then  
!
                    do i=1,nnt
!                       Stockage de la solution finale par scenario le long d'une coupe pour l'analyse statistique -----------------------
                        coupe_y = coupe_a(1) * coordonnees(i,1) + coupe_b(1)
                        aux = su0(i)/sh0(i)
                        if (sh0(i)<=tolisec) aux=0.0
                        if ( abs( coordonnees(i,2) - coupe_y ) <= distcote/densite_coupe  ) &
                                write(3002,'(5f16.6)') coordonnees(i,1), sh0(i)-she0(i), she0(i), sh0(i), su0(i)
!------------------------------------------------------------------------------------------------------------------------------------------
!                       Stockage de la solution finale par scenario dans tout le domaine pour l'analyse statistique ------------------------------------------
                        write(3003,'(i7,7f16.6)') i, coordonnees(i,1), coordonnees(i,2), abs(sh0(i)-she0(i)), she0(i), sh0(i), su0(i), sv0(i)
!                   --------------------------------------------------------------------------------------------------------------------------------------                  
                    enddo
                endif   ! de ( abs( tc - TS ) < tolaffiche) then
            endif ! de (monte_carlo == 0) then
!
        endif ! de (multi_simul ==1) then
!  ================================================================================================================================
 
        close(1006)
        close(2001)
        close(2002)
        close(2003)
        close(2004)
        close(2005)
        close(2006)
        close(2007)
        close(2008)
        close(2009)
        close(2010)
        close(2011)
        close(2012)
        close(2013)
        close(2014)
        close(2015)
        close(2016)
!
        deallocate(phi_h, phi_eta, phi_eta_tild, phi_hu, phi_hv, phi_u, phi_v, phij_u, phij_v, phi_h_zi, phi_h_eta)
        deallocate(Bi_jp,Bi_jp_hu,Bi_jp_hv)         
        deallocate(Bijpn1_eta, Bijpn2_eta)
        deallocate(Bijpn3_hu, Bijpn3_hv)
        deallocate(Cg2, Cg3, Cg2_eta_tild, Cg3_eta_tild)
        deallocate(Chuu2, Chuv2, Chuv3, Chvv3)
        deallocate(Bijpn_uhu, Bijpn_uhv, Bijpn_vhu, Bijpn_vhv)
        deallocate(MSfxu, MSfxv, MSfyv, MSfyu)
        deallocate(a_eta,a0_eta,a01_eta,resred_eta, MQk_eta, Mcl_out_eta)
        deallocate(a_hu, a0_hu, a01_hu, resred_hu, MQk_hu, Mcl_out_hu)
        deallocate(a_hv, a0_hv, a01_hv, resred_hv, MQk_hv, Mcl_out_hv)
        deallocate(a_h, a_u, a_v)
        deallocate(Mpk1_hu, Mpk1_hv, hgn1, hgn2)
        deallocate(un1,un2, vn1, vn2)
        deallocate(Mpk_deta,Mpk_dhu,Mpk_dhv)  
        deallocate(Mpk_u, Mpk_v)
        deallocate(Sfxu, Sfxv, Sfyv, Sfyu)
        deallocate(hun1, hvn2, deta, hgHn1, hgHn2)
        deallocate(huun1, huun2, huvn1, hvvn2, dhu, dhv)
        deallocate(Sfx1, Sfx2, Sfy1, Sfy2)
        deallocate(vectpod)
        deallocate(Bzmij, BQi_eta, BQi_hu, BQi_hv)
        deallocate(huun1full, huun2full, huvn1full, hvvn2full, podlamdafull, sourcfric_hu, sourcfric_hv)
        deallocate(zero_pod, pod_friction_hu, pod_friction_hv)
        deallocate(podlamdamoy, podlamdamax, h_pod_elt, coef_fric_pod_elt)

        call cpu_time(tf)
!****************************************************************************************************
end subroutine POD_PID_ROM