subroutine reconstruction(vdlg, vdlg1, solh, soleta, solhu, solhv)
  use precision_m
  use global
  use m_param

  real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv
  real(fp_kind), dimension(:,:), intent(in)  :: vdlg1, vdlg

  integer :: nd, iel, i
  integer                     :: stat(MPI_STATUS_SIZE)


  !! Echanges mémoire pour récuperere les solutions sur les éléments des domaines
  if(mpi_process_id/=0) then
    call MPI_SEND(vdlg1,3*nelt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(vdlg1_vect(1,1,i), 3*mpi_nelts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)

  if(mpi_process_id/=0) then
    call MPI_SEND(vdlg,3*nelt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(vdlg_vect(1,1,i), 3*mpi_nelts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)

  ! Echanges mémoire pour récuperere les solutions sur les noeuds des domaines
  ! solh, soleta, solhu, solhv,
  if(mpi_process_id/=0) then
    call MPI_SEND(solh,nnt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(sol_nodes_vect(1,1,i), mpi_nnts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)

  if(mpi_process_id/=0) then
    call MPI_SEND(soleta,nnt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(sol_nodes_vect(1,2,i), mpi_nnts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)
  if(mpi_process_id/=0) then
    call MPI_SEND(solhu,nnt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(sol_nodes_vect(1,3,i), mpi_nnts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)
  if(mpi_process_id/=0) then
    call MPI_SEND(solhv,nnt,fp_kind_mpi,0,mpi_process_id,MPI_COMM_WORLD,mpi_ierr)
  else
    do i=2,num_mpi_process
      call MPI_RECV(sol_nodes_vect(1,4,i), mpi_nnts(i), fp_kind_mpi, i-1, i-1, MPI_COMM_WORLD, stat, mpi_ierr)
    end do
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)

  if(mpi_process_id==0)then
    do i=1,nelt
      vdlg1_vect(1,i,1) = vdlg1(1,i)
      vdlg1_vect(2,i,1) = vdlg1(2,i)
      vdlg1_vect(3,i,1) = vdlg1(3,i)

      vdlg_vect(1,i,1) = vdlg(1,i)
      vdlg_vect(2,i,1) = vdlg(2,i)
      vdlg_vect(3,i,1) = vdlg(3,i)
    end do

    do i=1,nnt
      sol_nodes_vect(i,1,1) = soleta(i)
      sol_nodes_vect(i,2,1) = solh(i)
      sol_nodes_vect(i,3,1) = solhu(i)
      sol_nodes_vect(i,4,1) = solhv(i)
    end do

    !!Construction du vecteur solution aux éléments sur le domaine global
    vdlg1_global = -2
    vdlg_global = -2
    do i=1,num_mpi_process
      do iel=1,mpi_nelts_non_fant(i)
        vdlg1_global(1,liens_elems(i,iel)) = vdlg1_vect(1,iel,i)
        vdlg1_global(2,liens_elems(i,iel)) = vdlg1_vect(2,iel,i)
        vdlg1_global(3,liens_elems(i,iel)) = vdlg1_vect(3,iel,i)

        vdlg_global(1,liens_elems(i,iel)) = vdlg_vect(1,iel,i)
        vdlg_global(2,liens_elems(i,iel)) = vdlg_vect(2,iel,i)
        vdlg_global(3,liens_elems(i,iel)) = vdlg_vect(3,iel,i)
      end do
    end do

    !Construction du vecteur solution aux noeuds sur le domaine global
    sol_nodes_global = -2
    do i=1,num_mpi_process
      do iel=1,mpi_nnts(i)
        sol_nodes_global(1,liens_nodes(i,iel)) = sol_nodes_vect(iel,1,i)
        sol_nodes_global(2,liens_nodes(i,iel)) = sol_nodes_vect(iel,2,i)
        sol_nodes_global(3,liens_nodes(i,iel)) = sol_nodes_vect(iel,3,i)
        sol_nodes_global(4,liens_nodes(i,iel)) = sol_nodes_vect(iel,4,i)
      end do
    end do
  end if
end subroutine reconstruction

subroutine lect_liens()
  use precision_m
  use global
  use m_param

  integer :: i,j,dummy
  character(100) :: fileinput, id_string


  do i=1,num_mpi_process
    write(id_string, "(I3)") i-1
    fileinput = trim(adjustl(id_string)) //'_liens_nodes.txt'
    open(unit=11,file=fileinput,form='formatted',status='old')
    j=1
    do
      read(11,*,IOSTAT=io) dummy, liens_nodes(i,j)
      if(io/=0) exit
      j=j+1
    end do
    close(11)

    fileinput = trim(adjustl(id_string)) //'_liens_elems.txt'
    open(unit=11,file=fileinput,form='formatted',status='old')
    j=1
    do
      read(11,*,IOSTAT=io) dummy, liens_elems(i,j)
      if(io/=0) exit
      j=j+1
    end do
    close(11)
  end do

end subroutine lect_liens


attributes(global) subroutine mise_a_jr_zone_seche_cudaf(zm_d,vdlg_d, vdlg1_d)
  !==================================================================
  !     mise_a_jr_zone_seche = met jour les zones seches (update the dry areas)
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  Oct 09 2007
  !==================================================================

  use global_device

  implicit none

  real(fp_kind), dimension(nelt_d), intent(in)         :: zm_d
  real(fp_kind), dimension(ndln_d,nelt_d), intent(inout)    :: vdlg_d, vdlg1_d

  integer       :: ti,gi
  real(fp_kind) :: vdlg_dgi1

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti

  if(gi <= nelt_d) then
    vdlg_dgi1 = vdlg1_d(1,gi) - zm_d(gi)
    vdlg_d(1,gi) = vdlg_dgi1
    vdlg_d(2,gi) = vdlg1_d(2,gi)
    vdlg_d(3,gi) = vdlg1_d(3,gi)

    if (vdlg_dgi1 <= tolisec_d ) then      
      vdlg_d(1,gi)  = tolisec_d
      vdlg_d(2,gi)  = 0.d0
      vdlg_d(3,gi)  = 0.d0

      vdlg1_d(1,gi) = zm_d(gi)+tolisec_d
      vdlg1_d(2,gi) = 0.d0
      vdlg1_d(3,gi) = 0.d0                
    endif
  end if

end subroutine mise_a_jr_zone_seche_cudaf

subroutine sol_nodes(vdlg,surf,zm,soleta,solh,solhu,solhv,solu,solv)
  ! ======================================================================
  !     sol_nodes = calcul de la solution aux noeuds du maillage par
  !                 moyennes ponderees sur les volumes entourants
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:,:), intent(in)   :: vdlg
  real(fp_kind), dimension(:), intent(in)     :: surf, zm
  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv, solu, solv

  real(fp_kind), dimension(:), allocatable :: surfno, zzz

  integer :: kvol, i, no
  allocate(  surfno(nnt), zzz(nnt) )

  surfno = 0.0d0
  soleta  = 0.0d0
  solh   = 0.0d0
  solhu   = 0.0d0
  solhv   = 0.0d0
  solu   = 0.0d0
  solv   = 0.0d0
  zzz    = 0.0d0

  do kvol=1,nelt
    do i=1,ns
      no = connectivite(kvol,i)
      surfno(no) = surfno(no) + surf(kvol)
      zzz(no) = zzz(no) + surf(kvol) * zm(kvol)
      if ( vdlg(1,kvol) > tolisec ) then
        solh(no)   = solh(no)  + surf(kvol) * vdlg(1,kvol)
        soleta(no)    = soleta(no)   + surf(kvol) * ( vdlg(1,kvol) + zm(kvol) )
        solhu(no)    = solhu(no)   + surf(kvol) * vdlg(2,kvol) 
        solhv(no)    = solhv(no)   + surf(kvol) * vdlg(3,kvol)
      else
        soleta(no)    = soleta(no)   + surf(kvol) * ( tolisec + zm(kvol) )
      endif
    enddo
  enddo

  do no=1,nnt
    zzz(no) = zzz(no) / surfno(no)
    solh(no) = solh(no) / surfno(no)
    if ( solh(no) <= tolisec ) then
      solh(no) = tolisec
      soleta(no)  = zzz(no)
      solhu(no)  = 0.
      solhv(no)  = 0.
      solu(no)  = 0.
      solv(no)  = 0.
    else
      soleta(no) = soleta(no) / surfno(no)
      solhu(no)  = solhu(no)  / surfno(no)
      solhv(no)  = solhv(no)  / surfno(no)
      solu(no)   = solhu(no)  / (solh(no)*surfno(no))
      solv(no)   = solhv(no)  / (solh(no)*surfno(no))
    endif
  enddo

  deallocate(surfno, zzz)
end subroutine sol_nodes

subroutine stock_coupe2D(solh, soleta, solhu, solu)

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: solh, soleta, solhu, solu

  character (10) :: no_coupe
  integer :: kvol, i, j, no
  real(fp_kind) :: aux, coupe_x, coupe_y

  write(valtemps,'(f18.3)') tc

  if (start == 1) then                
    do j=1,nbrcoupes
      nbr_nds_coupes(j) = 0
      write(no_coupe,'(i2)') j
      if(num_mpi_process>1) then
        solfile2d = trim(adjustl(mpi_process_id_string)) //'_solution-2D_coupe_' // trim(adjustl(no_coupe))  // "_" // trim(adjustl(valtemps)) // '_s.txt'
      else
        solfile2d = 'solution-2D_coupe_' // trim(adjustl(no_coupe))  // "_" // trim(adjustl(valtemps)) // '_s.txt'
      end if
      open(unit=ec_sol2d,file=solfile2d,status="unknown")
      do i=1,nnt
        coupe_y = coupe_a(j) * coordonnees(i,1) + coupe_b(j)
        if ( abs( coordonnees(i,2) - coupe_y ) <= distcote ) then
          nbr_nds_coupes(j) = nbr_nds_coupes(j) + 1
          nds_coupes(j,nbr_nds_coupes(j)) = i                 
          write(ec_sol2d,'(5f16.6)')  coordonnees(i,1), soleta(i) - solh(i), solh(i), soleta(i), solu(i) 
        endif
      enddo
      close (ec_sol2d)
    enddo

  else
    do j=1,nbrcoupes
      write(no_coupe,'(i2)') j            !
      if(num_mpi_process>1) then
        solfile2d = trim(adjustl(mpi_process_id_string)) //'_solution-2D_coupe_' // trim(adjustl(no_coupe)) // "_" // trim(adjustl(valtemps)) // '_s.txt'
      else
        solfile2d = 'solution-2D_coupe_' // trim(adjustl(no_coupe)) // "_" // trim(adjustl(valtemps)) // '_s.txt'
      end if
      open(unit=ec_sol2d,file=solfile2d,status="unknown")
      if(nbr_nds_coupes(j) > 0) then
        do i=1,nbr_nds_coupes(j)
          no = nds_coupes(j,i)
          write(ec_sol2d,'(5f16.6)') coordonnees(no,1), soleta(no) - solh(no), solh(no), soleta(no), solu(no)     
        enddo
      endif
      close (ec_sol2d)
    enddo       ! de do j=1,nbrcoupes
    close (ec_sol2d)
  endif
end subroutine stock_coupe2D

subroutine ouv_fichiers(vdlg, vdlg1, zm)

  use precision_m
  use global_device
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(in)         :: zm
  real(fp_kind), dimension(:,:), intent(inout)    :: vdlg, vdlg1

  integer                 :: i

  open(unit=ec_bilan_sim,file='RAPPORT_SIMULATION.txt',status="unknown")
  if(num_mpi_process>1) then
    sol_elt_ts = trim(adjustl(mpi_process_id_string))    // trim(adjustl('_solution_elements_restart.txt'))
    sol_nd_ts = trim(adjustl(mpi_process_id_string))     // trim(adjustl('_solution_noeuds.txt'))
    sol_elt_ts_recons = trim(adjustl('solution_elements_restart.txt'))
    sol_nd_ts_recons = trim(adjustl('solution_noeuds.txt'))
  else
    sol_elt_ts = trim(adjustl('solution_elements_restart.txt'))
    sol_nd_ts = trim(adjustl('solution_noeuds.txt'))
  end if

  if(solrestart==1) then
    open(ec_sol_elt_t, file=sol_elt_ts, status="unknown")
    open(ec_sol_nd_t,  file=sol_nd_ts,  status="unknown")
  endif

  if(merged_solution==1) then
    open(ec_sol_elt_t_recons, file=sol_elt_ts_recons, status="unknown")
    open(ec_sol_nd_t_recons,  file=sol_nd_ts_recons,  status="unknown")
  endif

  !! Eriture de nombre total d elements en chaine de caracteres dans ntrirec
  write(ntrirec,'(i6)') nelt 

  select case (iflux)
  case (1)
    nom_methode = 'HLLC_ZOKA'
  case (2)
    nom_methode = 'HLLC_RIADH'
  case default
    print *,'donnee iflux non acceptable' 
  end select

  !! Cas d'un test avec loi de debit (table) Case of a test with debit law (table)
  if(debit_var==1) then
    open(unit=11,file=loi_debitglob,form='formatted',status='old')
    read(11,*) n_Q
    allocate(debit_t(n_Q,2))
    do i=1,n_Q
      read(11,*) debit_t(i,1) , debit_t(i,2)
    enddo
    close(11)
    cptdebit = 2
    cptdebit_d = cptdebit
    debitglob(1) = debit_t(cptdebit-1,2)
    debitglob_d = debitglob
    debitglob_sum = sum(debitglob)
  endif

  !! Ouverture du fichier de stockage des solutions 2D  (Opening the 2D solution storage file)
  write(valtemps,'(f12.3)') TS
  if(num_mpi_process>1) then
    solfile2d_MC = trim(adjustl(mpi_process_id_string)) // '_solutin-Q' // trim(adjustl(debit_tot)) // '_n_'// trim(adjustl(coef_frot))// '_t_' // trim(adjustl(valtemps)) // '_s'// '.txt'
  else
    solfile2d_MC = 'solution-Q' // trim(adjustl(debit_tot)) // '_n_'// trim(adjustl(coef_frot))// '_t_' // trim(adjustl(valtemps)) // '_s'// '.txt'
  end if
  if (monte_carlo==1 ) then
    if(num_mpi_process>1) then
      solfile2d_MC = trim(adjustl(mpi_process_id_string)) // '_SOL_FV_MULTISIM_2D.txt'
      solfile3d_MC = trim(adjustl(mpi_process_id_string)) // '_SOL_FV_MULTISIM_3D.txt'
    else
      solfile2d_MC = 'SOL_FV_MULTISIM_2D.txt'
      solfile3d_MC = 'SOL_FV_MULTISIM_3D.txt'
    end if
    open(unit=3002,file=solfile2d_MC,status="unknown")
    open(unit=3003,file=solfile3d_MC,status="unknown")
  endif

  if (nbrcoupes>1) then
    if(num_mpi_process>1) then
      file_Q_coupes = trim(adjustl(mpi_process_id_string)) // '_solution-debit_coupes.txt'
    else
      file_Q_coupes = 'solution-debit_coupes.txt'
    end if
    open(unit=ec_Q_coupes,file=file_Q_coupes,status="unknown")
  endif

end subroutine ouv_fichiers

subroutine bluekenue_export(solh, soleta, solhu, solhv)
  ! =================================================================================
  !     bluekenue_export == Exporte dans un fichier pour postraitement avec Bluekenue
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  mai 31 2010
  ! =================================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

  integer :: nd, iel
  real(fp_kind) :: solu, solv

  write(valtemps,'(f12.3)') tc 
  if(num_mpi_process>1) then
    solfile_eta_T3S = trim(adjustl(mpi_process_id_string)) // '_solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_h_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_u_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_v_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
  else
    solfile_eta_T3S = 'solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_h_T3S   = 'solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_u_T3S   = 'solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    solfile_v_T3S   = 'solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
  end if

  open(unit=ec_Bluekenu_eta,file=solfile_ETA_T3S,status="unknown")
  open(unit=ec_Bluekenu_h,file=solfile_H_T3S,    status="unknown")
  open(unit=ec_Bluekenu_u,file=solfile_U_T3S,    status="unknown")
  open(unit=ec_Bluekenu_v,file=solfile_V_T3S,    status="unknown")

  write(ec_Bluekenu_eta,*) ':NodeCount', nnt
  write(ec_Bluekenu_eta,*) ':ElementCount', nelt
  write(ec_Bluekenu_eta,*) ':ElementType  T3'
  write(ec_Bluekenu_eta,*) ':EndHeader'

  write(ec_Bluekenu_h,*) ':NodeCount', nnt
  write(ec_Bluekenu_h,*) ':ElementCount', nelt
  write(ec_Bluekenu_h,*) ':ElementType  T3'
  write(ec_Bluekenu_h,*) ':EndHeader'

  write(ec_Bluekenu_u,*) ':NodeCount', nnt
  write(ec_Bluekenu_u,*) ':ElementCount', nelt
  write(ec_Bluekenu_u,*) ':ElementType  T3'
  write(ec_Bluekenu_u,*) ':EndHeader'

  write(ec_Bluekenu_v,*) ':NodeCount', nnt
  write(ec_Bluekenu_v,*) ':ElementCount', nelt
  write(ec_Bluekenu_v,*) ':ElementType  T3'
  write(ec_Bluekenu_v,*) ':EndHeader'

  do nd=1, nnt
    if ( solh(nd) > tolisec ) then
      solu = solhu(nd)/solh(nd)
      solv = solhv(nd)/solh(nd)
    else
      solu = 0.d0
      solv = 0.d0
    endif
    write(ec_Bluekenu_eta,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)-sol_z_offset
    write(ec_Bluekenu_h,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solh(nd)
    write(ec_Bluekenu_u,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solu
    write(ec_Bluekenu_v,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solv
  enddo
  do iel=1, nelt
    write(ec_Bluekenu_eta,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_h,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_u,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_v,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
  enddo

  close(ec_Bluekenu_eta)
  close(ec_Bluekenu_h)
  close(ec_Bluekenu_u)
  close(ec_Bluekenu_v)

end subroutine bluekenue_export

subroutine simple_export(vdlg, vdlg1, solh, soleta, solhu, solhv, ci)

  use precision_m
  use global
  use m_param

  implicit none

  integer, intent(in) :: ci
  real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv
  real(fp_kind), dimension(:,:), intent(in)  :: vdlg1, vdlg

  integer :: nd, iel, i
  integer                     :: stat(MPI_STATUS_SIZE)

  if(ci==-1) then
    write(valtemps,*) "Final"
  else
    write(valtemps,'(I20)') ci
  end if

  if(solsimple==1 .or. solsimple==3) then 
    if(num_mpi_process>1) then
      solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    else
      solfile_simple = 'solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    end if
    open(unit=ec_sol_simple_nd,file=solfile_simple,status="unknown")
    write(ec_sol_simple_nd,*) tc                        
    do nd=1,nnt
      write(ec_sol_simple_nd,'(4f16.6)') solh(nd), soleta(nd)-sol_z_offset, solhu(nd), solhv(nd)
    end do
    close(ec_sol_simple_nd)
  end if

  if(solsimple==2 .or. solsimple==3) then 
    if(num_mpi_process>1) then
      solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    else
      solfile_simple = 'solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    end if
    open(unit=ec_sol_simple_elt,file=solfile_simple,status="unknown")
    write(ec_sol_simple_elt,*) tc                        
    do iel=1,nelt
      write(ec_sol_simple_elt,'(4f16.6)') vdlg(1,iel), vdlg1(1,iel)-sol_z_offset, vdlg1(2,iel), vdlg1(3,iel)
    end do
    close(ec_sol_simple_elt)
  end if


  !!Reception des solutions des autres process MPI
  if(merged_solution==1 .and. num_mpi_process>1 .and. mpi_process_id==0)then
    if(solsimple==1 .or. solsimple==3) then 
      solfile_simple = 'solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      open(unit=ec_sol_simple_nd,file=solfile_simple,status="unknown")
      i=1
      do while(sol_nodes_global(1,i)>-1 .and. i<=nnt_global)
        write(ec_sol_simple_nd,'(4f16.6)') sol_nodes_global(1,i), sol_nodes_global(2,i)-sol_z_offset, sol_nodes_global(3,i), sol_nodes_global(4,i)
        i=i+1
      end do
      close(ec_sol_simple_nd)
    end if

    if(solsimple==2 .or. solsimple==3) then 
      solfile_simple = 'solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      open(unit=ec_sol_simple_elt,file=solfile_simple,status="unknown")
      do iel=1,nelt_global_non_fant
        write(ec_sol_simple_elt,'(4f16.6)') vdlg_global(1,iel), vdlg1_global(1,iel)-sol_z_offset, vdlg1_global(2,iel), vdlg1_global(3,iel)
      end do
      close(ec_sol_simple_elt)
    end if
  end if
  call MPI_BARRIER(MPI_COMM_WORLD,mpi_ierr)
end subroutine simple_export

subroutine paraview_export(solh, soleta, solhu, solhv, ci)
  ! ==============================================================================
  !     paraview_export == Exporte dans un fichier vtk pour postraitement avec paraview
  !     auteur : Delmas Vincent
  !     version : 2.0  ;  july 31 2019
  ! ==============================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv

  integer :: nd, iel, ci
  real(fp_kind) :: solu, solv

  if(ci==-1) then
    write(valtemps,*) "Final"
  else
    write(valtemps,'(I20)') ci
  end if

  solfile_para = trim(adjustl(trim(mpi_process_id_string)))//'_solution-Paraview_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.vtk'))

  open(unit=ec_Paraview,file=solfile_para,status="unknown")

  write(ec_Paraview,'(a)') "# vtk DataFile Version 1.0"
  write(ec_Paraview,'(a)') "2D Unstructured Grid"
  write(ec_Paraview,'(a)') "ASCII"
  write(ec_Paraview,'(a)') ""

  write(ec_Paraview,'(a)') "DATASET UNSTRUCTURED_GRID"
  write(ec_Paraview,'(a,I10,a)') "POINTS", nnt, " float"

  do nd=1, nnt
    write(ec_Paraview,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), 0.
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10,I10)') "CELLS", nelt, 4*nelt
  do iel=1, nelt
    write(ec_Paraview,'(I1,3I10)') 3, connectivite(iel,1)-1, connectivite(iel,2)-1, connectivite(iel,3)-1
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10)') "CELL_TYPES", nelt
  do iel=1, nelt
    write(ec_Paraview,'(a)') "5"
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10)') "POINT_DATA", nnt
  write(ec_Paraview,'(a)') "SCALARS eta float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') soleta(nd)-sol_z_offset
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "SCALARS h float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') solh(nd)
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "SCALARS b float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') soleta(nd)-solh(nd)-sol_z_offset
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "VECTORS velocity float"
  do nd=1, nnt
    if ( solh(nd) > tolisec ) then
      solu = solhu(nd)/solh(nd)
      solv = solhv(nd)/solh(nd)
    else
      solu = 0.d0
      solv = 0.d0
    endif
    write(ec_Paraview,'(3f16.6)')   solu, solv, 0.
  end do

  close(ec_Paraview)

end subroutine paraview_export

subroutine tecplot_export(solh, soleta, solhu, solhv)
  ! ============================================================================
  !     tecplot_export == Export to a text file the solutions for postraitement with Tecplot
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  mai 13 2018
  ! ============================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

  integer :: nd, i
  real(fp_kind) :: solu, solv

  if ( start == 1 ) then

    tecplot   =  trim(adjustl(mpi_process_id_string))//'_solution-Tecplot.dat'

    open(unit=ec_tecplot,file=tecplot,status="unknown")

    write(ec_tecplot,*) 'title = "hauteur"'
    write(ec_tecplot,*) 'variables = "x","y","z","h","eta","u","v", "manning"'
    write(ec_tecplot,*) 'zone t="pas:',valtemps, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle'

    do nd=1, nnt
      write(ec_tecplot,'(8f16.6)') coordonnees(nd,1),coordonnees(nd,2),coordonnees(nd,3),solh(nd),soleta(nd),solhu(nd),solhv(nd),manning_nd(nd)
    enddo

    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '

    do i=1, nelt
      write(ec_tecplot,*) connectivite(i,1) , connectivite(i,2) , connectivite(i,3)
    enddo

    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '

  else
    write(ec_tecplot,*) 'zone t="pas:',tc, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle', ',D=(feconnect)'
    do nd=1, nnt
      write(ec_tecplot,'(8f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)-solh(nd), solh(nd), soleta(nd), solhu(nd), solhv(nd), manning_nd(nd)
    enddo
    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '
  endif
end subroutine tecplot_export
