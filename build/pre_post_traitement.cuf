attributes(global) subroutine mise_a_jr_zone_seche_cudaf(zm_d,vdlg_d, vdlg1_d)
  !==================================================================
  !     mise_a_jr_zone_seche = met jour les zones seches (update the dry areas)
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  Oct 09 2007
  !==================================================================

  use global_device

  implicit none

  real(fp_kind), dimension(:), intent(in)         :: zm_d
  real(fp_kind), dimension(:,:), intent(inout)    :: vdlg_d, vdlg1_d

  integer       :: ti,gi
  real(fp_kind) :: vdlg_dgi1

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti

  if(gi <= nelt_d) then
    vdlg_dgi1 = vdlg1_d(1,gi) - zm_d(gi)
    vdlg_d(1,gi) = vdlg_dgi1
    vdlg_d(2,gi) = vdlg1_d(2,gi)
    vdlg_d(3,gi) = vdlg1_d(3,gi)

    if (vdlg_dgi1 <= tolisec_d ) then      
      vdlg_d(1,gi)  = tolisec_d
      vdlg_d(2,gi)  = 0.d0
      vdlg_d(3,gi)  = 0.d0

      vdlg1_d(1,gi) = zm_d(gi)                  
      vdlg1_d(2,gi) = 0.d0
      vdlg1_d(3,gi) = 0.d0                
    endif
  end if

end subroutine mise_a_jr_zone_seche_cudaf

subroutine sol_nodes(vdlg,surf,zm,soleta,solh,solhu,solhv,solu,solv)
  ! ======================================================================
  !     sol_nodes = calcul de la solution aux noeuds du maillage par
  !                 moyennes ponderees sur les volumes entourants
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:,:), intent(in)   :: vdlg
  real(fp_kind), dimension(:), intent(in)     :: surf, zm
  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv, solu, solv

  real(fp_kind), dimension(:), allocatable :: surfno, zzz

  integer :: kvol, i, no
  allocate(  surfno(nnt), zzz(nnt) )

  surfno = 0.0d0
  soleta  = 0.0d0
  solh   = 0.0d0
  solhu   = 0.0d0
  solhv   = 0.0d0
  solu   = 0.0d0
  solv   = 0.0d0
  zzz    = 0.0d0

  do kvol=1,nelt
    do i=1,ns
      no = connectivite(kvol,i)
      surfno(no) = surfno(no) + surf(kvol)
      zzz(no) = zzz(no) + surf(kvol) * zm(kvol)
      if ( vdlg(1,kvol) > tolisec ) then
        solh(no)   = solh(no)  + surf(kvol) * vdlg(1,kvol)
        soleta(no)    = soleta(no)   + surf(kvol) * ( vdlg(1,kvol) + zm(kvol) )
        solhu(no)    = solhu(no)   + surf(kvol) * vdlg(2,kvol) 
        solhv(no)    = solhv(no)   + surf(kvol) * vdlg(3,kvol)
      else
        soleta(no)    = soleta(no)   + surf(kvol) * ( tolisec + zm(kvol) )
      endif
    enddo
  enddo

  do no=1,nnt
    zzz(no) = zzz(no) / surfno(no)
    solh(no) = solh(no) / surfno(no)
    if ( solh(no) <= tolisec ) then
      solh(no) = tolisec
      soleta(no)  = zzz(no)
      solhu(no)  = 0.
      solhv(no)  = 0.
      solu(no)  = 0.
      solv(no)  = 0.
    else
      soleta(no) = soleta(no) / surfno(no)
      solhu(no)  = solhu(no)  / surfno(no)
      solhv(no)  = solhv(no)  / surfno(no)
      solu(no)   = solhu(no)  / (solh(no)*surfno(no))
      solv(no)   = solhv(no)  / (solh(no)*surfno(no))
    endif
  enddo

  deallocate(surfno, zzz)
end subroutine sol_nodes

subroutine stock_coupe2D(solh, soleta, solhu, solu)

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: solh, soleta, solhu, solu

  character (10) :: no_coupe
  integer :: kvol, i, j, no
  real(fp_kind) :: aux, coupe_x, coupe_y

  write(valtemps,'(f18.3)') tc

  if (start == 1) then                
    do j=1,nbrcoupes
      nbr_nds_coupes(j) = 0
      write(no_coupe,'(i2)') j
      solfile2d = trim(adjustl(mpi_process_id_string)) //'_FV-2D_coupe_' // trim(adjustl(no_coupe))  // "_" // trim(adjustl(valtemps)) // '_s.txt'
      open(unit=ec_sol2d,file=solfile2d,status="unknown")
      do i=1,nnt
        coupe_y = coupe_a(j) * coordonnees(i,1) + coupe_b(j)
        if ( abs( coordonnees(i,2) - coupe_y ) <= distcote ) then
          nbr_nds_coupes(j) = nbr_nds_coupes(j) + 1
          nds_coupes(j,nbr_nds_coupes(j)) = i                 
          write(ec_sol2d,'(5f16.6)')  coordonnees(i,1), soleta(i) - solh(i), solh(i), soleta(i), solu(i) 
        endif
      enddo
      close (ec_sol2d)
    enddo

  else
    do j=1,nbrcoupes
      write(no_coupe,'(i2)') j            !
      solfile2d = trim(adjustl(mpi_process_id_string)) //'_FV-2D_coupe_' // trim(adjustl(no_coupe)) // "_" // trim(adjustl(valtemps)) // '_s.txt'
      open(unit=ec_sol2d,file=solfile2d,status="unknown")
      if(nbr_nds_coupes(j) > 0) then
        do i=1,nbr_nds_coupes(j)
          no = nds_coupes(j,i)
          write(ec_sol2d,'(5f16.6)') coordonnees(no,1), soleta(no) - solh(no), solh(no), soleta(no), solu(no)     
        enddo
      endif
      close (ec_sol2d)
    enddo       ! de do j=1,nbrcoupes
    close (ec_sol2d)
  endif
end subroutine stock_coupe2D

subroutine ouv_fichiers(vdlg, vdlg1, zm)

  use precision_m
  use global_device
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(in)         :: zm
  real(fp_kind), dimension(:,:), intent(inout)    :: vdlg, vdlg1

  integer                 :: i

  open(unit=ec_bilan_sim,file='RAPPORT_SIMULATION.txt',status="unknown")
  sol_elt_ts = trim(adjustl(mpi_process_id_string))    // trim(adjustl('_solution_elements_restart.txt'))
  sol_nd_ts = trim(adjustl(mpi_process_id_string))     // trim(adjustl('_solution_noeuds.txt'))

  if(solrestart==1) then
    open(ec_sol_elt_t, file=sol_elt_ts, status="unknown")
    open(ec_sol_nd_t,  file=sol_nd_ts,  status="unknown")
  endif

  !! Eriture de nombre total d elements en chaine de caracteres dans ntrirec
  write(ntrirec,'(i6)') nelt 

  select case (iflux)
  case (1)
    nom_methode = 'HLLC_ZOKA'
  case (2)
    nom_methode = 'HLLC_RIADH'
  case default
    print *,'donnee iflux non acceptable' 
  end select

  !! Cas d'un test avec loi de debit (table) Case of a test with debit law (table)
  if(debit_var==1) then
    open(unit=11,file=loi_debitglob,form='formatted',status='old')
    read(11,*) n_Q
    allocate(debit_t(n_Q,2))
    do i=1,n_Q
      read(11,*) debit_t(i,1) , debit_t(i,2)
    enddo
    close(11)
    cptdebit = 2
    cptdebit_d = cptdebit
    debitglob(1) = debit_t(cptdebit-1,2)
    debitglob_d = debitglob
    debitglob_sum = sum(debitglob)
  endif

  !! Ouverture du fichier de stockage des solutions 2D  (Opening the 2D solution storage file)
  write(valtemps,'(f12.3)') TS
  solfile2d_MC = trim(adjustl(mpi_process_id_string)) // '_FV--Q' // trim(adjustl(debit_tot)) // '_n_'// trim(adjustl(coef_frot))// '_t_' // trim(adjustl(valtemps)) // '_s'// '.txt'
  if (monte_carlo==1 ) then
    solfile2d_MC = trim(adjustl(mpi_process_id_string)) // '_SOL_FV_MULTISIM_2D.txt'
    solfile3d_MC = trim(adjustl(mpi_process_id_string)) // '_SOL_FV_MULTISIM_3D.txt'
    open(unit=3002,file=solfile2d_MC,status="unknown")
    open(unit=3003,file=solfile3d_MC,status="unknown")
  endif

  if (nbrcoupes>1) then
    file_Q_coupes = trim(adjustl(mpi_process_id_string)) // '_FV-debit_coupes.txt'
    open(unit=ec_Q_coupes,file=file_Q_coupes,status="unknown")
  endif

end subroutine ouv_fichiers

subroutine bluekenue_export(solh, soleta, solhu, solhv)
  ! =================================================================================
  !     bluekenue_export == Exporte dans un fichier pour postraitement avec Bluekenue
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  mai 31 2010
  ! =================================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

  integer :: nd, iel
  real(fp_kind) :: solu, solv

  write(valtemps,'(f12.3)') tc 
  solfile_eta_T3S = trim(adjustl(mpi_process_id_string)) // '_FV-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
  solfile_h_T3S   = trim(adjustl(mpi_process_id_string)) //   '_FV-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
  solfile_u_T3S   = trim(adjustl(mpi_process_id_string)) //   '_FV-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
  solfile_v_T3S   = trim(adjustl(mpi_process_id_string)) //   '_FV-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'

  open(unit=ec_Bluekenu_eta,file=solfile_ETA_T3S,status="unknown")
  open(unit=ec_Bluekenu_h,file=solfile_H_T3S,    status="unknown")
  open(unit=ec_Bluekenu_u,file=solfile_U_T3S,    status="unknown")
  open(unit=ec_Bluekenu_v,file=solfile_V_T3S,    status="unknown")

  write(ec_Bluekenu_eta,*) ':NodeCount', nnt
  write(ec_Bluekenu_eta,*) ':ElementCount', nelt
  write(ec_Bluekenu_eta,*) ':ElementType  T3'
  write(ec_Bluekenu_eta,*) ':EndHeader'

  write(ec_Bluekenu_h,*) ':NodeCount', nnt
  write(ec_Bluekenu_h,*) ':ElementCount', nelt
  write(ec_Bluekenu_h,*) ':ElementType  T3'
  write(ec_Bluekenu_h,*) ':EndHeader'

  write(ec_Bluekenu_u,*) ':NodeCount', nnt
  write(ec_Bluekenu_u,*) ':ElementCount', nelt
  write(ec_Bluekenu_u,*) ':ElementType  T3'
  write(ec_Bluekenu_u,*) ':EndHeader'

  write(ec_Bluekenu_v,*) ':NodeCount', nnt
  write(ec_Bluekenu_v,*) ':ElementCount', nelt
  write(ec_Bluekenu_v,*) ':ElementType  T3'
  write(ec_Bluekenu_v,*) ':EndHeader'

  do nd=1, nnt
    if ( solh(nd) > tolisec ) then
      solu = solhu(nd)/solh(nd)
      solv = solhv(nd)/solh(nd)
    else
      solu = 0.d0
      solv = 0.d0
    endif
    write(ec_Bluekenu_eta,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)
    write(ec_Bluekenu_h,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solh(nd)
    write(ec_Bluekenu_u,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solu
    write(ec_Bluekenu_v,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solv
  enddo
  do iel=1, nelt
    write(ec_Bluekenu_eta,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_h,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_u,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    write(ec_Bluekenu_v,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
  enddo

  close(ec_Bluekenu_eta)
  close(ec_Bluekenu_h)
  close(ec_Bluekenu_u)
  close(ec_Bluekenu_v)

end subroutine bluekenue_export

subroutine basic_export(vdlg1, solh, soleta, solhu, solhv, ci, id)

  use precision_m
  use global
  use m_param

  implicit none

  integer, intent(in) :: id, ci
  real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv
  real(fp_kind), dimension(:,:), intent(in)  :: vdlg1

  integer :: nd, iel

  if(ci==-1) then
    write(valtemps,*) "Final"
  else
    write(valtemps,'(I20)') ci
  end if

  if(id==0 .or. id==2) then 
    solfile_basic = trim(adjustl(trim(mpi_process_id_string)))//'_solution_noeuds_basic_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    open(unit=ec_sol_basic_nd,file=solfile_basic,status="unknown")
    do nd=1,nnt
      write(ec_sol_basic_nd,'(f16.6)') soleta(nd)
    end do
    close(ec_sol_basic_nd)
  else if(id==1 .or. id==2) then 
    solfile_basic = trim(adjustl(trim(mpi_process_id_string)))//'_solution_elements_basic_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
    open(unit=ec_sol_basic_elt,file=solfile_basic,status="unknown")
    do iel=1,nelt
      write(ec_sol_basic_elt,'(f16.6)') vdlg1(1,iel)
    end do
    close(ec_sol_basic_elt)
  end if

end subroutine basic_export

subroutine paraview_export(solh, soleta, solhu, solhv, ci)
  ! ==============================================================================
  !     paraview_export == Exporte dans un fichier vtk pour postraitement avec paraview
  !     auteur : Delmas Vincent
  !     version : 2.0  ;  july 31 2019
  ! ==============================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(in)  :: soleta, solh, solhu, solhv

  integer :: nd, iel, ci
  real(fp_kind) :: solu, solv

  if(ci==-1) then
    write(valtemps,*) "Final"
  else
    write(valtemps,'(I20)') ci
  end if

  solfile_para = trim(adjustl(trim(mpi_process_id_string)))//'_FV-Paraview_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.vtk'))

  open(unit=ec_Paraview,file=solfile_para,status="unknown")

  write(ec_Paraview,'(a)') "# vtk DataFile Version 1.0"
  write(ec_Paraview,'(a)') "2D Unstructured Grid"
  write(ec_Paraview,'(a)') "ASCII"
  write(ec_Paraview,'(a)') ""

  write(ec_Paraview,'(a)') "DATASET UNSTRUCTURED_GRID"
  write(ec_Paraview,'(a,I10,a)') "POINTS", nnt, " float"

  do nd=1, nnt
    write(ec_Paraview,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), 0.
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10,I10)') "CELLS", nelt, 4*nelt
  do iel=1, nelt
    write(ec_Paraview,'(I1,3I10)') 3, connectivite(iel,1)-1, connectivite(iel,2)-1, connectivite(iel,3)-1
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10)') "CELL_TYPES", nelt
  do iel=1, nelt
    write(ec_Paraview,'(a)') "5"
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a,I10)') "POINT_DATA", nnt
  write(ec_Paraview,'(a)') "SCALARS eta float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') soleta(nd)
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "SCALARS h float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') solh(nd)
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "SCALARS b float"
  write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
  do nd=1, nnt
    write(ec_Paraview,'(f16.6)') soleta(nd)-solh(nd)
  end do

  write(ec_Paraview,'(a)') ""
  write(ec_Paraview,'(a)') "VECTORS velocity float"
  do nd=1, nnt
    if ( solh(nd) > tolisec ) then
      solu = solhu(nd)/solh(nd)
      solv = solhv(nd)/solh(nd)
    else
      solu = 0.d0
      solv = 0.d0
    endif
    write(ec_Paraview,'(3f16.6)')   solu, solv, 0.
  end do

  close(ec_Paraview)

end subroutine paraview_export

subroutine tecplot_export(solh, soleta, solhu, solhv)
  ! ============================================================================
  !     tecplot_export == Export to a text file the solutions for postraitement with Tecplot
  !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
  !     version : 2.0  ;  mai 13 2018
  ! ============================================================================

  use precision_m
  use global
  use m_param

  implicit none

  real(fp_kind), dimension(:), intent(inout)  :: soleta, solh, solhu, solhv

  integer :: nd, i
  real(fp_kind) :: solu, solv

  if ( start == 1 ) then

    tecplot   =  trim(adjustl(mpi_process_id_string))//'_FV-Tecplot.dat'

    open(unit=ec_tecplot,file=tecplot,status="unknown")

    write(ec_tecplot,*) 'title = "hauteur"'
    write(ec_tecplot,*) 'variables = "x","y","z","h","eta","u","v", "manning"'
    write(ec_tecplot,*) 'zone t="pas:',valtemps, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle'

    do nd=1, nnt
      write(ec_tecplot,'(8f16.6)') coordonnees(nd,1),coordonnees(nd,2),coordonnees(nd,3),solh(nd),soleta(nd),solhu(nd),solhv(nd),manning_nd(nd)
    enddo

    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '

    do i=1, nelt
      write(ec_tecplot,*) connectivite(i,1) , connectivite(i,2) , connectivite(i,3)
    enddo

    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '

  else
    write(ec_tecplot,*) 'zone t="pas:',tc, '" , f=fepoint, n=',nnt, ',e=',nelt, ',et=triangle', ',D=(feconnect)'
    do nd=1, nnt
      write(ec_tecplot,'(8f16.6)') coordonnees(nd,1), coordonnees(nd,2), soleta(nd)-solh(nd), solh(nd), soleta(nd), solhu(nd), solhv(nd), manning_nd(nd)
    enddo
    write(ec_tecplot,*)' '
    write(ec_tecplot,*)' '
  endif
end subroutine tecplot_export
