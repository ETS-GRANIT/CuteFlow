attributes(global) subroutine cotes_cudaf3_riadh(surf_d, zm_d,gradz_d,vdlg_d)
  ! Cacul du flux HLLC avec methode riadh
  ! Article : A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications, Riadh et al.

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine solver_Riemann_cudaf_riadh(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)

      use global_device

      implicit none

      integer, intent(in)                   :: kvol, kvoisin, model
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(:), intent(in)     :: surf
      real(fp_kind), dimension(:,:), intent(in)   :: vdlg
    end subroutine solver_Riemann_cudaf_riadh

  end interface

  real(fp_kind), dimension(:), intent(in)      :: surf_d, zm_d
  real(fp_kind), dimension(:,:), intent(in)    :: gradz_d  ! remove it if not used
  real(fp_kind), dimension(:,:), intent(in)    :: vdlg_d

  integer               :: i, nc1, nc2, kvoisin, dl,pp, hybrid, model, nc3
  real(fp_kind)               :: x1, x2, y1, y2, ln, x3, y3
  real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr, hijet, hjiet, zij
  real(fp_kind)               :: zero, debitnorm, orient
  real(fp_kind), dimension(2) :: norm
  real(fp_kind), dimension(3) :: flux
  integer                     :: ti,gi, tj, gj, id_entree
  real                        :: cond
  real(fp_kind), shared       :: s1(64,3)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti
  tj = threadIdx%y
  gj=  (blockIdx%y - 1)*blockDim%y + tj

  zero = 0.d0
  hybrid = 0

  !   Retrieve a neighboring cell dry ===============================
  ! do it outside and see if un_voisin_sec is being used here    

  if(gi <= nelt_d-nelt_fant_recep_d) then
    nc1 = tj
    cond = merge(1,0, nc1 == ns_d)
    nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))
    cond = merge(1,0, nc2 == ns_d)
    nc3 = int((nc2 - ns_d + 1)*cond + (nc2 + 1)*(1-cond))

    x1 = coo_table_elemwise_d(gi, 3*nc1-2)
    y1 = coo_table_elemwise_d(gi, 3*nc1-1)

    x2 = coo_table_elemwise_d(gi, 3*nc2-2)
    y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

    x3 = coo_table_elemwise_d(gi, 3*nc3-2)
    y3 = coo_table_elemwise_d(gi, 3*nc3-1) 

    ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

    norm(1) = ( y2 - y1 ) / ln
    norm(2) = ( x1 - x2 ) / ln

    orient = norm(1)*((x1+x2)/2.-(x1+x2+x3)/3.) + norm(2)*((y1+y2)/2.-(y1+y2+y3)/3.)
    if(orient < 0.) then
      norm(1) = ( y1 - y2 ) / ln
      norm(2) = ( x2 - x1 ) / ln
    end if

    ! *** initialisation du flux ***
    flux     = 0.d0
    kvoisin = boundary_d(gi,nc1,1)
    id_entree = boundary_d(gi,nc1,2)

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(1,gi)
      s1(ti,2) = zm_d(gi)
    endif

    call syncthreads()

    hautl  = s1(ti,1)
    zml    = s1(ti,2)

    call syncthreads()

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(2,gi)
      s1(ti,2) = vdlg_d(3,gi)
    endif

    call syncthreads()

    hul    = s1(ti,1)
    hvl    = s1(ti,2)

    call syncthreads()

    vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
    vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl

    ! *** application des conditions aux limites si kvol est frontier ***
    if ( kvoisin == -1 ) then ! *** flux entrant ***
      if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
        flux(1) = hautl * vitul
        flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
        flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
      elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
        debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
        flux(1) = debitnorm
        flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
        flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
        debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
        debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
      else
        write(*,*) 'donnee inlet_d non convenable'
      endif
    endif

    if ( kvoisin == -2 ) then ! *** flux sortant ***
      if ( vitul > 0.d0 .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
        hautl = h_sortie_d(id_entree) - zml
        flux(1) = hautl * vitul
        flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
        flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
      else
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl**2/2.
        flux(3) = norm(2) * gp_d * hautl**2/2.
      endif

      debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln

    endif

    if ( kvoisin == -3 ) then  ! *** flux de mur ***
      flux(1) = 0.d0
      flux(2) = norm(1) * gp_d * hautl**2/2.
      flux(3) = norm(2) * gp_d * hautl**2/2.
    endif

    if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
      hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
      zmr = zm_d(kvoisin)        !this is also inefficient global memory access

      zij = max(zml,zmr)
      hijet = hautl + zml - zij
      hijet = max(0.0D0, hijet)

      hjiet = hautr + zmr - zij
      hjiet = max(0.0D0, hjiet)

      hur   = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
      hvr   = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

      vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
      vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr

      !call solver_Riemann_cudaf_riadh(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
      call solver_Riemann_cudaf_riadh(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)

    endif ! de ( kvoisin > 0. )

    s1(ti, tj)   = flux(1) * ln
    call syncthreads()

    if(tj == 1)  resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(2) * ln
    call syncthreads()

    if(tj == 1)  resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(3) * ln
    call syncthreads()

    if(tj == 1)  resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)

  endif ! Fin de if(gi<nelt_d) 
end subroutine cotes_cudaf3_riadh

attributes(global) subroutine cotes_cudaf3(surf_d, zm_d,gradz_d,vdlg_d)
  ! ======================================================================
  !     cotes = calcul du flux à l'interface des cotes de kvol
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine solver_Riemann_cudaf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)

      use global_device

      implicit none

      integer, intent(in)                   :: kvol, kvoisin, model
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(:), intent(in)     :: surf
      real(fp_kind), dimension(:,:), intent(in)   :: vdlg
    end subroutine solver_Riemann_cudaf

  end interface

  real(fp_kind), dimension(:), intent(in)      :: surf_d, zm_d
  real(fp_kind), dimension(:,:), intent(in)    :: gradz_d  ! remove it if not used
  real(fp_kind), dimension(:,:), intent(in)    :: vdlg_d

  integer               :: i, nc1, nc2, kvoisin, dl,pp, hybrid, model, nc3
  real(fp_kind)               :: x1, x2, y1, y2, ln, x3, y3
  real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr
  real(fp_kind)               :: zero, debitnorm, orient
  real(fp_kind), dimension(2) :: norm
  real(fp_kind), dimension(3) :: flux
  integer                     :: ti,gi, tj, gj, id_entree
  real                        :: cond
  real(fp_kind), shared       :: s1(64,3)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti
  tj = threadIdx%y
  gj=  (blockIdx%y - 1)*blockDim%y + tj

  zero = 0.d0
  hybrid = 0

  !   Retrieve a neighboring cell dry ===============================
  ! do it outside and see if un_voisin_sec is being used here    

  if(gi <= nelt_d-nelt_fant_recep_d) then
    nc1 = tj
    cond = merge(1,0, nc1 == ns_d)
    nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))
    cond = merge(1,0, nc2 == ns_d)
    nc3 = int((nc2 - ns_d + 1)*cond + (nc2 + 1)*(1-cond))

    x1 = coo_table_elemwise_d(gi, 3*nc1-2)
    y1 = coo_table_elemwise_d(gi, 3*nc1-1)

    x2 = coo_table_elemwise_d(gi, 3*nc2-2)
    y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

    x3 = coo_table_elemwise_d(gi, 3*nc3-2)
    y3 = coo_table_elemwise_d(gi, 3*nc3-1) 

    ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

    norm(1) = ( y2 - y1 ) / ln
    norm(2) = ( x1 - x2 ) / ln

    orient = norm(1)*((x1+x2)/2.-(x1+x2+x3)/3.) + norm(2)*((y1+y2)/2.-(y1+y2+y3)/3.)
    if(orient < 0.) then
      norm(1) = ( y1 - y2 ) / ln
      norm(2) = ( x2 - x1 ) / ln
    end if

    ! *** initialisation du flux ***
    flux     = 0.d0
    kvoisin = boundary_d(gi,nc1,1)
    id_entree = boundary_d(gi,nc1,2)

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(1,gi)
      s1(ti,2) = zm_d(gi)
    endif

    call syncthreads()

    hautl  = s1(ti,1)
    zml    = s1(ti,2)

    call syncthreads()

    if ( hautl> tolisec_d ) then
      if(nc1 == 1) then 
        s1(ti,1) = vdlg_d(2,gi)
        s1(ti,2) = vdlg_d(3,gi)
      endif

      call syncthreads()

      hul    = s1(ti,1)
      hvl    = s1(ti,2)

      vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
      vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl
    else
      hautl = tolisec_d
      vitul = 0.d0
      vitvl = 0.d0
    endif

    ! *** application des conditions aux limites si kvol est frontier ***
    if ( kvoisin == -1 ) then ! *** flux entrant ***
      if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
        if ( hautl > tolisec_d ) then
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        endif

      elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
        debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
        flux(1) = debitnorm
        flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
        flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
        debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
        debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
      else
        write(*,*) 'donnee inlet_d non convenable'
      endif
    endif

    if ( kvoisin == -2 ) then ! *** flux sortant ***
      if ( hautl > tolisec_d ) then
        if ( vitul > 0.d0 .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
          hautl = h_sortie_d(id_entree) - zml
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        else
          flux(1) = 0.d0
          flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
          flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
        endif
      else
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
      end if

      debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln

    endif

    if ( kvoisin == -3 ) then  ! *** flux de mur ***
      if (hautl > tolisec_d) then
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
      else
        flux(1) = 0.d0
        flux(2) = 0.d0
        flux(3) = 0.d0
      endif
    endif

    if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
      hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
      zmr = zm_d(kvoisin)        !this is also inefficient global memory access

      if ( hautr > tolisec_d ) then
        hur    = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
        hvr    = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

        vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
        vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr
      else
        hautr = tolisec_d
        vitur = 0.d0
        vitvr = 0.d0
        hybrid = 0
      endif

      call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)

      ! *** WET and DRY
      ! *** Prolongement du niveau d'eau sur le sec pour éviter la création d'un gradient
      if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zmr > hautl+zml ) then
          !Transitoire : Cellule calculée mouillée - Cellule voisine sèche ***
          if ( vitul > sqrt(2*gp_d*(zmr-zml) ) ) then
            zmr = zml+hautl  
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
            flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
          endif
        endif   ! de if( zmr > hautl+zml ) then

      elseif( hautl <= tolisec_d .and. hautr > tolisec_d ) then  ! de if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zml >= hautr+zmr ) then 
          !Transitoire : Cellule calculée sèche  - Cellule voisine mouillée 
          if ( -vitur > sqrt(2*gp_d*(zml-zmr) ) .and. vitur < 0) then
            zml   = zmr+hautr
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = 0.d0
            flux(3) = 0.d0
          endif
        endif ! de if( zml >= hautr+zmr ) then
      endif   ! (hautr <= tolisec_d .and. hautl > tolisec_d) then

      ! Cas de deux éléments voisins secs
      if (hautl <= tolisec_d .and. hautr <= tolisec_d) then
        flux(1) = 0.d0
        flux(2) = 0.d0
        flux(3) = 0.d0
      endif
      ! Sommation des flux d'interface
      ! flux_interface = flux_interface + flux*ln
    endif ! de ( kvoisin > 0. )

    s1(ti, tj)   = flux(1) * ln
    call syncthreads()

    if(tj == 1)  resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(2) * ln
    call syncthreads()

    if(tj == 1)  resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(3) * ln
    call syncthreads()

    if(tj == 1)  resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)

  endif ! Fin de if(gi<nelt_d) 
end subroutine cotes_cudaf3


attributes(device) subroutine solver_Riemann_cudaf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)
  ! Méthode de l'article :
  ! Modeling of wetting–drying transitions in free surfaceflows overcomplex topographies 
  ! JM Zokagoa et A. Soulaimaini

  use precision_m
  use global_device
  implicit none

  integer, intent(in)                         :: kvol, kvoisin, model
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(:), intent(in)     :: surf
  real(fp_kind), dimension(:,:), intent(in)   :: vdlg

  real(fp_kind)                 :: hm, cel, vitess, vitesm, vitesp, hbar !,cell, celr
  real(fp_kind)                 :: hl2, hr2, zml2, zmr2
  real(fp_kind), dimension(3)   :: fl, fr, flux1
  real(fp_kind), dimension(2,3) :: f

  integer                 :: i, noeud, dl ,p
  real(fp_kind)                 :: udeclg, vdeclg, udecrg, vdecrg, limiteurh, limiteurhu, limiteurhv
  real(fp_kind)                 :: hdecl, udecl, vdecl, hdecr, udecr, vdecr
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr
  real(fp_kind)                 :: xleftupw, yleftupw, xrigtupw, yrigtupw, lamda_local
  real(fp_kind), dimension(3)   :: courant, bbb, psi, ratio, dloc, dupw
  real(fp_kind), dimension(5)   :: poids

  pp = pp + 1
  hbar = hl     

  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hbar*(hl+zml)            
  f(1,3) = hl * ul * vl
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hbar*(hr+zmr)
  f(2,3) = hr * ur * vr

  if ( hr <= tolisec_d .or. hl <= tolisec_d )  then
    ! *** calcul de la celerite et de la vitsse de propagation d'onde ***
    hm     = (hl + hr) / 2.d0 
    vitess = (ul + ur) / 2.d0

    cel =  sqrt( gp_d * hm )
    vitesm = vitess  - cel
    vitesp = vitess  + cel

    lamda_local = max( abs(vitesm) , abs(vitess) , abs(vitesp) )          

    fl(1) = (hr + zmr) - (hl+zml)
    fl(2) = hr * ur - hl * ul
    fl(3) = hr * vr - hl * vl

    do dl=1,ndln_d
      flux1(dl) = ( f(1,dl) + f(2,dl) - lamda_local * fl(dl) ) / 2.d0
    enddo

  else    !  L interface separe deux cellules mouillees
    !           *** celerités a gauche et a droite ***
    al = sqrt( gp_d * hl )
    ar = sqrt( gp_d * hr )

    !           *** profondeur dans la region etoile ***  Shock-Capturing Methods for Free-Surface Shallow Flows : Toro
    het  =  ( hl + hr ) / 2  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4     ! formules (10.17 / 10.18) p178/179

    if ( het.le.min(hl,hr) ) then       ! == onde de rarefaction :
      het = ( ( al + ar )/2 + ( ul - ur )/4 )**2 / gp_d
    else
      gl = sqrt( 0.5 * gp_d * ( het + hl ) / ( het * hl ) )
      gr = sqrt( 0.5 * gp_d * ( het + hr ) / ( het * hr ) )
      het = ( hl * gl + hr * gr + ul - ur ) / ( gl + gr )
    endif
    !           *** vitesses d'ondes ***
    if ( hl <= tolisec_d ) then
      sl  = ur - 2 * ar
      sr  = ur + ar
      set = sl
    else if ( hr <= tolisec_d ) then
      sl  = ul - al
      sr  = ul + 2 * al
      set = sr
    else
      if ( het > hl ) then
        sl = ul - al * sqrt( het * (het + hl) / 2 ) / hl
      else
        sl = ul - al
      endif
      if ( het > hr ) then
        sr = ur + ar * sqrt( het * (het + hr) / 2 ) / hr
      else
        sr = ur + ar
      endif
      set = ( sl * hr * ( ur - sr ) - sr * hl * ( ul - sl ) ) /  ( hr * ( ur - sr ) - hl * ( ul - sl ) )
    endif

    !			Flux HLLC
    if ( sl >= 0 ) then
      do dl=1, ndln_d
        flux1(dl) = f(1,dl)
      enddo
    elseif ( sr <= 0 ) then
      do dl=1, ndln_d
        flux1(dl) = f(2,dl)
      enddo
    elseif ( sl < 0 .and. set >= 0 ) then
      flux1(1) = ( sr * f(1,1) - sl * f(2,1) + sl * sr * ( hr - hl ) ) / ( sr - sl )
      flux1(2) = ( sr * f(1,2) - sl * f(2,2) + sl * sr * (hr*ur - hl*ul) ) / ( sr - sl )
      flux1(3) = flux1(1) * vl
    elseif ( set <= 0 .and. sr > 0 ) then
      flux1(1) = ( sr * f(1,1) - sl * f(2,1) + sl * sr * ( hr - hl ) ) / ( sr - sl )
      flux1(2) = ( sr * f(1,2) - sl * f(2,2) + sl * sr * (hr*ur - hl*ul) ) / ( sr - sl )
      flux1(3) = flux1(1) * vr
    endif
  endif !		de ''if ( hr <= tolisec_d .or. hl <= tolisec_d )''

  ! *** inersion du flux ***
  flux(1) = flux1(1)
  flux(2) = norm(1) * flux1(2) - norm(2) * flux1(3)
  flux(3) = norm(2) * flux1(2) + norm(1) * flux1(3)                       
end subroutine solver_Riemann_cudaf

attributes(device) subroutine solver_Riemann_cudaf_riadh(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)
  ! Import des routines de Riadh ATA pour HLLC
  ! Méthode de l'article : 
  ! A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications
  ! Riadh ATA et al.
  ! 
  ! Contrairement a l'autre solveur de Zokagoa on ne prend pas en compte la bathymétrie ici
  ! il faut la traiter dans les termes sources

  use precision_m
  use global_device
  implicit none

  integer, intent(in)                         :: kvol, kvoisin, model
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(:), intent(in)     :: surf
  real(fp_kind), dimension(:,:), intent(in)   :: vdlg

  real(fp_kind)                 :: hm, cel, vitess, vitesm, vitesp, eps
  real(fp_kind)                 :: hl2, hr2, zml2, zmr2
  real(fp_kind), dimension(3)   :: fl, fr, flux1
  real(fp_kind), dimension(2,3) :: f, fet, q, qet

  integer                 :: i, noeud, dl ,p
  real(fp_kind)                 :: udeclg, vdeclg, udecrg, vdecrg, limiteurh, limiteurhu, limiteurhv
  real(fp_kind)                 :: hdecl, udecl, vdecl, hdecr, udecr, vdecr
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond
  real(fp_kind)                 :: xleftupw, yleftupw, xrigtupw, yrigtupw, lamda_local
  real(fp_kind), dimension(3)   :: courant, bbb, psi, ratio, dloc, dupw
  real(fp_kind), dimension(5)   :: poids

  eps = 1e-6

  pp = pp + 1

  if(hl.lt.eps.and.hr.lt.eps) goto 20

  al = sqrt( gp_d * hl )
  ar = sqrt( gp_d * hr )

  het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
  uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

  if ( het.lt.hl ) then
    pql = 1.
  else
    if(hl.gt.eps) then
      pql = sqrt(0.5*(het+hl)*het/hl**2)
    else
      pql = 0.
    end if
  endif

  if ( het.lt.hr ) then
    pqr = 1.
  else
    if(hr.gt.eps) then
      pqr = sqrt(0.5*(het+hr)*het/hr**2)
    else
      pqr = 0.
    end if
  endif

  20 continue

  if ( hl.gt.eps ) then
    sl = ul-al*pql
  else
    sl  = ur - 2 * ar
    sr  = ur + ar
    goto 35
  end if

  if ( hr.gt.eps ) then
    sr = ur+ar*pqr
  else
    sl  = ul - al
    sr  = ul + 2 * al
    goto 35
  end if

  35 continue

  denom = hr*(ur-sr)-hl*(ul-sl)
  if(abs(denom).lt.eps) then
    set = uet
  else
    set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
  end if

  !Calcul de Ql et Qr (Riadh)
  q(1,1) = hl
  q(1,2) = hl*ul
  q(1,3) = hl*vl

  q(2,1) = hr
  q(2,2) = hr*ur
  q(2,3) = hr*vr

  !!Calcul de Qetl et Qetr
  if(abs(sl-set).gt.eps) then
    pond = hl*(sl-ul)/(sl-set)
  else
    pond= 0.D0
  End if

  qet(1,1) = pond
  qet(1,2) = pond*set
  qet(1,3) = pond*vl


  if(abs(sr-set).gt.eps) then
    pond = hr*(sr-ur)/(sr-set)
  else
    pond= 0.D0
  end if

  qet(2,1) = pond
  qet(2,2) = pond*set
  qet(2,3) = pond*vr

  !!Cacul de G(Ul)
  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
  f(1,3) = hl * ul * vl

  !!Cacul de G(Ur)
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
  f(2,3) = hr * ur * vr

  fet(1,1) = f(1,1) + sl*(qet(1,1)-q(1,1))
  fet(1,2) = f(1,2) + sl*(qet(1,2)-q(1,2))
  fet(1,3) = f(1,3) + sl*(qet(1,3)-q(1,3))

  fet(2,1) = f(2,1) + sr*(qet(2,1)-q(2,1))
  fet(2,2) = f(2,2) + sr*(qet(2,2)-q(2,2))
  fet(2,3) = f(2,3) + sr*(qet(2,3)-q(2,3))

  !Flux HLLC
  if (0.lt.sl) then
    flux1(1) = f(1,1)
    flux1(2) = f(1,2)
    flux1(3) = f(1,3)
  elseif (0.lt.set.and.0.gt.sl) then
    flux1(1) = fet(1,1)
    flux1(2) = fet(1,2)
    flux1(3) = fet(1,3)
  elseif (0.gt.set.and.0.lt.sr) then
    flux1(1) = fet(2,1)
    flux1(2) = fet(2,2)
    flux1(3) = fet(2,3)
  else
    flux1(1) = f(2,1)
    flux1(2) = f(2,2)
    flux1(3) = f(2,3)
  endif

  ! *** inersion du flux ***
  flux(1) = flux1(1)
  flux(2) = norm(1) * flux1(2) - norm(2) * flux1(3)
  flux(3) = norm(2) * flux1(2) + norm(1) * flux1(3)                       
end subroutine solver_Riemann_cudaf_riadh
