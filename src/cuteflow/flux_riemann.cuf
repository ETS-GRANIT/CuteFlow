module flux_riemann
  implicit none
contains
  attributes(global) subroutine cotes3(surf_d, zm_d,vdlg_d)
    ! Cacul du flux HLLC avec methode riadh
    ! Article : A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications, Riadh et al.

    use precision_kind
    use global_data_device
    implicit none

    real(fp_kind), dimension(nelt_d), intent(in)      :: surf_d, zm_d
    real(fp_kind), dimension(ndln_d,nelt_d), intent(in)    :: vdlg_d

    integer                     :: i, nc1, nc2, kvoisin, dl,pp, nc3, kvol, kv
    real(fp_kind)               :: x1, x2, y1, y2, ln, x3, y3, xupw, yupw
    real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr, hijet, hjiet, zij
    integer                     :: kvol_v1, kvol_v2, kvoisin_v1, kvoisin_v2, kupw1, kupw2
    real(fp_kind)               :: kvol_v1_h, kvol_v1_u, kvol_v1_v
    real(fp_kind)               :: kvol_v2_h, kvol_v2_u, kvol_v2_v
    real(fp_kind)               :: kvoisin_v1_h, kvoisin_v1_u, kvoisin_v1_v
    real(fp_kind)               :: kvoisin_v2_h, kvoisin_v2_u, kvoisin_v2_v
    real(fp_kind)               :: hl_upw, ul_upw, vl_upw, hr_upw, ur_upw, vr_upw
    real(fp_kind)               :: kupw1_area, kupw2_area
    real(fp_kind)               :: zero, debitnorm, orient
    real(fp_kind), dimension(2) :: norm
    real(fp_kind), dimension(3) :: flux
    real :: cond

    integer                     :: ti,gi, tj, gj, id_entree, tjv
    real(fp_kind), shared       :: s1(blockdim%x,ns_d)

    ti = threadIdx%x
    gi = (blockIdx%x - 1)*blockDim%x + ti
    tj = threadIdx%y
    gj=  (blockIdx%y - 1)*blockDim%y + tj

    zero = 0.d0

    !   Retrieve a neighboring cell dry ===============================
    ! do it outside and see if un_voisin_sec is being used here    

    if(gi <= nelt_d-nelt_fant_recep_d) then
      ! write(*,*),gi,"launch"
      kvol = gi
      nc1 = tj
      cond = merge(1,0, nc1 == ns_d)
      nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))
      cond = merge(1,0, nc2 == ns_d)
      nc3 = int((nc2 - ns_d + 1)*cond + (nc2 + 1)*(1-cond))

      x1 = coo_table_elemwise_d(gi, 3*nc1-2)
      y1 = coo_table_elemwise_d(gi, 3*nc1-1)

      x2 = coo_table_elemwise_d(gi, 3*nc2-2)
      y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

      x3 = coo_table_elemwise_d(gi, 3*nc3-2)
      y3 = coo_table_elemwise_d(gi, 3*nc3-1) 

      ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

      norm(1) = ( y2 - y1 ) / ln
      norm(2) = ( x1 - x2 ) / ln

      orient = norm(1)*((x1+x2)/2.-(x1+x2+x3)/3.) + norm(2)*((y1+y2)/2.-(y1+y2+y3)/3.)
      if(orient < 0.) then
        norm(1) = ( y1 - y2 ) / ln
        norm(2) = ( x2 - x1 ) / ln
      end if

      ! *** initialisation du flux ***
      flux     = 0.d0
      kvoisin = boundary_d(gi,nc1,1)
      id_entree = boundary_d(gi,nc1,2)

      if(nc1 == 1) then 
        s1(ti,1) = vdlg_d(1,gi)
        s1(ti,2) = zm_d(gi)
      endif

      call syncthreads()

      hautl  = s1(ti,1)
      zml    = s1(ti,2)

      call syncthreads()

      if(nc1 == 1) then 
        s1(ti,1) = vdlg_d(2,gi)
        s1(ti,2) = vdlg_d(3,gi)
      endif

      call syncthreads()

      hul    = s1(ti,1)
      hvl    = s1(ti,2)

      call syncthreads()

      vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
      vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl

      ! *** application des conditions aux limites si kvol est frontier ***
      if ( kvoisin == -1 ) then ! *** flux entrant ***
        if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
        elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
          debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
          flux(1) = debitnorm
          flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
          flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl**2/2. )
          debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
          debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
        else
          write(*,*) 'donnee inlet_d non convenable'
        endif
      endif

      if ( kvoisin == -2 ) then ! *** flux sortant ***
        if ( vitul > tolisec_d .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
          hautl = h_sortie_d(id_entree) - zml
          hautl = max(0.0D0, hautl)
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl**2/2. ) + norm(1) * hautl * vitul * vitvl
        else
          flux(1) = 0.d0
          flux(2) = norm(1) * gp_d * hautl**2/2.
          flux(3) = norm(2) * gp_d * hautl**2/2.
        endif

        debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln

      endif

      if ( kvoisin == -3 ) then  ! *** flux de mur ***
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl**2/2.
        flux(3) = norm(2) * gp_d * hautl**2/2.
      endif

      if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
        hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
        zmr = zm_d(kvoisin)        !this is also inefficient global memory access

        zij = max(zml,zmr)
        hijet = hautl + zml - zij
        hijet = max(0.0D0, hijet)

        hjiet = hautr + zmr - zij
        hjiet = max(0.0D0, hjiet)

        hur   = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
        hvr   = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

        vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
        vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr

        if(iflux_d==1) then
          !!HLLC
          call solver_Riemann_hllc(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,flux,ln,pp)
        else if(iflux_d==2) then 
          !!WAF méthode riadh ata
          call solver_Riemann_riadh(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,flux,ln,pp)
        else if (iflux_d==3) then 
          !! WAF Loukilli
          !! Order 2 second neighbor

          if(iupwind_d==1) then
            !! kvol_v1 est le premier voisin de kvol
            !! kvol_v2 est le second voisin de kvol
            !! kvoisin est le voisin de kvol à travers l'interface qu'on regarde
            kvol_v1 = upwind_cells_d(1,tj,kvol)
            kvol_v2 = upwind_cells_d(2,tj,kvol)

            kvol_v1_h = vdlg_d(1,kvol_v1)
            if(kvol_v1_h>tolisec_d) then
              kvol_v1_u = (vdlg_d(2,kvol_v1) * norm(1) + vdlg_d(3,kvol_v1) * norm(2))/kvol_v1_h
              kvol_v1_v = (vdlg_d(3,kvol_v1) * norm(1) - vdlg_d(2,kvol_v1) * norm(2))/kvol_v1_h
            else
              kvol_v1_h = tolisec_d
              kvol_v1_u = 0.
              kvol_v1_v = 0.
            end if

            kvol_v2_h = vdlg_d(1,kvol_v2)
            if(kvol_v2_h>tolisec_d) then
              kvol_v2_u = (vdlg_d(2,kvol_v2) * norm(1) + vdlg_d(3,kvol_v2) * norm(2))/kvol_v2_h
              kvol_v2_v = (vdlg_d(3,kvol_v2) * norm(1) - vdlg_d(2,kvol_v2) * norm(2))/kvol_v2_h
            else
              kvol_v2_h = tolisec_d
              kvol_v2_u = 0.
              kvol_v2_v = 0.
            end if


            !!Cherche quel côte est l'interface du coté de kvoisin
            if(((connectivite_d(kvoisin,1) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,2) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,2) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,1) == connectivite_d(kvol,nc2)))) then
              tjv = 1
            else if(((connectivite_d(kvoisin,2) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,3) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,3) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,2) == connectivite_d(kvol,nc2)))) then
              tjv = 2
            else if(((connectivite_d(kvoisin,3) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,1) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,1) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,3) == connectivite_d(kvol,nc2)))) then
              tjv = 3
            end if

            kvoisin_v1 = upwind_cells_d(1,tjv,kvoisin)
            kvoisin_v2 = upwind_cells_d(2,tjv,kvoisin)

            kvoisin_v1_h = vdlg_d(1,kvoisin_v1)
            if(kvoisin_v1_h>tolisec_d) then
              kvoisin_v1_u = (vdlg_d(2,kvoisin_v1) * norm(1) + vdlg_d(3,kvoisin_v1) * norm(2))/kvoisin_v1_h
              kvoisin_v1_v = (vdlg_d(3,kvoisin_v1) * norm(1) - vdlg_d(2,kvoisin_v1) * norm(2))/kvoisin_v1_h
            else
              kvoisin_v1_h = tolisec_d
              kvoisin_v1_u = 0.
              kvoisin_v1_v = 0.
            end if

            kvoisin_v2_h = vdlg_d(1,kvoisin_v2)
            if(kvoisin_v2_h>tolisec_d) then
              kvoisin_v2_u = (vdlg_d(2,kvoisin_v2) * norm(1) + vdlg_d(3,kvoisin_v2) * norm(2))/kvoisin_v2_h
              kvoisin_v2_v = (vdlg_d(3,kvoisin_v2) * norm(1) - vdlg_d(2,kvoisin_v2) * norm(2))/kvoisin_v2_h
            else
              kvoisin_v2_h = tolisec_d
              kvoisin_v2_u = 0.
              kvoisin_v2_v = 0.
            end if

            if(((kvol_v1 == kvol) .or. (kvol_v2==kvol)) .or. ((kvoisin_v1==kvoisin) .or. (kvoisin_v2==kvoisin))) then
              hl_upw=hautl
              ul_upw=vitul
              vl_upw=vitvl

              hr_upw=hautr
              ur_upw=vitur
              vr_upw=vitvr
            else
              hl_upw=(surf_d(kvol_v1)*kvol_v1_h+surf_d(kvol_v2)*kvol_v2_h)/(surf_d(kvol_v1)+surf_d(kvol_v2))
              hr_upw=(surf_d(kvoisin_v1)*kvoisin_v1_h+surf_d(kvoisin_v2)*kvoisin_v2_h)/(surf_d(kvoisin_v1)+surf_d(kvoisin_v2))

              ul_upw=(surf_d(kvol_v1)*kvol_v1_u+surf_d(kvol_v2)*kvol_v2_u)/(surf_d(kvol_v1)+surf_d(kvol_v2))
              ur_upw=(surf_d(kvoisin_v1)*kvoisin_v1_u+surf_d(kvoisin_v2)*kvoisin_v2_u)/(surf_d(kvoisin_v1)+surf_d(kvoisin_v2))

              vl_upw=(surf_d(kvol_v1)*kvol_v1_v+surf_d(kvol_v2)*kvol_v2_v)/(surf_d(kvol_v1)+surf_d(kvol_v2))
              vr_upw=(surf_d(kvoisin_v1)*kvoisin_v1_v+surf_d(kvoisin_v2)*kvoisin_v2_v)/(surf_d(kvoisin_v1)+surf_d(kvoisin_v2))
            end if
          else if(iupwind_d==2) then
            !!Cherche quel côte est l'interface du coté de kvoisin
            if(((connectivite_d(kvoisin,1) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,2) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,2) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,1) == connectivite_d(kvol,nc2)))) then
              tjv = 1
            else if(((connectivite_d(kvoisin,2) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,3) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,3) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,2) == connectivite_d(kvol,nc2)))) then
              tjv = 2
            else if(((connectivite_d(kvoisin,3) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,1) == connectivite_d(kvol,nc2))) .or. &
              &((connectivite_d(kvoisin,1) == connectivite_d(kvol,nc1)) .and. &
              &(connectivite_d(kvoisin,3) == connectivite_d(kvol,nc2)))) then
              tjv = 3
            end if


            hl_upw = 0.
            ul_upw = 0.
            vl_upw = 0.
            kupw1_area = 0.

            hr_upw = 0.
            ur_upw = 0.
            vr_upw = 0.
            kupw2_area = 0.

            do i=1,6
              !!Indice de la maille i contenant le sommet nc1+2 (opposé à l'interface)
              kupw1 = vertex_neighbors_d(i,connectivite_d(kvol,1+mod(nc1+1,3))) 
              orient = (x_centroid_d(kupw1)-x3)*(x3-x_centroid_d(kvol)) + (y_centroid_d(kupw1)-y3)*(y3-y_centroid_d(kvol)) 
              ! if(kupw1>0 .and. kupw1/=kvol .and. orient>0.) then
              if(kupw1>0 .and. kupw1/=kvol) then
                ! if(kupw1>0 .and. kupw1/=kvol) then
                ! if(kvol==6195 .and. kvoisin == 6199) print*, "L",i, kupw1
                if(vdlg_d(1,kupw1) > tolisec_d) then
                  hl_upw = hl_upw + vdlg_d(1,kupw1)*surf_d(kupw1)
                  ul_upw = ul_upw + (vdlg_d(2,kupw1) * norm(1) + vdlg_d(3,kupw1) * norm(2))*surf_d(kupw1)/vdlg_d(1,kupw1)
                  vl_upw = vl_upw + (vdlg_d(3,kupw1) * norm(1) - vdlg_d(2,kupw1) * norm(2))*surf_d(kupw1)/vdlg_d(1,kupw1)
                end if
                kupw1_area = kupw1_area + surf_d(kupw1)
              end if

              kupw2 = vertex_neighbors_d(i,connectivite_d(kvoisin,1+mod((tjv+2)-1,3)))
              ! x3 = coo_table_elemwise_d(gi, 3*nc3-2)
              xupw = coo_table_elemwise_d(kvoisin,3*mod((tjv+2)-1,3)+1)
              yupw = coo_table_elemwise_d(kvoisin,3*mod((tjv+2)-1,3)+2)
              orient = (x_centroid_d(kupw2)-xupw)*(xupw-x_centroid_d(kvoisin)) + (y_centroid_d(kupw2)-yupw)*(yupw-y_centroid_d(kvoisin)) 
              ! if(kupw2>0 .and. kupw2/=kvoisin .and. orient>0.) then
              if(kupw2>0 .and. kupw2/=kvoisin) then
                ! if(kvol==6195 .and. kvoisin == 6199) print*, "R",i, kupw2
                ! if(kupw2>0 .and. kupw2/=kvoisin) then
                if(vdlg_d(1,kupw2) > tolisec_d) then
                  hr_upw = hr_upw + vdlg_d(1,kupw2)*surf_d(kupw2)
                  ur_upw = ur_upw + (vdlg_d(2,kupw2) * norm(1) + vdlg_d(3,kupw2) * norm(2))*surf_d(kupw2)/vdlg_d(1,kupw2)
                  vr_upw = vr_upw + (vdlg_d(3,kupw2) * norm(1) - vdlg_d(2,kupw2) * norm(2))*surf_d(kupw2)/vdlg_d(1,kupw2)
                end if
                kupw2_area = kupw2_area + surf_d(kupw2)
              end if
            end do

            if(kupw1_area > 1e-8) then
              hl_upw = hl_upw / kupw1_area
              ul_upw = ul_upw / kupw1_area
              vl_upw = vl_upw / kupw1_area
              ! hl_upw = (hl_upw / kupw1_area + hautl)/2.
              ! ul_upw = (ul_upw / kupw1_area + vitul)/2.
              ! vl_upw = (vl_upw / kupw1_area + vitvl)/2.
            else
              hl_upw = hautl
              ul_upw = vitul
              vl_upw = vitvl
            end if

            if(kupw2_area > 1e-8) then
              hr_upw = hr_upw / kupw2_area
              ur_upw = ur_upw / kupw2_area
              vr_upw = vr_upw / kupw2_area
              ! hr_upw = (hr_upw / kupw2_area + hautr)/2.
              ! ur_upw = (ur_upw / kupw2_area + vitur)/2.
              ! vr_upw = (vr_upw / kupw2_area + vitvr)/2.
            else
              hr_upw = hautr
              ur_upw = vitur
              vr_upw = vitvr
            end if

          end if

          call solver_Riemann_waf(gi,kvoisin,surf_d,norm,vdlg_d,hijet,vitul,vitvl,hjiet,vitur,vitvr,zml,zmr,hl_upw,ul_upw,vl_upw,hr_upw,ur_upw,vr_upw,flux,ln,pp)
        end if ! de choix schéma iflux

      endif ! de ( kvoisin > 0. )

      s1(ti, tj)   = flux(1) * ln
      call syncthreads()

      if(tj == 1)  resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
      call syncthreads()

      s1(ti, tj)   = flux(2) * ln
      call syncthreads()

      if(tj == 1)  resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
      call syncthreads()

      s1(ti, tj)   = flux(3) * ln
      call syncthreads()

      if(tj == 1)  resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)

    endif
  end subroutine cotes3

  attributes(device) subroutine limiter(r, c, A)
    use precision_kind
    use global_data_device

    implicit none

    real(fp_kind), intent(in) :: r, c 
    real(fp_kind), intent(inout) :: A

    if(ilimiteur_d==0) then
      !!Reduction to HLLC
      A =1.

    else if(ilimiteur_d==1) then

      !!!Superbee
      if(r<=0) then 
        A = 1.
      else if(r>0. .and. r<0.5) then
        A = 1.-2.*(1.-abs(c))*r
      else if(r>0.5 .and. r<1.) then
        A = abs(c)
      else if(r>1. .and. r<2.) then
        A = 1.-(1.-abs(c))*r
      else
        A = 2.*abs(c)-1.
      end if

    else if(ilimiteur_d==2) then

      !!Leer
      if(r<=0) then 
        A = 1.
      else
        A = 1-2*(1-abs(c))*r/(1+r)
      end if

    else if(ilimiteur_d==3) then

      !!ALbada
      if(r<=0) then 
        A = 1.
      else
        A = 1.-(1.-abs(c))*r*(1.+r)/(1.+r*r)
      end if

    else if(ilimiteur_d==4) then

      !!Minbee
      if(r<=0) then
        A = 1.
      else if(r<=1) then
        A = 1 - (1-abs(c))*r
      else
        A = abs(c)
      end if

    end if

  end subroutine limiter

  attributes(device) subroutine solver_Riemann_waf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,hl_upw,ul_upw,vl_upw,hr_upw,ur_upw,vr_upw,flux,ln,pp)
    ! Solveur tiré de : "Numerical Tracking of Shallow Water Waves by the Unstructured Finite Volume WAF Approximation" 
    !  Loukili et Soulaimani 2007

    use precision_kind
    use global_data_device
    implicit none

    integer, intent(in)                         :: kvol, kvoisin
    integer, intent(inout)                      :: pp
    real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
    real(fp_kind), intent(in)                   :: hl_upw, ul_upw, vl_upw, hr_upw, ur_upw, vr_upw
    real(fp_kind), dimension(2), intent(in)     :: norm
    real(fp_kind), dimension(3), intent(inout)  :: flux
    real(fp_kind), dimension(nelt_d), intent(in)     :: surf
    real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg

    integer                       :: i 
    real(fp_kind)                 :: eps
    real(fp_kind), dimension(3)   :: flux1, flux_hllc, flux_waf
    real(fp_kind), dimension(2,3) :: f, q
    real(fp_kind), dimension(3) :: fet, qet
    real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond
    real(fp_kind) :: dtoverdx, cr, cl, cet, wl, wlet, wlr, wr, wret
    real(fp_kind) :: rr, rl, ret, delta_loc_l, delta_loc_r, delta_loc_et
    real(fp_kind) :: delta_upw_r, delta_upw_l, delta_upw_et, limit_l, limit_r, limit_et

    eps = 1e-16

    pp = pp + 1

    if(hl.lt.eps.and.hr.lt.eps) goto 20

    al = sqrt( gp_d * hl )
    ar = sqrt( gp_d * hr )

    het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
    uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

    if ( het.lt.hl ) then
      pql = 1.
    else
      if(hl.gt.eps) then
        pql = sqrt(0.5*(het+hl)*het/hl**2)
      else
        pql = 0.
      end if
    endif

    if ( het.lt.hr ) then
      pqr = 1.
    else
      if(hr.gt.eps) then
        pqr = sqrt(0.5*(het+hr)*het/hr**2)
      else
        pqr = 0.
      end if
    endif

    20 continue

    if ( hl.gt.eps ) then
      sl = ul-al*pql
    else
      sl  = ur - 2 * ar
      sr  = ur + ar
      goto 35
    end if

    if ( hr.gt.eps ) then
      sr = ur+ar*pqr
    else
      sl  = ul - al
      sr  = ul + 2 * al
      goto 35
    end if

    35 continue

    denom = hr*(ur-sr)-hl*(ul-sl)
    if(abs(denom).lt.eps) then
      set = uet
    else
      set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
    end if

    !Calcul de Ql et Qr
    q(1,1) = hl
    q(1,2) = hl*ul
    q(1,3) = hl*vl

    q(2,1) = hr
    q(2,2) = hr*ur
    q(2,3) = hr*vr

    !!Cacul de G(Ul)
    f(1,1) = hl * ul
    f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
    f(1,3) = hl * ul * vl

    !!Cacul de G(Ur)
    f(2,1) = hr * ur
    f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
    f(2,3) = hr * ur * vr

    !!G(U*) 
    fet = (sr*f(1,:)-sl*f(2,:)+sl*sr*(q(2,:)-q(1,:)))/(sr-sl+eps) !!HLL classique

    !Flux HLLC
    if (sl > 0) then ! G(Ul)
      flux_hllc(:) = f(1,:)
    else if (sr < 0) then ! G(Ur)
      flux_hllc(:) = f(2,:)
    else
      flux_hllc(:) = fet(:)
      !Correction HLLC
      if(set > 0) then
        flux_hllc(3) = flux_hllc(1) * vl
      else
        flux_hllc(3) = flux_hllc(1) * vr
      end if
    endif

    dtoverdx =  1.8*dt_d/min(cotemin_arr_d(kvoisin), cotemin_arr_d(kvol)) !!cotemin_arr_d is 1.8*inscribed_circle_radius

    cr = sr * dtoverdx
    cl = sl * dtoverdx
    cet = set * dtoverdx

    !! TVD stabilization 
    delta_loc_r = hr-hl
    delta_loc_l = hr-hl
    delta_loc_et = vr-vl

    if(sr>0) then
      delta_upw_r = hl-hl_upw
    else
      delta_upw_r = hr_upw-hr
    endif

    if(sl>0) then
      delta_upw_l = hl-hl_upw
    else
      delta_upw_l = hr_upw-hr
    endif

    if(set>0) then
      delta_upw_et = vl-vl_upw
    else
      delta_upw_et = vr_upw-vr
    endif

    rl = delta_upw_l/(delta_loc_l + eps)
    rr = delta_upw_r/(delta_loc_r + eps)
    ret = delta_upw_et/(delta_loc_et + eps)

    call limiter(rl,cl,limit_l)
    call limiter(rr,cr,limit_r)
    call limiter(ret,cet,limit_et)

    wl = (1 + dsign(1.d0,sl) * limit_l)/2.
    wlet = (1 + dsign(1.d0,set) * limit_et)/2.

    wlr = (dsign(1.d0,sr)*limit_r - dsign(1.d0,sl)*limit_l)/2.

    wr = (1 - dsign(1.d0,sr) * limit_r)/2.
    wret = (1 - dsign(1.d0,set) * limit_et)/2.

    flux_waf(1) = wl*f(1,1) + wlr*flux_hllc(1) + wr*f(2,1)
    flux_waf(2) = wl*f(1,2) + wlr*flux_hllc(2) + wr*f(2,2)
    flux_waf(3) = (wlet*vl + wret*vr)*flux_waf(1)

    ! *** reprojection du flux ***
    flux(1) = flux_waf(1)
    flux(2) = norm(1)*flux_waf(2) - norm(2)*flux_waf(3)
    flux(3) = norm(2)*flux_waf(2) + norm(1)*flux_waf(3)                       
  end subroutine solver_Riemann_waf

  attributes(device) subroutine solver_Riemann_hllc(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
    ! HLLC classique
    ! Solveur tiré de : "Numerical Tracking of Shallow Water Waves by the Unstructured Finite Volume WAF Approximation" 
    !  Loukili et Soulaimani 2007

    use precision_kind
    use global_data_device
    implicit none

    integer, intent(in)                         :: kvol, kvoisin
    integer, intent(inout)                      :: pp
    real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
    real(fp_kind), dimension(2), intent(in)     :: norm
    real(fp_kind), dimension(3), intent(inout)  :: flux
    real(fp_kind), dimension(nelt_d), intent(in)     :: surf
    real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg

    integer                       :: i 
    real(fp_kind)                 :: eps
    real(fp_kind), dimension(3)   :: flux1, flux_hllc
    real(fp_kind), dimension(2,3) :: f, q
    real(fp_kind), dimension(3) :: fet, qet
    real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond

    eps = 1e-8

    pp = pp + 1

    if(hl.lt.eps.and.hr.lt.eps) goto 20

    al = sqrt( gp_d * hl )
    ar = sqrt( gp_d * hr )

    het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
    uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

    if ( het.lt.hl ) then
      pql = 1.
    else
      if(hl.gt.eps) then
        pql = sqrt(0.5*(het+hl)*het/hl**2)
      else
        pql = 0.
      end if
    endif

    if ( het.lt.hr ) then
      pqr = 1.
    else
      if(hr.gt.eps) then
        pqr = sqrt(0.5*(het+hr)*het/hr**2)
      else
        pqr = 0.
      end if
    endif

    20 continue

    if ( hl.gt.eps ) then
      sl = ul-al*pql
    else
      sl  = ur - 2 * ar
      sr  = ur + ar
      goto 35
    end if

    if ( hr.gt.eps ) then
      sr = ur+ar*pqr
    else
      sl  = ul - al
      sr  = ul + 2 * al
      goto 35
    end if

    35 continue

    denom = hr*(ur-sr)-hl*(ul-sl)
    if(abs(denom).lt.eps) then
      set = uet
    else
      set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
    end if

    !Calcul de Ql et Qr
    q(1,1) = hl
    q(1,2) = hl*ul
    q(1,3) = hl*vl

    q(2,1) = hr
    q(2,2) = hr*ur
    q(2,3) = hr*vr

    !!Cacul de G(Ul)
    f(1,1) = hl * ul
    f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
    f(1,3) = hl * ul * vl

    !!Cacul de G(Ur)
    f(2,1) = hr * ur
    f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
    f(2,3) = hr * ur * vr

    !!G(U*) 
    fet = (sr*f(1,:)-sl*f(2,:)+sl*sr*(q(2,:)-q(1,:)))/(sr-sl+eps) !!HLL classique

    !Flux HLLC
    if (sl > 0) then ! G(Ul)
      flux_hllc(:) = f(1,:)
    else if (sr < 0) then ! G(Ur)
      flux_hllc(:) = f(2,:)
    else
      flux_hllc(:) = fet(:)
      !Correction HLLC
      if(set > 0) then
        flux_hllc(3) = flux_hllc(1) * vl
      else
        flux_hllc(3) = flux_hllc(1) * vr
      end if
    endif

    flux(1) = flux_hllc(1)
    flux(2) = norm(1) * flux_hllc(2) - norm(2) * flux_hllc(3)
    flux(3) = norm(2) * flux_hllc(2) + norm(1) * flux_hllc(3)                       
  end subroutine solver_Riemann_hllc


  attributes(device) subroutine solver_Riemann_riadh(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,flux,ln,pp)
    ! Import des routines de Riadh ATA pour HLLC
    ! Méthode de l'article : 
    ! A Weighted Average Flux (WAF) scheme applied to shallow waterequations for real-life applications
    ! Riadh ATA et al.
    use precision_kind
    use global_data_device
    implicit none

    integer, intent(in)                         :: kvol, kvoisin
    integer, intent(inout)                      :: pp
    real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
    real(fp_kind), dimension(2), intent(in)     :: norm
    real(fp_kind), dimension(3), intent(inout)  :: flux
    real(fp_kind), dimension(nelt_d), intent(in)     :: surf
    real(fp_kind), dimension(ndln_d,nelt_d), intent(in)   :: vdlg

    integer                       :: i 
    real(fp_kind)                 :: eps
    real(fp_kind), dimension(3)   :: flux1
    real(fp_kind), dimension(2,3) :: f, q, fet, qet
    real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr, uet, pql, pqr, denom, pond

    eps = 1e-6

    pp = pp + 1

    if(hl.lt.eps.and.hr.lt.eps) goto 20

    al = sqrt( gp_d * hl )
    ar = sqrt( gp_d * hr )

    het  =  ( hl + hr ) / 2.  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4.
    uet  =  ( ul + ur ) / 2.  -  ( hr - hl ) * ( al + ar ) / ( hl + hr ) 

    if ( het.lt.hl ) then
      pql = 1.
    else
      if(hl.gt.eps) then
        pql = sqrt(0.5*(het+hl)*het/hl**2)
      else
        pql = 0.
      end if
    endif

    if ( het.lt.hr ) then
      pqr = 1.
    else
      if(hr.gt.eps) then
        pqr = sqrt(0.5*(het+hr)*het/hr**2)
      else
        pqr = 0.
      end if
    endif

    20 continue

    if ( hl.gt.eps ) then
      sl = ul-al*pql
    else
      sl  = ur - 2 * ar
      sr  = ur + ar
      goto 35
    end if

    if ( hr.gt.eps ) then
      sr = ur+ar*pqr
    else
      sl  = ul - al
      sr  = ul + 2 * al
      goto 35
    end if

    35 continue

    denom = hr*(ur-sr)-hl*(ul-sl)
    if(abs(denom).lt.eps) then
      set = uet
    else
      set = (sl*hr*(ur-sr) -sr*hl*(ul-sl))/denom
    end if

    !Calcul de Ql et Qr (Riadh)
    q(1,1) = hl
    q(1,2) = hl*ul
    q(1,3) = hl*vl

    q(2,1) = hr
    q(2,2) = hr*ur
    q(2,3) = hr*vr

    !!Calcul de Qetl et Qetr
    if(abs(sl-set).gt.eps) then
      pond = hl*(sl-ul)/(sl-set)
    else
      pond= 0.D0
    End if

    qet(1,1) = pond
    qet(1,2) = pond*set
    qet(1,3) = pond*vl


    if(abs(sr-set).gt.eps) then
      pond = hr*(sr-ur)/(sr-set)
    else
      pond= 0.D0
    end if

    qet(2,1) = pond
    qet(2,2) = pond*set
    qet(2,3) = pond*vr

    !!Cacul de G(Ul)
    f(1,1) = hl * ul
    f(1,2) = hl * ul**2 + gp_d*hl*hl/2.0D0
    f(1,3) = hl * ul * vl

    !!Cacul de G(Ur)
    f(2,1) = hr * ur
    f(2,2) = hr * ur**2 + gp_d*hr*hr/2.0D0
    f(2,3) = hr * ur * vr

    fet(1,1) = f(1,1) + sl*(qet(1,1)-q(1,1))
    fet(1,2) = f(1,2) + sl*(qet(1,2)-q(1,2))
    fet(1,3) = f(1,3) + sl*(qet(1,3)-q(1,3))

    fet(2,1) = f(2,1) + sr*(qet(2,1)-q(2,1))
    fet(2,2) = f(2,2) + sr*(qet(2,2)-q(2,2))
    fet(2,3) = f(2,3) + sr*(qet(2,3)-q(2,3))

    !Flux HLLC
    if (0.lt.sl) then
      flux1(1) = f(1,1)
      flux1(2) = f(1,2)
      flux1(3) = f(1,3)
    elseif (0.lt.set.and.0.gt.sl) then
      flux1(1) = fet(1,1)
      flux1(2) = fet(1,2)
      flux1(3) = fet(1,3)
    elseif (0.gt.set.and.0.lt.sr) then
      flux1(1) = fet(2,1)
      flux1(2) = fet(2,2)
      flux1(3) = fet(2,3)
    else
      flux1(1) = f(2,1)
      flux1(2) = f(2,2)
      flux1(3) = f(2,3)
    endif

    ! *** reprojection du flux ***
    flux(1) = flux1(1)
    flux(2) = norm(1) * flux1(2) - norm(2) * flux1(3)
    flux(3) = norm(2) * flux1(2) + norm(1) * flux1(3)                       
  end subroutine solver_Riemann_riadh
end module flux_riemann
