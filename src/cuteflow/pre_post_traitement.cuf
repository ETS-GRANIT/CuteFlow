module pre_post_traitement
  implicit none
contains

  subroutine global_save_sol_visu
    use precision_kind
    use global_data
    use global_data_device
    use file_id
    implicit none

    integer :: ierr

    tblock_nodes = dim3(32, 1, 1)
    grid_nodes   = dim3(ceiling(real(nnt)/real(tblock%x)), 1, 1)

    ! *** Stockage de la solution pour postraitement et animation 
    if((solvisu > 0 .and. abs( tc - tsolvisu(cptsolvisu) ) <= tolaffiche))then
      vdlg = vdlg_d

      !Praview EXPORT
      if(solvisu==1 .or. solvisu==2) then
        call paraview_export(cptsolvisu)
      end if

      !CGNS EXPORT
      if(is_cgns==1 .and. (solvisu==1 .or. solvisu==3)) then
        call cgns_export(cptsolvisu)
        call update_sol_nodes<<<grid_nodes, tblock_nodes>>> 
        call cgns_nodes_export(cptsolvisu)
      end if

      !Simple EXPORT
      if(solvisu==1 .or. solvisu==4) then
        if(.not. is_solnode) then
          vdlg_nodes = 0.
          call compute_sol_on_nodes
          is_solnode = .TRUE.
        end if
        call simple_export(cptsolvisu)
      end if

      cptsolvisu = cptsolvisu + 1

      ! call save_sol_for_restart
    endif

  end subroutine global_save_sol_visu

  subroutine compute_sol_on_nodes
    use precision_kind
    use global_data

    real(fp_kind), dimension(nnt) :: area
    integer :: i, j, jj

    area = 0.

    do i=1,nelt
      do j=1,ndln
        jj = connectivite(i,j)
        vdlg_nodes(:,jj) = vdlg_nodes(:,jj) + vdlg(:,i)*surf(i)
        area(jj) = area(jj) + surf(i)
      end do
    end do

    do jj=1,nnt
        vdlg_nodes(:,jj) = vdlg_nodes(:,jj)/area(jj)
    end do
  end subroutine compute_sol_on_nodes

  subroutine ouv_fichiers
    use precision_kind
    use global_data
    use file_id
    implicit none

    if(num_mpi_process>1) then
      sol_elt_ts = trim(adjustl(mpi_process_id_string))//trim(adjustl('_solution_elements_restart.txt'))
    else
      sol_elt_ts = trim(adjustl('solution_elements_restart.txt'))
    end if

    if(solrestart==1) then
      open(ec_sol_elt_t, file=sol_elt_ts, status="unknown")
    endif
  end subroutine ouv_fichiers

  subroutine bluekenue_export
    ! =================================================================================
    !     bluekenue_export == Exporte dans un fichier pour postraitement avec Bluekenue
    !     auteur : Zokagoa Jean-Marie  GRANIT ETSMTL
    !     version : 2.0  ;  mai 31 2010
    ! =================================================================================

    use precision_kind
    use global_data
    use file_id

    implicit none

    integer :: nd, iel
    real(fp_kind) :: solu, solv

    write(valtemps,'(f12.3)') tc 

    if(num_mpi_process>1) then
      solfile_eta_T3S = trim(adjustl(mpi_process_id_string)) // '_solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_h_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_u_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_v_T3S   = trim(adjustl(mpi_process_id_string)) //   '_solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    else
      solfile_eta_T3S = 'solution-ETA-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_h_T3S   = 'solution-H-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_u_T3S   = 'solution-U-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
      solfile_v_T3S   = 'solution-V-Bluekenue_t_'// trim(adjustl(valtemps)) // 's.T3S'
    end if

    open(unit=ec_Bluekenu_eta,file=solfile_ETA_T3S,status="unknown")
    open(unit=ec_Bluekenu_h,file=solfile_H_T3S,    status="unknown")
    open(unit=ec_Bluekenu_u,file=solfile_U_T3S,    status="unknown")
    open(unit=ec_Bluekenu_v,file=solfile_V_T3S,    status="unknown")

    write(ec_Bluekenu_eta,*) ':NodeCount', nnt
    write(ec_Bluekenu_eta,*) ':ElementCount', nelt
    write(ec_Bluekenu_eta,*) ':ElementType  T3'
    write(ec_Bluekenu_eta,*) ':EndHeader'

    write(ec_Bluekenu_h,*) ':NodeCount', nnt
    write(ec_Bluekenu_h,*) ':ElementCount', nelt
    write(ec_Bluekenu_h,*) ':ElementType  T3'
    write(ec_Bluekenu_h,*) ':EndHeader'

    write(ec_Bluekenu_u,*) ':NodeCount', nnt
    write(ec_Bluekenu_u,*) ':ElementCount', nelt
    write(ec_Bluekenu_u,*) ':ElementType  T3'
    write(ec_Bluekenu_u,*) ':EndHeader'

    write(ec_Bluekenu_v,*) ':NodeCount', nnt
    write(ec_Bluekenu_v,*) ':ElementCount', nelt
    write(ec_Bluekenu_v,*) ':ElementType  T3'
    write(ec_Bluekenu_v,*) ':EndHeader'

    do nd=1, nnt
      if ( vdlg_nodes(1,nd) > tolisec ) then
        solu = vdlg_nodes(2,nd)/vdlg_nodes(1,nd)
        solv = vdlg_nodes(3,nd)/vdlg_nodes(1,nd)
      else
        solu = 0.d0
        solv = 0.d0
      endif
      write(ec_Bluekenu_eta,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), vdlg_nodes(1,nd)+coordonnees(nd,3)-sol_z_offset
      write(ec_Bluekenu_h,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), vdlg_nodes(1,nd)
      write(ec_Bluekenu_u,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solu
      write(ec_Bluekenu_v,'(3f16.6)')   coordonnees(nd,1), coordonnees(nd,2), solv
    enddo

    do iel=1, nelt
      write(ec_Bluekenu_eta,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_h,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_u,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
      write(ec_Bluekenu_v,*) connectivite(iel,1) , connectivite(iel,2) , connectivite(iel,3)
    enddo

    close(ec_Bluekenu_eta)
    close(ec_Bluekenu_h)
    close(ec_Bluekenu_u)
    close(ec_Bluekenu_v)

  end subroutine bluekenue_export

  subroutine simple_export(ci)

    use precision_kind
    use global_data
    use file_id

    implicit none

    integer, intent(in) :: ci
    integer :: nd, iel, i

    write(valtemps,'(I20)') ci

    if(solvisu==4 .or. solvisu==1) then 
      if(num_mpi_process>1) then
        solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      else
        solfile_simple = 'solution_noeuds_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      end if
      open(unit=ec_sol_simple,file=solfile_simple,status="unknown")
      write(ec_sol_simple,*) tc                        
      do nd=1,nnt
        write(ec_sol_simple,'(4f16.6)') vdlg_nodes(1,nd), vdlg_nodes(1,nd)+coordonnees(nd,3)-sol_z_offset, vdlg_nodes(2,nd), vdlg_nodes(3,nd)
      end do
      close(ec_sol_simple)
    end if

    if(solvisu==5 .or. solvisu==1) then 
      if(num_mpi_process>1) then
        solfile_simple = trim(adjustl(trim(mpi_process_id_string)))//'_solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      else
        solfile_simple = 'solution_elements_simple_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.txt'))
      end if
      open(unit=ec_sol_simple,file=solfile_simple,status="unknown")
      write(ec_sol_simple,*) tc                        
      do iel=1,nelt
        write(ec_sol_simple,'(4f16.6)') vdlg(1,iel), vdlg(1,iel)+zm(iel)-sol_z_offset, vdlg(2,iel), vdlg(3,iel)
      end do
      close(ec_sol_simple)
    end if
  end subroutine simple_export

  subroutine cgns_nodes_export(it)
    use global_data
    use precision_kind
    use file_id
    use cgns

    implicit none 

    integer, intent(in) :: it

    integer :: my_zone, sol
    integer :: ierr, fn, n_bases, base, cellDim, physDim, n_zones, zone, zoneType, sizes(3*3), ord, i
    integer :: field_wd, field_vx, field_vy, field_vz, field_mx, field_my, field_mz, field_b, field_fs
    integer, dimension(2) :: idata
    character(200) :: basename, zonename

    !!Read cgns file and goto good location
    call cgp_pio_mode_f(0, ierr)

    call cgp_open_f(meshfile_nodes, CG_MODE_MODIFY, fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cg_nbases_f(fn, n_bases, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f
    base = 1

    call cg_base_read_f(fn, base, basename, cellDim, physDim, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    call cg_nzones_f(fn, base, n_zones, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    do zone=1,n_zones
      call cg_zone_type_f(fn, base, zone, zoneType, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_zone_read_f(fn, base, zone, zonename, sizes, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_goto_f(fn, base, ierr, trim(adjustl(zonename)), 0, "end")
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_ordinal_read_f(ord, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      if(ord == mpi_process_id) then
        exit
      end if
    end do

    my_zone = zone

    if(it==0) then
      call cg_biter_write_f(fn, base, 'TimeIterValues', visu_snapshots+1, ierr)
      call cg_goto_f(fn, base, ierr,'BaseIterativeData_t',1,'end')
      !!RealDouble = 4
      call cg_array_write_f('TimeValues',4,1,visu_snapshots+1,tsolvisu(0:),ierr)

      do zone=1,n_zones
        call cg_ziter_write_f(fn,base,zone,'ZoneIterativeData',ierr)
        call cg_goto_f(fn,base,ierr,'Zone_t',zone,'ZoneIterativeData_t',1,'end')
        idata(1)=32
        idata(2)=visu_snapshots+1
        !!Character = 5
        call cg_array_write_f('FlowSolutionPointers',5,2,idata,solname_visu(0:),ierr)
      end do
    end if

    do zone=1,n_zones
      !!!Vertex = 2
      !!!Cellcenter = 3
      call cg_sol_write_f(fn, base, zone, solname_visu(it), 2, sol, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      !!RealDouble = 4
      call cgp_field_write_f(fn, base, zone, sol, 4, 'Water Depth', field_wd, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'Bathymetry', field_b, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'Free surface elevation', field_fs, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumX', field_mx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumY', field_my, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumZ', field_mz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityX', field_vx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityY', field_vy, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityZ', field_vz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f
    end do

    zone = my_zone

    !!Not on gpu to save gpu memory
    do i=1,nnt
      vdlg_visu_nodes(i,1) = vdlg_nodes(1,i)

      vdlg_visu_nodes(i,2) = vdlg_nodes(2,i)
      vdlg_visu_nodes(i,3) = vdlg_nodes(3,i)
      vdlg_visu_nodes(i,4) = 0.

      if(vdlg_visu_nodes(i,1) > tolisec) then
        vdlg_visu_nodes(i,5) = vdlg_nodes(2,i)/vdlg_nodes(1,i)
        vdlg_visu_nodes(i,6) = vdlg_nodes(3,i)/vdlg_nodes(1,i)
        vdlg_visu_nodes(i,7) = 0.
      else 
        vdlg_visu_nodes(i,5) = 0.
        vdlg_visu_nodes(i,6) = 0.
        vdlg_visu_nodes(i,7) = 0.
      end if

      vdlg_visu_nodes(i,8) = vdlg_nodes(1,i) + coordonnees(i,3) - sol_z_offset
    end do

    call cgp_field_write_data_f(fn, base, zone, sol, field_wd, 1, nnt,  vdlg_visu_nodes(1,1), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_b, 1, nnt,  coordonnees(1,3), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_fs, 1, nnt,  vdlg_visu_nodes(1,8), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_mx, 1, nnt,  vdlg_visu_nodes(1,2), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_my, 1, nnt,  vdlg_visu_nodes(1,3), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_mz, 1, nnt,  vdlg_visu_nodes(1,4), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vx, 1, nnt,  vdlg_visu_nodes(1,5), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vy, 1, nnt,  vdlg_visu_nodes(1,6), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vz, 1, nnt,  vdlg_visu_nodes(1,7), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_close_f(fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

  end subroutine cgns_nodes_export

  subroutine cgns_export(it)
    use global_data
    use precision_kind
    use file_id
    use cgns

    implicit none 

    integer, intent(in) :: it

    integer :: my_zone, sol
    integer :: ierr, fn, n_bases, base, cellDim, physDim, n_zones, zone, zoneType, sizes(3*3), ord, i
    integer :: field_wd, field_vx, field_vy, field_vz, field_mx, field_my, field_mz, field_b, field_fs
    integer, dimension(2) :: idata
    character(200) :: basename, zonename

    !!Read cgns file and goto good location
    call cgp_pio_mode_f(0, ierr)

    call cgp_open_f(meshfile, CG_MODE_MODIFY, fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cg_nbases_f(fn, n_bases, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f
    base = 1

    call cg_base_read_f(fn, base, basename, cellDim, physDim, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    call cg_nzones_f(fn, base, n_zones, ierr)
    if (ierr .ne. CG_OK) call cg_error_exit_f

    do zone=1,n_zones
      call cg_zone_type_f(fn, base, zone, zoneType, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_zone_read_f(fn, base, zone, zonename, sizes, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_goto_f(fn, base, ierr, trim(adjustl(zonename)), 0, "end")
      if (ierr .ne. CG_OK) call cg_error_exit_f

      call cg_ordinal_read_f(ord, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      if(ord == mpi_process_id) then
        exit
      end if
    end do

    my_zone = zone

    if(it==0) then
      call cg_biter_write_f(fn, base, 'TimeIterValues', visu_snapshots+1, ierr)
      call cg_goto_f(fn, base, ierr,'BaseIterativeData_t',1,'end')
      !!RealDouble = 4
      call cg_array_write_f('TimeValues',4,1,visu_snapshots+1,tsolvisu(0:),ierr)

      do zone=1,n_zones
        call cg_ziter_write_f(fn,base,zone,'ZoneIterativeData',ierr)
        call cg_goto_f(fn,base,ierr,'Zone_t',zone,'ZoneIterativeData_t',1,'end')
        idata(1)=32
        idata(2)=visu_snapshots+1
        !!Character = 5
        call cg_array_write_f('FlowSolutionPointers',5,2,idata,solname_visu(0:),ierr)
      end do
    end if

    do zone=1,n_zones
      !!!Vertex = 2
      !!!Cellcenter = 3
      call cg_sol_write_f(fn, base, zone, solname_visu(it), 3, sol, ierr)
      if (ierr .ne. CG_OK) call cg_error_exit_f

      !!RealDouble = 4
      call cgp_field_write_f(fn, base, zone, sol, 4, 'Water Depth', field_wd, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'Bathymetry', field_b, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'Free surface elevation', field_fs, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumX', field_mx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumY', field_my, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'MomentumZ', field_mz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityX', field_vx, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityY', field_vy, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f

      call cgp_field_write_f(fn, base, zone, sol, 4, 'VelocityZ', field_vz, ierr)
      if (ierr .ne. CG_OK) call cgp_error_exit_f
    end do

    zone = my_zone

    !!Not on gpu to save gpu memory
    do i=1,nelt
      vdlg_visu(i,1) = vdlg(1,i)

      vdlg_visu(i,2) = vdlg(2,i)
      vdlg_visu(i,3) = vdlg(3,i)
      vdlg_visu(i,4) = 0.

      if(vdlg_visu(i,1) > tolisec) then
        vdlg_visu(i,5) = vdlg(2,i)/vdlg(1,i)
        vdlg_visu(i,6) = vdlg(3,i)/vdlg(1,i)
        vdlg_visu(i,7) = 0.
      else 
        vdlg_visu(i,5) = 0.
        vdlg_visu(i,6) = 0.
        vdlg_visu(i,7) = 0.
      end if

      vdlg_visu(i,8) = vdlg(1,i) + zm(i) - sol_z_offset
    end do

    call cgp_field_write_data_f(fn, base, zone, sol, field_wd, 1, nelt,  vdlg_visu(1,1), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_b, 1, nelt,  zm, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_fs, 1, nelt,  vdlg_visu(1,8), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_mx, 1, nelt,  vdlg_visu(1,2), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_my, 1, nelt,  vdlg_visu(1,3), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_mz, 1, nelt,  vdlg_visu(1,4), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vx, 1, nelt,  vdlg_visu(1,5), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vy, 1, nelt,  vdlg_visu(1,6), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_field_write_data_f(fn, base, zone, sol, field_vz, 1, nelt,  vdlg_visu(1,7), ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

    call cgp_close_f(fn, ierr)
    if (ierr .ne. CG_OK) call cgp_error_exit_f

  end subroutine cgns_export

  subroutine paraview_export(ci)
    ! ==============================================================================
    !     paraview_export == Exporte dans un fichier vtk pour postraitement avec paraview
    !     auteur : Delmas Vincent
    !     version : 2.0  ;  july 31 2019
    ! ==============================================================================

    use precision_kind
    use global_data
    use file_id

    implicit none

    integer, intent(in) :: ci

    integer :: nd, iel
    real(fp_kind) :: solu, solv

    write(valtemps,'(I20)') ci

    solfile_para = trim(adjustl(trim(mpi_process_id_string)))//'_solution-Paraview_'//trim(adjustl(trim(valtemps)))//adjustl(trim('.vtk'))

    open(unit=ec_Paraview,file=solfile_para,status="unknown")

    write(ec_Paraview,'(a)') "# vtk DataFile Version 1.0"
    write(ec_Paraview,'(a)') "2D Unstructured Grid"
    write(ec_Paraview,'(a)') "ASCII"
    write(ec_Paraview,'(a)') ""

    write(ec_Paraview,'(a)') "DATASET UNSTRUCTURED_GRID"
    write(ec_Paraview,'(a,I10,a)') "POINTS", nnt, " float"

    do nd=1, nnt
      write(ec_Paraview,'(3f16.6)') coordonnees(nd,1), coordonnees(nd,2), 0.
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10,I10)') "CELLS", nelt, 4*nelt
    do iel=1, nelt
      write(ec_Paraview,'(I1,3I10)') 3, connectivite(iel,1)-1, connectivite(iel,2)-1, connectivite(iel,3)-1
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10)') "CELL_TYPES", nelt
    do iel=1, nelt
      write(ec_Paraview,'(a)') "5"
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a,I10)') "CELL_DATA", nelt
    write(ec_Paraview,'(a)') "SCALARS eta float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') vdlg(1,iel)+zm(iel)-sol_z_offset
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "SCALARS h float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') vdlg(1,iel)
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "SCALARS b float"
    write(ec_Paraview,'(a)') "LOOKUP_TABLE default"
    do iel=1, nelt
      write(ec_Paraview,'(f16.6)') zm(iel)-sol_z_offset
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "VECTORS velocity float"
    do iel=1, nelt
      if ( vdlg(1,iel) > tolisec ) then
        solu = vdlg(2,iel)/vdlg(1,iel)
        solv = vdlg(3,iel)/vdlg(1,iel)
      else
        solu = 0.d0
        solv = 0.d0
      endif
      write(ec_Paraview,'(3f16.6)')   solu, solv, 0.
    end do

    write(ec_Paraview,'(a)') ""
    write(ec_Paraview,'(a)') "VECTORS flux float"
    do iel=1, nelt
      if ( vdlg(1,iel) > tolisec ) then
        write(ec_Paraview,'(3f16.6)')   vdlg(2,iel), vdlg(3,iel), 0.
      else
        write(ec_Paraview,'(3f16.6)')   0., 0., 0.
      endif
    end do

    close(ec_Paraview)

  end subroutine paraview_export

  subroutine save_sol_for_restart
    use global_data
    use file_id
    implicit none

    integer :: iel

    write(ec_sol_elt_t,*) tc                        

    do iel=1,nelt
      write(ec_sol_elt_t,'(4f16.6)') vdlg(1,iel), vdlg(2,iel), vdlg(3,iel)
    enddo

    rewind (ec_sol_elt_t)
  end subroutine save_sol_for_restart

  attributes(global) subroutine update_sol_nodes
    use precision_kind
    use global_data_device

    implicit none

    integer :: ti, gi

    integer :: mgi, k
    real(fp_kind) :: area=0.

    ti = threadIdx%x
    gi = (blockIdx%x - 1)*blockDim%x + ti

    if(gi <= nnt_d) then
      do k=1,6
        mgi = vertex_neighbors_d(k,gi)
        if(mgi > 0) then
          vdlg_nodes_d(:,gi) = vdlg_d(:,mgi)*surf_d(mgi)
          area = area +surf_d(mgi)
        end if
      end do
      vdlg_nodes_d(:,gi) = vdlg_nodes_d(:,gi)/area
    end if
  end subroutine update_sol_nodes
end module pre_post_traitement
