attributes(global) subroutine cotes_cudaf3(surf_d, zm_d,gradz_d,vdlg_d)
  ! ======================================================================
  !     cotes = calcul du flux à l'interface des cotes de kvol
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine solver_Riemann_cudaf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)

      use global_device

      implicit none

      integer, intent(in)                   :: kvol, kvoisin, model
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(:), intent(in)     :: surf
      real(fp_kind), dimension(:,:), intent(in)   :: vdlg
    end subroutine solver_Riemann_cudaf

  end interface

  real(fp_kind), dimension(:), intent(in)      :: surf_d, zm_d
  real(fp_kind), dimension(:,:), intent(in)    :: gradz_d  ! remove it if not used
  real(fp_kind), dimension(:,:), intent(in)    :: vdlg_d

  integer               :: i, nc1, nc2, kvoisin, dl,pp, hybrid, model, nc3
  real(fp_kind)               :: x1, x2, y1, y2, ln, x3, y3
  real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr
  real(fp_kind)               :: zero, debitnorm, orient
  real(fp_kind), dimension(2) :: norm
  real(fp_kind), dimension(3) :: flux
  integer                     :: ti,gi, tj, gj, id_entree
  real                        :: cond
  real(fp_kind), shared       :: s1(64,3)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti
  tj = threadIdx%y
  gj=  (blockIdx%y - 1)*blockDim%y + tj

  zero = 0.d0
  hybrid = 0

  !   Retrieve a neighboring cell dry ===============================
  ! do it outside and see if un_voisin_sec is being used here    

  if(gi <= nelt_d-nelt_fant_recep_d) then
    nc1 = tj
    cond = merge(1,0, nc1 == ns_d)
    nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))
    cond = merge(1,0, nc2 == ns_d)
    nc3 = int((nc2 - ns_d + 1)*cond + (nc2 + 1)*(1-cond))

    x1 = coo_table_elemwise_d(gi, 3*nc1-2)
    y1 = coo_table_elemwise_d(gi, 3*nc1-1)

    x2 = coo_table_elemwise_d(gi, 3*nc2-2)
    y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

    x3 = coo_table_elemwise_d(gi, 3*nc3-2)
    y3 = coo_table_elemwise_d(gi, 3*nc3-1) 

    ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

    norm(1) = ( y2 - y1 ) / ln
    norm(2) = ( x1 - x2 ) / ln

    orient = norm(1)*((x1+x2)/2.-(x1+x2+x3)/3.) + norm(2)*((y1+y2)/2.-(y1+y2+y3)/3.)
    if(orient < 0.) then
      norm(1) = ( y1 - y2 ) / ln
      norm(2) = ( x2 - x1 ) / ln
    end if

    ! *** initialisation du flux ***
    flux     = 0.d0
    kvoisin = boundary_d(gi,nc1,1)
    id_entree = boundary_d(gi,nc1,2)

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(1,gi)
      s1(ti,2) = zm_d(gi)
    endif

    call syncthreads()

    hautl  = s1(ti,1)
    zml    = s1(ti,2)

    call syncthreads()

    if ( hautl> tolisec_d ) then
      if(nc1 == 1) then 
        s1(ti,1) = vdlg_d(2,gi)
        s1(ti,2) = vdlg_d(3,gi)
      endif

      call syncthreads()

      hul    = s1(ti,1)
      hvl    = s1(ti,2)

      vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
      vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl
    else
      hautl = tolisec_d
      vitul = 0.d0
      vitvl = 0.d0
    endif

    ! *** application des conditions aux limites si kvol est frontier ***
    if ( kvoisin == -1 ) then ! *** flux entrant ***
      if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
        if (test_d==5) hautl = 1 + 0.75*cos(2*3.14159265358979*tc_d/3600)
        if ( hautl > tolisec_d ) then
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        endif

      elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
        if ( hautl > tolisec_d ) then
          debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
          flux(1) = debitnorm
          flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
          flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
          debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
          debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
        else
          hautl = tolisec_d             
          flux(1) = 0.d0
          flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
          flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
        endif
      else
        write(*,*) 'donnee inlet_d non convenable'
      endif
    endif

    if ( kvoisin == -2 ) then ! *** flux sortant ***
      if ( hautl > tolisec_d ) then
        if ( vitul > 0.d0 .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
          hautl = h_sortie_d(id_entree) - zml
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        else if ( vitul < 0.d0 .and. -vitul/sqrt(gp_d*hautl) > 1.d0 ) then
          hautl = h_sortie_d(id_entree) - zml
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        else
          flux(1) = 0.d0
          flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
          flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
        endif
      else
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
      end if

      debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln
    endif

    if ( kvoisin == -3 ) then  ! *** flux de mur ***
      if (hautl > tolisec_d) then
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
      else
        flux(1) = 0.d0
        flux(2) = 0.d0
        flux(3) = 0.d0
      endif
    endif

    if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
      hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
      zmr = zm_d(kvoisin)        !this is also inefficient global memory access

      if ( hautr > tolisec_d ) then
        hur    = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
        hvr    = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

        vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
        vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr
      else
        hautr = tolisec_d
        vitur = 0.d0
        vitvr = 0.d0
        hybrid = 0
      endif

      call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)

      ! *** WET and DRY
      ! *** Prolongement du niveau d'eau sur le sec pour éviter la création d'un gradient
      if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zmr > hautl+zml ) then
          !Transitoire : Cellule calculée mouillée - Cellule voisine sèche ***
          if ( vitul > sqrt(2*gp_d*(zmr-zml) ) ) then
            zmr = zml+hautl  
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
            flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
          endif
        endif   ! de if( zmr > hautl+zml ) then

      elseif( hautl <= tolisec_d .and. hautr > tolisec_d ) then  ! de if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zml >= hautr+zmr ) then 
          !Transitoire : Cellule calculée sèche  - Cellule voisine mouillée 
          if ( -vitur > sqrt(2*gp_d*(zml-zmr) ) .and. vitur < 0) then
            zml   = zmr+hautr
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = 0.d0
            flux(3) = 0.d0
          endif
        endif ! de if( zml >= hautr+zmr ) then
      endif   ! (hautr <= tolisec_d .and. hautl > tolisec_d) then

      ! Cas de deux éléments voisins secs
      if (test_d /=1) then  ! Necessaire dans la cas de la prairie
        if (hautl <= tolisec_d .and. hautr <= tolisec_d) then
          flux(1) = 0.d0
          flux(2) = 0.d0
          flux(3) = 0.d0
        endif
      endif
      ! Sommation des flux d'interface
      ! flux_interface = flux_interface + flux*ln
    endif ! de ( kvoisin > 0. )

    s1(ti, tj)   = flux(1) * ln
    call syncthreads()

    if(tj == 1)  resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(2) * ln
    call syncthreads()

    if(tj == 1)  resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)
    call syncthreads()

    s1(ti, tj)   = flux(3) * ln
    call syncthreads()

    if(tj == 1)  resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3)

  endif ! Fin de if(gi<nelt_d) 
end subroutine cotes_cudaf3

attributes(global) subroutine cotes_cudaf4(surf_d, zm_d,gradz_d,vdlg_d)
  ! ======================================================================
  !     cotes = calcul du flux à l'interface des cotes de kvol
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine solver_Riemann_cudaf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)

      use global_device

      implicit none

      integer, intent(in)                   :: kvol, kvoisin, model
      integer, intent(inout)                :: pp
      real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
      real(fp_kind), dimension(2), intent(in)     :: norm
      real(fp_kind), dimension(3), intent(inout)  :: flux
      real(fp_kind), dimension(:), intent(in)     :: surf
      real(fp_kind), dimension(:,:), intent(in)   :: vdlg
    end subroutine solver_Riemann_cudaf

  end interface

  real(fp_kind), dimension(:), intent(in)      :: surf_d, zm_d
  real(fp_kind), dimension(:,:), intent(in)    :: gradz_d  ! remove it if not used
  real(fp_kind), dimension(:,:), intent(in)    :: vdlg_d

  ! local variables  !remove variables which are not in use, they eat up registers and leads to less no. of concurrent blocks per SM
  integer               :: i, nc1, nc2, kvoisin, dl,pp, hybrid, model, id_entree
  real(fp_kind)               :: x1, x2, y1, y2, ln 
  real(fp_kind)               :: hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hul, hvl, hur, hvr
  real(fp_kind)               :: zero, debitnorm
  real(fp_kind), dimension(2) :: norm
  real(fp_kind), dimension(3) :: flux
  integer                     :: ti,gi, tj, gj
  real                        :: cond
  real(fp_kind), shared       :: s1(64,4)

  ti = threadIdx%x
  gi = (blockIdx%x - 1)*blockDim%x + ti
  tj = threadIdx%y
  gj=  (blockIdx%y - 1)*blockDim%y + tj

  zero = 0.d0
  hybrid = 0

  if(gi <= nelt_d-nelt_fant_recep_d) then
    nc1 = tj
    cond = merge(1,0, nc1 == ns_d)
    nc2 = int((nc1 - ns_d + 1)*cond + (nc1 + 1)*(1-cond))

    x1 = coo_table_elemwise_d(gi, 3*nc1-2)
    y1 = coo_table_elemwise_d(gi, 3*nc1-1)

    x2 = coo_table_elemwise_d(gi, 3*nc2-2)
    y2 = coo_table_elemwise_d(gi, 3*nc2-1) 

    ln = sqrt( (x2 - x1)**2 + (y2 - y1)**2 )

    norm(1) = ( y2 - y1 ) / ln
    norm(2) = ( x1 - x2 ) / ln

    flux     = 0.d0
    kvoisin = boundary_d(gi,nc1,1)
    id_entree = boundary_d(gi,nc1,2)

    if(nc1 == 1) then 
      s1(ti,1) = vdlg_d(1,gi)
      s1(ti,2) = zm_d(gi)
    endif

    call syncthreads()

    hautl  = s1(ti,1)
    zml    = s1(ti,2)

    call syncthreads()

    if ( hautl> tolisec_d ) then
      if(nc1 == 1) then 
        s1(ti,1) = vdlg_d(2,gi)
        s1(ti,2) = vdlg_d(3,gi)
      endif

      call syncthreads()

      hul    = s1(ti,1)
      hvl    = s1(ti,2)

      vitul = (hul * norm(1) + hvl * norm(2) ) / hautl
      vitvl = (hvl * norm(1) - hul * norm(2) ) / hautl
    else
      hautl = tolisec_d
      vitul = 0.d0
      vitvl = 0.d0
    endif

    ! *** application des conditions aux limites si kvol est frontier ***
    if ( kvoisin == -1 ) then ! *** flux entrant ***
      if ( inlet_d == 1 ) then       ! inlet_d = 1 == Entree transmissive
        if (test_d==5) hautl = 1 + 0.75*cos(2*3.14159265358979*tc_d/3600)
        if ( hautl > tolisec_d ) then
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        endif
      elseif ( inlet_d == 2 ) then   ! inlet_d = 2 = Entree avec debit
        ! if ( hautl > tolisec_d ) then
          debitnorm = -debitglob_d(id_entree) / long_entree_d(id_entree)
          flux(1) = debitnorm
          flux(2) = norm(1) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
          flux(3) = norm(2) * ( debitnorm**2/hautl  + gp_d * hautl*(hautl+zml) )
          debit_entree_arr_d(io_identifier_d(gi),1) = (-debitnorm)*ln    
          debit_entree_arr_d(io_identifier_d(gi),2) = id_entree
        ! else
        !   hautl = tolisec_d             
        !   flux(1) = 0.d0
        !   flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        !   flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
        ! endif
      else
        write(*,*) 'donnee inlet_d non convenable'
      endif
    endif

    if ( kvoisin == -2 ) then ! *** flux sortant ***
      if ( hautl > tolisec_d ) then
        if ( vitul > 0.d0 .and. vitul/sqrt(gp_d*hautl) < 1.d0 ) then
          hautl = h_sortie_d(id_entree) - zml
          if ( hautl > tolisec_d ) then
            flux(1) = hautl * vitul
            flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
            flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
          else
            flux(1) = 0.d0
            flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
            flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
          endif
        else
          flux(1) = hautl * vitul
          flux(2) = norm(1) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) - norm(2) * hautl * vitul * vitvl
          flux(3) = norm(2) * ( hautl * vitul**2 + gp_d * hautl*(hautl+zml) ) + norm(1) * hautl * vitul * vitvl
        endif
      else
        flux(1) = 0.d0
        flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
        flux(3) = norm(2) * gp_d * hautl*(hautl+zml)   
      endif

      if ( vitul > 0.d0)  then 
        debit_sortie_arr_d(io_identifier_d(gi))  = flux(1)*ln
      else
        debit_sortie_arr_d(io_identifier_d(gi))  = 0.d0
      endif
    endif

    if ( kvoisin == -3 ) then  ! *** flux de mur ***
      if (hautl > tolisec_d) then
        zmr   =  zml
        hautr =  hautl
        vitur = -vitul
        vitvr = -vitvl
        call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
      else
        flux(1) = 0.d0
        flux(2) = 0.d0
        flux(3) = 0.d0
      endif
    endif

    if  ( kvoisin > 0. ) then   ! *** kvol fait frontiere avec kvoisin ***
      hautr = vdlg_d(1,kvoisin)  !this is inefficient global memory access, put vdlg_d in shared? possible?
      zmr = zm_d(kvoisin)        !this is also inefficient global memory access

      if ( hautr > tolisec_d ) then
        hur    = vdlg_d(2,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory
        hvr    = vdlg_d(3,kvoisin)  ! this is very  inefficient global memory access, can be done may be by shared memory

        vitur = ( hur * norm(1) + hvr * norm(2) ) / hautr
        vitvr = ( hvr * norm(1) - hur * norm(2) ) / hautr

      else
        hautr = tolisec_d
        vitur = 0.d0
        vitvr = 0.d0
        hybrid = 0
      endif

      call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)

      ! *** WET and DRY
      ! *** Prolongement du niveau d'eau sur le sec pour éviter la création d'un gradient
      if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zmr > hautl+zml ) then
          !Transitoire : Cellule calculée mouillée - Cellule voisine sèche ***
          if ( vitul > sqrt(2*gp_d*(zmr-zml) ) ) then
            zmr = zml+hautl  
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = norm(1) * gp_d * hautl*(hautl+zml)
            flux(3) = norm(2) * gp_d * hautl*(hautl+zml)
          endif
        endif   ! de if( zmr > hautl+zml ) then

      elseif( hautl <= tolisec_d .and. hautr > tolisec_d ) then  ! de if (hautr <= tolisec_d .and. hautl > tolisec_d) then
        if( zml >= hautr+zmr ) then 
          !               Transitoire : Cellule calculée sèche  - Cellule voisine mouillée 
          if ( -vitur > sqrt(2*gp_d*(zml-zmr) ) .and. vitur < 0) then
            zml   = zmr+hautr
            call solver_Riemann_cudaf(gi,kvoisin,surf_d,norm,vdlg_d,hautl,vitul,vitvl,hautr,vitur,vitvr,zml,zmr,hybrid,flux,ln,pp)
          else
            flux(1) = 0.d0
            flux(2) = 0.d0
            flux(3) = 0.d0
          endif
        endif ! de if( zml >= hautr+zmr ) then
      endif   ! (hautr <= tolisec_d .and. hautl > tolisec_d) then

      ! Cas de deux éléments voisins secs **********************************************
      if (test_d /=1) then  ! Necessaire dans la cas de la prairie
        if (hautl <= tolisec_d .and. hautr <= tolisec_d) then
          flux(1) = 0.d0
          flux(2) = 0.d0
          flux(3) = 0.d0
        endif
      endif
    endif ! de ( kvoisin > 0. )

    s1(ti, tj)   = flux(1) * ln
    call syncthreads()

    if(tj == 1)   resc_d(1,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3) + s1(ti, 4)
    call syncthreads()

    s1(ti, tj)   = flux(2) * ln
    call syncthreads()
    if(tj == 1)   resc_d(2,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3) + s1(ti, 4)
    call syncthreads()

    s1(ti, tj)   = flux(3) * ln
    call syncthreads()
    if(tj == 1)   resc_d(3,gi) = s1(ti, 1) + s1(ti, 2) + s1(ti, 3) + s1(ti, 4)

  endif ! Fin de if(gi<nelt_d) 
end subroutine cotes_cudaf4


attributes(device) subroutine upwindmean_cudaf(kvol,kvoisin,surf,vdlg,xupwind,yupwind,hautdec,vitudec,vitvdec)
  ! ======================================================================
  !     upwindmean_cudaf = calcul une moyenne decentree de l'etat du cote de kvol
  !     auteur : Youssef Loukili  GRANIT ETSMTL
  !     version : 1.0  ;  May 12 2003
  ! ======================================================================
  
  use global_device
  use precision_m

  implicit none

  integer, intent(in)                           :: kvol, kvoisin
  real(fp_kind), dimension(:), intent(in)       :: surf
  real(fp_kind), dimension(:,:), intent(in)     :: vdlg
  real(fp_kind), intent(inout)                  :: hautdec, vitudec, vitvdec
  real(fp_kind), intent(inout)                  :: xupwind, yupwind

  integer                       :: i, j, noeud1, noeud2, elemupw
  integer, dimension(4)         :: elemkvol
  real(fp_kind)                 :: xnoeud1, xnoeud2, ynoeud1, ynoeud2, xface, yface
  real(fp_kind)                 :: dnoeud12, norm1, norm2, celer
  real(fp_kind)                 :: hautl, vitul, vitvl, hautr, vitur, vitvr
  real(fp_kind)                 :: xelemkvol, yelemkvol, surfupw, difhaut, surfarea, vdlg_elem1

  xupwind = 0.d0
  yupwind = 0.d0
  hautdec = 0.d0
  vitudec = 0.d0
  vitvdec = 0.d0
  surfupw = 0.d0

  IF ( ns_d == 3 ) THEN
    hautl = vdlg(1,kvol)
    do i=1,ns_d
      elemkvol(i) = boundary_d(kvol,i,1)
      if ( elemkvol(i) == -1 .or. elemkvol(i) == -2 ) then ! *** flux entrant ou sortant ***
        surfarea = surf(kvol)
        hautdec  = hautdec + surfarea * hautl
        vitudec  = vitudec + surfarea * vdlg(2,kvol) / hautl
        vitvdec  = vitvdec + surfarea * vdlg(3,kvol) / hautl
        surfupw  = surfupw + surfarea

      else if ( elemkvol(i) == -3 ) then  ! *** flux nul ***
        !           pour mur non glissant ###
        surfarea = surf(kvol)
        surfupw = surfupw + surfarea
        hautdec = hautdec + surfarea * hautl

      else if (elemkvol(i) /= kvoisin) then   ! *** kvol frontier avec 1 vol /= kvoisin ***
        surfarea = surf(elemkvol(i))
        surfupw = surfupw + surfarea
        vdlg_elem1 = vdlg(1,elemkvol(i))
        hautdec = hautdec + surfarea * vdlg_elem1
        vitudec = vitudec + surfarea * vdlg(2,elemkvol(i)) / vdlg_elem1
        vitvdec = vitvdec + surfarea * vdlg(3,elemkvol(i)) / vdlg_elem1
      endif
    enddo

    hautdec = hautdec / surfupw
    vitudec = vitudec / surfupw
    vitvdec = vitvdec / surfupw
  ENDIF
end subroutine upwindmean_cudaf

attributes(device) subroutine solver_Riemann_cudaf(kvol,kvoisin,surf,norm,vdlg,hl,ul,vl,hr,ur,vr,zml,zmr,model,flux,ln,pp)
  ! **********************************************************************
  !     lax_method = calcul du flux de eta par la méthode "lax-fredrichs"
  ! == référence : analysis of the discontinuous galerkin method 
  ! ==             applied to the diffusion operator.
  ! ==             harold l. atkins - nasa langley research center.
  ! ==             chi-wang shu - brown university.
  ! ==             14th aiaa computational fluid dynamics conference
  ! ==             28 - 31 june 1999, norfolk, va.
  !     auteur : youssef loukili  granit etsmtl
  !     version : 1.0  ;  may 12 2003
  ! ======================================================================

  use precision_m
  use global_device
  implicit none

  interface

    attributes(device) subroutine upwindmean_cudaf(kvol,kvoisin,surf,vdlg,xupwind,yupwind,hautdec,vitudec,vitvdec)

      use global_device
      use precision_m

      integer, intent(in)                           :: kvol, kvoisin
      real(fp_kind), dimension(:), intent(in)       :: surf
      real(fp_kind), dimension(:,:), intent(in)     :: vdlg
      real(fp_kind), intent(inout)                  :: hautdec, vitudec, vitvdec
      real(fp_kind), intent(inout)                  :: xupwind, yupwind
    end subroutine upwindmean_cudaf

  end interface

  integer, intent(in)                         :: kvol, kvoisin, model
  integer, intent(inout)                      :: pp
  real(fp_kind), intent(in)                   :: hl, ul, vl, hr, ur, vr, zml, zmr, ln
  real(fp_kind), dimension(2), intent(in)     :: norm
  real(fp_kind), dimension(3), intent(inout)  :: flux
  real(fp_kind), dimension(:), intent(in)     :: surf
  real(fp_kind), dimension(:,:), intent(in)   :: vdlg

  real(fp_kind)                 :: hm, cel, vitess, vitesm, vitesp, hp !,cell, celr
  real(fp_kind)                 :: hl2, hr2, zml2, zmr2
  real(fp_kind), dimension(3)   :: fl, fr, flux1, alfa_corrige
  real(fp_kind), dimension(2,3) :: f

  integer                 :: i, noeud, dl ,p
  real(fp_kind)                 :: udeclg, vdeclg, udecrg, vdecrg, limiteurh, limiteurhu, limiteurhv
  real(fp_kind)                 :: hdecl, udecl, vdecl, hdecr, udecr, vdecr
  real(fp_kind)                 :: al, ar, het, gl, gr, sl, sr, set, xl, xr
  real(fp_kind)                 :: xleftupw, yleftupw, xrigtupw, yrigtupw, lamda_local
  real(fp_kind), dimension(3)   :: courant, bbb, psi, ratio, dloc, dupw
  real(fp_kind), dimension(5)   :: poids

  pp = pp + 1
  hp = hl     

  f(1,1) = hl * ul
  f(1,2) = hl * ul**2 + gp_d*hp*(hl+zml)            
  f(1,3) = hl * ul * vl
  f(2,1) = hr * ur
  f(2,2) = hr * ur**2 + gp_d*hp*(hr+zmr)
  f(2,3) = hr * ur * vr

  if ( hr <= tolisec_d .or. hl <= tolisec_d )  then
    ! *** calcul de la celerite et de la vitsse de propagation d'onde ***
    hm     = (hl + hr) / 2.d0 
    vitess = (ul + ur) / 2.d0

    cel =  sqrt( gp_d * hm )
    vitesm = vitess  - cel
    vitesp = vitess  + cel

    lamda_local = max( abs(vitesm) , abs(vitess) , abs(vitesp) )          

    fl(1) = (hr + zmr) - (hl+zml)
    fl(2) = hr * ur - hl * ul
    fl(3) = hr * vr - hl * vl

    do dl=1,ndln_d
      flux1(dl) = ( f(1,dl) + f(2,dl) - lamda_local * fl(dl) ) / 2.d0
    enddo

  else    !  L interface separe deux cellules mouillees
    !           *** celerités a gauche et a droite ***
    al = sqrt( gp_d * hl )
    ar = sqrt( gp_d * hr )

    !           *** profondeur dans la region etoile ***  Shock-Capturing Methods for Free-Surface Shallow Flows : Toro
    het  =  ( hl + hr ) / 2  -  ( ur - ul ) * ( hl + hr ) / ( al + ar ) / 4     ! formules (10.17 / 10.18) p178/179

    if ( het.le.min(hl,hr) ) then       ! == onde de rarefaction :
      het = ( ( al + ar )/2 + ( ul - ur )/4 )**2 / gp_d
    else
      gl = sqrt( 0.5 * gp_d * ( het + hl ) / ( het * hl ) )
      gr = sqrt( 0.5 * gp_d * ( het + hr ) / ( het * hr ) )
      het = ( hl * gl + hr * gr + ul - ur ) / ( gl + gr )
    endif
    !           *** vitesses d'ondes ***
    if ( hl <= tolisec_d ) then
      sl  = ur - 2 * ar
      sr  = ur + ar
      set = sl
    else if ( hr <= tolisec_d ) then
      sl  = ul - al
      sr  = ul + 2 * al
      set = sr
    else
      if ( het > hl ) then
        sl = ul - al * sqrt( het * (het + hl) / 2 ) / hl
      else
        sl = ul - al
      endif
      if ( het > hr ) then
        sr = ur + ar * sqrt( het * (het + hr) / 2 ) / hr
      else
        sr = ur + ar
      endif
      set = ( sl * hr * ( ur - sr ) - sr * hl * ( ul - sl ) ) /  ( hr * ( ur - sr ) - hl * ( ul - sl ) )
    endif

    !			Flux HLLC
    if ( sl >= 0 ) then
      do dl=1, ndln_d
        flux1(dl) = f(1,dl)
      enddo
    elseif ( sr <= 0 ) then
      do dl=1, ndln_d
        flux1(dl) = f(2,dl)
      enddo
    elseif ( sl < 0 .and. set >= 0 ) then
      flux1(1) = ( sr * f(1,1) - sl * f(2,1) + sl * sr * ( hr - hl ) ) / ( sr - sl )
      flux1(2) = ( sr * f(1,2) - sl * f(2,2) + sl * sr * (hr*ur - hl*ul) ) / ( sr - sl )
      flux1(3) = flux1(1) * vl
    elseif ( set <= 0 .and. sr > 0 ) then
      flux1(1) = ( sr * f(1,1) - sl * f(2,1) + sl * sr * ( hr - hl ) ) / ( sr - sl )
      flux1(2) = ( sr * f(1,2) - sl * f(2,2) + sl * sr * (hr*ur - hl*ul) ) / ( sr - sl )
      flux1(3) = flux1(1) * vr
    endif
  endif !		de ''if ( hr <= tolisec_d .or. hl <= tolisec_d )''

  ! *** inersion du flux ***
  flux(1) = flux1(1)
  flux(2) = norm(1) * flux1(2) - norm(2) * flux1(3)
  flux(3) = norm(2) * flux1(2) + norm(1) * flux1(3)                       
end subroutine solver_Riemann_cudaf
